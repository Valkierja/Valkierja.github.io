---
title: 回调函数和匿名回调法
poc: true
categories:
  - [信息安全, 二进制]
  - [开发, GamePlay]
tags: [回调函数]
id: '379'
date: 2021-08-20 02:53:29
---

之前在Unity开发的时候遇到一个现象：同样是unity对外暴露的接口函数，同样都是程序自身完全没有调用过（但都是unity会调用的）但是rider对其语法高亮却不同，这主要是回调函数和普通函数的区别

回调函数应当理解为委托与委托的回收，当然也可以单纯理解为提前声明但是没有定义，或者没有完整定义的函数

不过前者是底层本质

更深层的说，比如微软已经基本写好一个函数，这个函数一般是作为某类委托的回调函数的主调

但是这个函数并不是完整定义的，因为微软并不知道你需要如何处理委托，比如打印字符，微软并不知道你想如何打印（实际上printf之类的函数并不是回调函数，举个例子而已），于是微软只会放一个打印接口，然后让程序员自己补全里面的细节内容，但并不是让程序员直接补全，因为直接补全意味着修改系统文件，是高危行为，实际上的补全方法是利用回调函数的入口点地址传参进去（参数名adr）

然后call @adr即可，这样就从控制权就从系统函数移交到用户函数，ring0变ring3，风险性降低

这个补全的过程称为**登记**

“回”这个字来自于从ring0**返回**ring3的过程

unity底层代码看不懂，这里找了个python的例子

假设我们现在由于某密码算法需求，需要各种同余群，比如2k＋1，4k＋1，6k＋1，8k＋1...

但是我们需要的**种类**是无限的，因此，传统写法无法满足需求：if，switch不能无限，而且传统写法也需要声明无数个函数，如果用**回调＋匿名递归**则可以非常漂亮的完成

```
#OddNumGroupGenerator.py
def getOddNumber(k, getEvenNumber):
    return 1 + getEvenNumber(k)

#main.py
from OddNumGroupGenerator import *
def main():
      i = getOddNumber(k, lambda x: x * 2*n)  #完美
   
```

n为需要的自然数,如果需要4k＋1群，则2\*n=4即n=2,当然也可以控制n的值为偶数(通过偶数生成器的返回值),然后把2\*n改为n

另外，窗口的回调函数往往称为窗口过程