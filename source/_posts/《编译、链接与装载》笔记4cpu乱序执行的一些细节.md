---
title: 《编译、链接与装载》笔记(4)CPU乱序执行的一些细节行为，以及会引发的问题
poc: true
categories:
  - 硬件
tags: []
id: '794'
date: 2021-09-07 17:49:25
---

源码

![](https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172053290.png)

假设实例指针pInstance，则下面的操作是在多线程下是危险的多发行为

`pInstance = new T`

因为这个操作的三个步骤允许被CPU乱序执行:

第一步,分配内存空间

第二步,把这个空间的地址传给构造函数然后调用构造函数

第三步,把这个空间的地址赋给 `pInstance`

第二第三步是互不影响的,所以会被乱序执行

假设首先第三步执行,然后开始执行构造函数,但是还没执行完毕,此时另一个线程来到第一个if,得到false,然后直接返回,而他返回的对象是还没有构造完毕的实例

**这种极端情况下的new函数调用，是很大一部分复现率并非100%的bug的来源**，说人话就是

**直接调用new在多线程高发情形下，非常不安全**

正确做法是先new到tmp里面，然后加栅（barrier），然后再把tmp赋给pInstance