---
title: 句柄类家族详解笔记
poc: true
categories:
  - [开发, Windows]
  - [笔记, 存档]
tags: [需要修改]
id: '433'
date: 2021-08-21 05:46:34
---

首先是补一些历史课

在Windows还是一个16位操作系统的年代，句柄和API的思想已经比较成熟了

那时候的内存区块还不是flat mod，所以需要区分指向同一份dll模块的不同指针拷贝，为了这样的需求，微软首次发明了实例的概念，每个拷贝是一个实例，所以句柄实例的类型是hInstance类

后来win32内存变为flat mod，同时保护模式的CPU和一些Windows的安全机制，于是区分拷贝实例也不再必要了，这一时期的句柄相关API使用的是hMoudle类，另外窗体使用的是hWND类，然后又有了通用的HANDLE类

但其实后来微软统一了一下，现在在头文件里面他们是一个东西23333

```
typedef PVOID HANDLE;
typedef HANDLE HWND;
typedef HANDLE HINSTANCE;
typedef HINSTANCE HMODULE;
```

顺便有点好奇空指针的实际意义，顺着找到了某大神的解答

pVOID，aka "Pointer to something, but it's up to you to figure it out"

简直完美，另外有一段解答

![](https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172113311.png)

但是因此感觉空指针会危险很多，而且出了bug不好修，自己写些小东西的话还是少用吧

历史课结束

句柄涵盖的范围很广，包括常见的模块，窗体，线程等，也包括静态资源（也很常见，但和其他动态资源比起来，这位有点异端）的临时（程序关闭就结束）全局索引

另外，任何模块的句柄在数值上等于模块装入内存的起始地址，书中原话是“模块句柄在数值上等于程序在内存中装入的起始地址”，应该是作者写错了，已经提交勘误，不过我估计琢石成器这种老书也很难再版了吧。。

句柄的概念更像是一种黑匣子

我们去商场购物，要存东西，存好东西之后，存包机吐出来一个条形码，这里我们假设条形码翻译出来的数字就是句柄，而这个句柄对应的资源就是我们的包

但是我们（作为调用资源的应用程序）并不需要知道这个数字是怎么生成的，只需要把这个句柄作为凭证告知操作系统，操作系统就会返还对应资源（我们存的包）

但实际上真正的句柄也不是一种凭证，句柄的调用是基于flat模式安全性的，不存在越权一说，只需要有一个数字就行，数字本身不具有电子签名能力（但是条形码有凭证签名能力，因为可以默认顾客不会带着打印机来商场伪造条形码）

姑且先写这些，有一些其他细节还在考证（也可能之后就懒得考证了，因为都是一些特别底层的东西，感觉也暂时没必要了解）