---
title: 80386与8086内存寻址机制的区别及MMU访问分权底层机制
poc: true
categories:
  - [笔记, 存档]
tags: []
id: '233'
date: 2021-08-09 18:11:48
---

写了很多东西啊,一边写一边看,然后看到了一句话,于是都删了,因为发现这些内容没啥用

![](https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172108944.png)

## 现在可公开的信息

首先要理解各种机制再历史上出现的时间顺序和因果顺序

首先是当时技术力如果想要大面积制造寄存器,那么只能是制造16位的,但是以当时的软件普遍开支来看,20位的总线才能算很够用,因此8086实模式采用了线性地址10H×偏移+段地址

但是发展到32位之后,20位的总线已经不需要使用两个16位寄存器填满数据了,相反还需要扩大总线为32位

当时眼光来看 4GB的空间已经十分够用,所以就保持了这样

但是段寄存器就显得毫无用处了,因为我们只需要一个偏移地址寄存器就可以寻址所有4GB内存空间

此时在保护模式和实模式的区别就显现出来了,实模式直接通过段寄存器和偏移地址寻址,是"实实在在的物理地址"

而保护模式下的段寄存器则变为保护信息段选择器，通过该寄存器从段描述符表中选择权限，优先级，门描述符等

只有这些属性确定了，才可以对相应内存区块进行操作

但为什么我们在逆向32位程序的时候，并未在汇编代码当中发现段选择器的相关内容？

因为这种底层信息交给程序员修改太不安全了，所以：

![](https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172107409.png)

![](https://raw.githubusercontent.com/Valkierja/ALLPIC/main/img/202303172108648.png)

另外是分页和虚拟内存，

实际上可以把虚拟内存看作未加载的页，缺页时尝试加载的话才会放入物理内存

或者换句话来说，虚拟内存其实就是硬盘空间，虚拟内存某种意义上根本不是物理内存的衍生，因为他所包含的内容是待加载的页，或者是已经加载过但是暂时不需要的页，我们可以认为虚拟内存就是硬盘空间，因为虚拟内存的所有物理属性都和实际的硬盘相同，他只是划分了一个空间，这段线性空间便于寻道，用于存放完全未加载的东西的copy

这段话不知道有没有说明白

此外物理内存到虚拟内存的映射是指针式的

被映射的dll实际上只有一份,无论是源文件,还是虚拟内存中的copy还是物理内存的指针

这样的话,一万个程序如果都调用了一个相同的dll当中的相同api,内存开销其实是非常小的

另外有一种攻击手法,我们可以修改页表并指定一个并不存在的页面映射,或者说是伪造的页面映射