---
title: 程序:从静态文件到装载为进程
poc: true
categories:
- [笔记, 编译原理]
- [开发]
tags: [装载器, 编译器, 进程, 动态内存]
id: '95'
date: 2021-05-21 08:10:35
---

## 正文

什么是进程？当我们提到进程的时候，其实就是这个进程所对应的主要程序，及其所需要的程序外部资源、代码等

比如一个调用了MessageBoxW API的程序在运行时会向外部dll进行查找，进程也应当包含被查找的外部资源对象等

我们都知道，每个进程都有一个属于自己的独立的4GB的虚拟空间；如果从0000 0000开始计数的话，4GB对应为FFFF FFFF，但实际上这片空间并不是平权的，大致可以分为：

![](https://static.zhishibox.net/20210315/image_109593497.png)

如果只是死记硬背这些数值的话，倒也没什么意义

这里记录一下困扰笔者的一点：

空指针赋值区原则上来说只需要0000 0000地址处为0就足够所有程序使用了；防止越界的禁入区原则上来说44kb也够用了；就算是为了安全考虑，64kb大小的NULLptr空间，未免也太过冗余了吧；经查，这与**分配粒度**，**字节对齐**等有关，网上大部分资料指向Window核心编程的相关章节；经查该章节及其前后部分并未说明**分配粒度**的定义，同时**分配粒度**一词并无维基百科词条，进而在看雪、52上搜索，找到一篇远古文章，原文链接如下

https://web.archive.org/web/20110117113240/http://blog.ednchina.com/colinluan/238299/message.aspx#78067

"若仅仅解释为**对齐需要**的话，64kb也未免有些太大了"；经查，这一操作是为了向后兼容，防止由于各种原因需要在用户模式区之前加入一小段机器码，因此**缺省对齐值大于最小合法对齐值**

需要特别提及的一点是，64kb禁入区在MMU内部映射表中，不指向任何实际的物理内存区块

每个进程独立的虚拟空间，只有低2G区域，高2G区域的内核段是所有程序共用的，操作系统需要在这部分区域中加载各类dll以及其他外部资源

所有的进程都是由其他进程创建的，第一个进程（PID==0）是由操作系统内核创建的